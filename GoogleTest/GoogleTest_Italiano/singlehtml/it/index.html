<!DOCTYPE html>

<html lang="it" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Documentazione GoogleTest 1.16.0</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=40435999"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=45930005"></script>
    <link rel="index" title="Indice" href="genindex.html" />
    <link rel="search" title="Cerca" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="welcome-to-googletest-s-documentation">
<h1>Benvenuti nella Documentazione di GoogleTest!<a class="headerlink" href="#welcome-to-googletest-s-documentation" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-docs/index"></span><section id="googletest-user-s-guide">
<h2>Guida Utente di GoogleTest<a class="headerlink" href="#googletest-user-s-guide" title="Link to this heading">¶</a></h2>
<section id="welcome-to-googletest">
<h3>Benvenuti in GoogleTest!<a class="headerlink" href="#welcome-to-googletest" title="Link to this heading">¶</a></h3>
<p>GoogleTest è il framework di test e mocking C++ di Google. Questa guida l’utente ha i seguenti contenuti:</p>
<ul class="simple">
<li><p><span class="xref myst">Guida di GoogleTest</span> - Insegna come scrivere semplici test utilizzando GoogleTest. I principianti dovrebbero cominciare da qui.</p></li>
<li><p><span class="xref myst">GoogleTest Advanced</span> - Leggere questo, dopo la Guida per utilizzare GoogleTest al massimo delle sue potenzialità.</p></li>
<li><p><span class="xref myst">Esempi di Googletest</span> - Descrive degli esempi di GoogleTest.</p></li>
<li><p><span class="xref myst">FAQ di GoogleTest</span> - Ci sono domande? Si cercano Suggerimenti? Controllare prima qui.</p></li>
<li><p><span class="xref myst">Mocking per Principianti</span> - Insegna come creare oggetti mock e come utilizzarli nei test.</p></li>
<li><p><span class="xref myst">Mocking Cookbook</span> - Include suggerimenti e approcci ai casi d’uso comuni di mocking.</p></li>
<li><p><span class="xref myst">Cheat Sheet del Mocking</span> - Un pratico riferimento per matcher, azioni, invarianti e altro.</p></li>
<li><p><span class="xref myst">Mocking FAQ</span> - Contiene le risposte ad alcune domande specifiche sul mocking.</p></li>
</ul>
</section>
</section>
<span id="document-CONTRIBUTING"></span><section id="how-to-become-a-contributor-and-submit-your-own-code">
<h2>How to become a contributor and submit your own code<a class="headerlink" href="#how-to-become-a-contributor-and-submit-your-own-code" title="Link to this heading">¶</a></h2>
<section id="contributor-license-agreements">
<h3>Contributor License Agreements<a class="headerlink" href="#contributor-license-agreements" title="Link to this heading">¶</a></h3>
<p>We’d love to accept your patches! Before we can take them, we have to jump a
couple of legal hurdles.</p>
<p>Please fill out either the individual or corporate Contributor License Agreement
(CLA).</p>
<ul class="simple">
<li><p>If you are an individual writing original source code and you’re sure you
own the intellectual property, then you’ll need to sign an
<a class="reference external" href="https://developers.google.com/open-source/cla/individual">individual CLA</a>.</p></li>
<li><p>If you work for a company that wants to allow you to contribute your work,
then you’ll need to sign a
<a class="reference external" href="https://developers.google.com/open-source/cla/corporate">corporate CLA</a>.</p></li>
</ul>
<p>Follow either of the two links above to access the appropriate CLA and
instructions for how to sign and return it. Once we receive it, we’ll be able to
accept your pull requests.</p>
</section>
<section id="are-you-a-googler">
<h3>Are you a Googler?<a class="headerlink" href="#are-you-a-googler" title="Link to this heading">¶</a></h3>
<p>If you are a Googler, please make an attempt to submit an internal contribution
rather than a GitHub Pull Request. If you are not able to submit internally, a
PR is acceptable as an alternative.</p>
</section>
<section id="contributing-a-patch">
<h3>Contributing A Patch<a class="headerlink" href="#contributing-a-patch" title="Link to this heading">¶</a></h3>
<ol class="arabic simple">
<li><p>Submit an issue describing your proposed change to the
<a class="reference external" href="https://github.com/google/googletest/issues">issue tracker</a>.</p></li>
<li><p>Please don’t mix more than one logical change per submittal, because it
makes the history hard to follow. If you want to make a change that doesn’t
have a corresponding issue in the issue tracker, please create one.</p></li>
<li><p>Also, coordinate with team members that are listed on the issue in question.
This ensures that work isn’t being duplicated and communicating your plan
early also generally leads to better patches.</p></li>
<li><p>If your proposed change is accepted, and you haven’t already done so, sign a
Contributor License Agreement
(<a class="reference internal" href="#contributor-license-agreements">see details above</a>).</p></li>
<li><p>Fork the desired repo, develop and test your code changes.</p></li>
<li><p>Ensure that your code adheres to the existing style in the sample to which
you are contributing.</p></li>
<li><p>Ensure that your code has an appropriate set of unit tests which all pass.</p></li>
<li><p>Submit a pull request.</p></li>
</ol>
</section>
<section id="the-google-test-and-google-mock-communities">
<h3>The Google Test and Google Mock Communities<a class="headerlink" href="#the-google-test-and-google-mock-communities" title="Link to this heading">¶</a></h3>
<p>The Google Test community exists primarily through the
<a class="reference external" href="https://groups.google.com/group/googletestframework">discussion group</a> and the
GitHub repository. Likewise, the Google Mock community exists primarily through
their own <a class="reference external" href="https://groups.google.com/group/googlemock">discussion group</a>. You
are definitely encouraged to contribute to the discussion and you can also help
us to keep the effectiveness of the group high by following and promoting the
guidelines listed here.</p>
<section id="please-be-friendly">
<h4>Please Be Friendly<a class="headerlink" href="#please-be-friendly" title="Link to this heading">¶</a></h4>
<p>Showing courtesy and respect to others is a vital part of the Google culture,
and we strongly encourage everyone participating in Google Test development to
join us in accepting nothing less. Of course, being courteous is not the same as
failing to constructively disagree with each other, but it does mean that we
should be respectful of each other when enumerating the 42 technical reasons
that a particular proposal may not be the best choice. There’s never a reason to
be antagonistic or dismissive toward anyone who is sincerely trying to
contribute to a discussion.</p>
<p>Sure, C++ testing is serious business and all that, but it’s also a lot of fun.
Let’s keep it that way. Let’s strive to be one of the friendliest communities in
all of open source.</p>
<p>As always, discuss Google Test in the official GoogleTest discussion group. You
don’t have to actually submit code in order to sign up. Your participation
itself is a valuable contribution.</p>
</section>
</section>
<section id="style">
<h3>Style<a class="headerlink" href="#style" title="Link to this heading">¶</a></h3>
<p>To keep the source consistent, readable, diffable and easy to merge, we use a
fairly rigid coding style, as defined by the
<a class="reference external" href="https://github.com/google/styleguide">google-styleguide</a> project. All patches
will be expected to conform to the style outlined
<a class="reference external" href="https://google.github.io/styleguide/cppguide.html">here</a>. Use
<a class="reference external" href="https://github.com/google/googletest/blob/main/.clang-format">.clang-format</a> to
check your formatting.</p>
</section>
<section id="requirements-for-contributors">
<h3>Requirements for Contributors<a class="headerlink" href="#requirements-for-contributors" title="Link to this heading">¶</a></h3>
<p>If you plan to contribute a patch, you need to build Google Test, Google Mock,
and their own tests from a git checkout, which has further requirements:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.python.org/">Python</a> v3.6 or newer (for running some of the
tests and re-generating certain source files from templates)</p></li>
<li><p><a class="reference external" href="https://cmake.org/">CMake</a> v2.8.12 or newer</p></li>
</ul>
</section>
<section id="developing-google-test-and-google-mock">
<h3>Developing Google Test and Google Mock<a class="headerlink" href="#developing-google-test-and-google-mock" title="Link to this heading">¶</a></h3>
<p>This section discusses how to make your own changes to the Google Test project.</p>
<section id="testing-google-test-and-google-mock-themselves">
<h4>Testing Google Test and Google Mock Themselves<a class="headerlink" href="#testing-google-test-and-google-mock-themselves" title="Link to this heading">¶</a></h4>
<p>To make sure your changes work as intended and don’t break existing
functionality, you’ll want to compile and run Google Test and GoogleMock’s own
tests. For that you can use CMake:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>mkdir mybuild
cd mybuild
cmake -Dgtest_build_tests=ON -Dgmock_build_tests=ON ${GTEST_REPO_DIR}
</pre></div>
</div>
<p>To choose between building only Google Test or Google Mock, you may modify your
cmake command to be one of each</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cmake -Dgtest_build_tests=ON ${GTEST_DIR} # sets up Google Test tests
cmake -Dgmock_build_tests=ON ${GMOCK_DIR} # sets up Google Mock tests
</pre></div>
</div>
<p>Make sure you have Python installed, as some of Google Test’s tests are written
in Python. If the cmake command complains about not being able to find Python
(<code class="docutils literal notranslate"><span class="pre">Could</span> <span class="pre">NOT</span> <span class="pre">find</span> <span class="pre">PythonInterp</span> <span class="pre">(missing:</span> <span class="pre">PYTHON_EXECUTABLE)</span></code>), try telling it
explicitly where your Python executable can be found:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cmake</span> <span class="o">-</span><span class="n">DPYTHON_EXECUTABLE</span><span class="o">=</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">python</span> <span class="o">...</span>
</pre></div>
</div>
<p>Next, you can build Google Test and / or Google Mock and all desired tests. On
*nix, this is usually done by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span>
</pre></div>
</div>
<p>To run the tests, do</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">test</span>
</pre></div>
</div>
<p>All tests should pass.</p>
</section>
</section>
</section>
<span id="document-README"></span><section id="googletest">
<h2>GoogleTest<a class="headerlink" href="#googletest" title="Link to this heading">¶</a></h2>
<section id="announcements">
<h3>Announcements<a class="headerlink" href="#announcements" title="Link to this heading">¶</a></h3>
<section id="documentation-updates">
<h4>Documentation Updates<a class="headerlink" href="#documentation-updates" title="Link to this heading">¶</a></h4>
<p>Our documentation is now live on GitHub Pages at
https://google.github.io/googletest/. We recommend browsing the documentation on
GitHub Pages rather than directly in the repository.</p>
</section>
<section id="release-1-17-0">
<h4>Release 1.17.0<a class="headerlink" href="#release-1-17-0" title="Link to this heading">¶</a></h4>
<p><a class="reference external" href="https://github.com/google/googletest/releases/tag/v1.17.0">Release 1.17.0</a> is
now available.</p>
<p>The 1.17.x branch
<a class="reference external" href="https://opensource.google/documentation/policies/cplusplus-support#c_language_standard">requires at least C++17</a>.</p>
</section>
<section id="continuous-integration">
<h4>Continuous Integration<a class="headerlink" href="#continuous-integration" title="Link to this heading">¶</a></h4>
<p>We use Google’s internal systems for continuous integration.</p>
</section>
<section id="coming-soon">
<h4>Coming Soon<a class="headerlink" href="#coming-soon" title="Link to this heading">¶</a></h4>
<ul class="simple">
<li><p>We are planning to take a dependency on
<a class="reference external" href="https://github.com/abseil/abseil-cpp">Abseil</a>.</p></li>
</ul>
</section>
</section>
<section id="welcome-to-googletest-google-s-c-test-framework">
<h3>Welcome to <strong>GoogleTest</strong>, Google’s C++ test framework!<a class="headerlink" href="#welcome-to-googletest-google-s-c-test-framework" title="Link to this heading">¶</a></h3>
<p>This repository is a merger of the formerly separate GoogleTest and GoogleMock
projects. These were so closely related that it makes sense to maintain and
release them together.</p>
<section id="getting-started">
<h4>Iniziamo<a class="headerlink" href="#getting-started" title="Link to this heading">¶</a></h4>
<p>See the <a class="reference external" href="https://google.github.io/googletest/">GoogleTest User’s Guide</a> for
documentation. We recommend starting with the
<a class="reference external" href="https://google.github.io/googletest/primer.html">GoogleTest Primer</a>.</p>
<p>More information about building GoogleTest can be found at
<a class="reference internal" href="#googletest/README.md"><span class="xref myst">googletest/README.md</span></a>.</p>
</section>
</section>
<section id="features">
<h3>Features<a class="headerlink" href="#features" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>xUnit test framework: <br />
Googletest is based on the <a class="reference external" href="https://en.wikipedia.org/wiki/XUnit">xUnit</a>
testing framework, a popular architecture for unit testing</p></li>
<li><p>Test discovery: <br />
Googletest automatically discovers and runs your tests, eliminating the need
to manually register your tests</p></li>
<li><p>Rich set of assertions: <br />
Googletest provides a variety of assertions, such as equality, inequality,
exceptions, and more, making it easy to test your code</p></li>
<li><p>User-defined assertions: <br />
You can define your own assertions with Googletest, making it simple to
write tests that are specific to your code</p></li>
<li><p>Death tests: <br />
Googletest supports death tests, which verify that your code exits in a
certain way, making it useful for testing error-handling code</p></li>
<li><p>Fatal and non-fatal failures: <br />
You can specify whether a test failure should be treated as fatal or
non-fatal with Googletest, allowing tests to continue running even if a
failure occurs</p></li>
<li><p>Value-parameterized tests: <br />
Googletest supports value-parameterized tests, which run multiple times with
different input values, making it useful for testing functions that take
different inputs</p></li>
<li><p>Type-parameterized tests: <br />
Googletest also supports type-parameterized tests, which run with different
data types, making it useful for testing functions that work with different
data types</p></li>
<li><p>Various options for running tests: <br />
Googletest provides many options for running tests including running
individual tests, running tests in a specific order and running tests in
parallel</p></li>
</ul>
</section>
<section id="supported-platforms">
<h3>Piattaforme Supportate<a class="headerlink" href="#supported-platforms" title="Link to this heading">¶</a></h3>
<p>GoogleTest segue le <a class="reference external" href="https://opensource.google/documentation/policies/cplusplus-support">Foundational C++ Support Policy</a> di Google. See <a class="reference external" href="https://github.com/google/oss-policies-info/blob/main/foundational-cxx-support-matrix.md">this table</a> for a list of currently supported versions of compilers, platforms, and build tools.</p>
</section>
<section id="who-is-using-googletest">
<h3>Who Is Using GoogleTest?<a class="headerlink" href="#who-is-using-googletest" title="Link to this heading">¶</a></h3>
<p>In addition to many internal projects at Google, GoogleTest is also used by the
following notable projects:</p>
<ul class="simple">
<li><p>The <a class="reference external" href="https://www.chromium.org/">Chromium projects</a> (behind the Chrome
browser and Chrome OS).</p></li>
<li><p>The <a class="reference external" href="https://llvm.org/">LLVM</a> compiler.</p></li>
<li><p><a class="reference external" href="https://github.com/google/protobuf">Protocol Buffers</a>, Google’s data
interchange format.</p></li>
<li><p>The <a class="reference external" href="https://opencv.org/">OpenCV</a> computer vision library.</p></li>
</ul>
</section>
<section id="related-open-source-projects">
<h3>Related Open Source Projects<a class="headerlink" href="#related-open-source-projects" title="Link to this heading">¶</a></h3>
<p><a class="reference external" href="https://github.com/nholthaus/gtest-runner">GTest Runner</a> is a Qt5 based
automated test-runner and Graphical User Interface with powerful features for
Windows and Linux platforms.</p>
<p><a class="reference external" href="https://github.com/ospector/gtest-gbar">GoogleTest UI</a> is a test runner that
runs your test binary, allows you to track its progress via a progress bar, and
displays a list of test failures. Clicking on one shows failure text. GoogleTest
UI is written in C#.</p>
<p><a class="reference external" href="https://github.com/kinow/gtest-tap-listener">GTest TAP Listener</a> is an event
listener for GoogleTest that implements the
<a class="reference external" href="https://en.wikipedia.org/wiki/Test_Anything_Protocol">TAP protocol</a> for test
result output. If your test runner understands TAP, you may find it useful.</p>
<p><a class="reference external" href="https://github.com/google/gtest-parallel">gtest-parallel</a> is a test runner that
runs tests from your binary in parallel to provide significant speed-up.</p>
<p><a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=DavidSchuldenfrei.gtest-adapter">GoogleTest Adapter</a>
is a VS Code extension allowing to view GoogleTest in a tree view and run/debug
your tests.</p>
<p><a class="reference external" href="https://github.com/matepek/vscode-catch2-test-adapter">C++ TestMate</a> is a VS
Code extension allowing to view GoogleTest in a tree view and run/debug your
tests.</p>
<p><a class="reference external" href="https://pypi.org/project/cornichon/">Cornichon</a> is a small Gherkin DSL parser
that generates stub code for GoogleTest.</p>
</section>
<section id="contributing-changes">
<h3>Contributing Changes<a class="headerlink" href="#contributing-changes" title="Link to this heading">¶</a></h3>
<p>Please read
<a class="reference external" href="https://github.com/google/googletest/blob/main/CONTRIBUTING.md"><code class="docutils literal notranslate"><span class="pre">CONTRIBUTING.md</span></code></a>
for details on how to contribute to this project.</p>
<p>Happy testing!</p>
</section>
</section>
</div>
</section>
<section id="supported-platforms">
<h1>Piattaforme Supportate<a class="headerlink" href="#supported-platforms" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-docs/platforms"></span><section id="supported-platforms">
<h2>Piattaforme Supportate<a class="headerlink" href="#supported-platforms" title="Link to this heading">¶</a></h2>
<p>GoogleTest segue le <a class="reference external" href="https://opensource.google/documentation/policies/cplusplus-support">Foundational C++ Support Policy</a> di Google. Consultare <a class="reference external" href="https://github.com/google/oss-policies-info/blob/main/foundational-cxx-support-matrix.md">questa tabella</a> per un elenco delle versioni di compilatori, di piattaforme e di strumenti di building attualmente supportati.</p>
</section>
<span id="document-docs/quickstart-bazel"></span><section id="quickstart-building-with-bazel">
<h2>Quickstart: Il Building con Bazel<a class="headerlink" href="#quickstart-building-with-bazel" title="Link to this heading">¶</a></h2>
<p>Questo tutorial ha lo scopo rendere operativi con l’uso di GoogleTest col sistema di build Bazel. Se è la prima volta che si usa GoogleTest, o c’è bisogno di un ripasso, consigliamo questo tutorial come punto di partenza.</p>
<section id="prerequisites">
<h3>Prerequisiti<a class="headerlink" href="#prerequisites" title="Link to this heading">¶</a></h3>
<p>Per questo tutorial, c’è bisogno di:</p>
<ul class="simple">
<li><p>Un sistema operativo compatibile (ad esempio Linux, macOS, Windows).</p></li>
<li><p>A compatible C++ compiler that supports at least C++17.</p></li>
<li><p><a class="reference external" href="https://bazel.build/">Bazel</a> 7.0 or higher, the preferred build system used
by the GoogleTest team.</p></li>
</ul>
<p>Vedere <span class="xref myst">Supported Platforms</span> per ulteriori informazioni sulle piattaforme compatibili con GoogleTest.</p>
<p>Se Bazel non è ancora installato, consultare la <a class="reference external" href="https://bazel.build/install">Bazel installation guide</a>.</p>
<p>{: .callout .note} Nota: I comandi del terminale in questo tutorial mostrano un prompt della shell Unix, ma funzionano anche sulla riga di comando di Windows.</p>
</section>
<section id="set-up-a-bazel-workspace">
<h3>Configurare un workspace Bazel<a class="headerlink" href="#set-up-a-bazel-workspace" title="Link to this heading">¶</a></h3>
<p>Un <a class="reference external" href="https://docs.bazel.build/versions/main/build-ref.html#workspace">workspace Bazel</a> è una directory sul file system che si utilizza per gestire i file sorgenti per il software che si desideri creare. Each workspace directory has a text file named <code class="docutils literal notranslate"><span class="pre">MODULE.bazel</span></code> which may be empty, or may contain references to external dependencies required to build the outputs.</p>
<p>Innanzitutto, si crea una directory per il workspace:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mkdir my_workspace &amp;&amp; cd my_workspace
</pre></div>
</div>
<p>Next, you’ll create the <code class="docutils literal notranslate"><span class="pre">MODULE.bazel</span></code> file to specify dependencies. As of Bazel
7.0, the recommended way to consume GoogleTest is through the
<a class="reference external" href="https://registry.bazel.build/modules/googletest">Bazel Central Registry</a>. To do
this, create a <code class="docutils literal notranslate"><span class="pre">MODULE.bazel</span></code> file in the root directory of your Bazel workspace
with the following content:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># MODULE.bazel</span>

<span class="c1"># Choose the most recent version available at</span>
<span class="c1"># https://registry.bazel.build/modules/googletest</span>
<span class="n">bazel_dep</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;googletest&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.17.0&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Ora si è pronti per creare codice C++ che utilizza GoogleTest.</p>
</section>
<section id="create-and-run-a-binary">
<h3>Crea ed eseguire un file binario<a class="headerlink" href="#create-and-run-a-binary" title="Link to this heading">¶</a></h3>
<p>Una volta configurato il workspace Bazel, si può utilizzare il codice GoogleTest all’interno del progetto.</p>
<p>Come esempio, si crea un file denominato <code class="docutils literal notranslate"><span class="pre">hello_test.cc</span></code> nella directory <code class="docutils literal notranslate"><span class="pre">my_workspace</span></code> col seguente contenuto:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gtest/gtest.h&gt;</span>

<span class="c1">// Demonstrate some basic assertions.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">HelloTest</span><span class="p">,</span><span class="w"> </span><span class="n">BasicAssertions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Expect two strings not to be equal.</span>
<span class="w">  </span><span class="n">EXPECT_STRNE</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Expect equality.</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>GoogleTest fornisce <span class="xref myst">asserzioni</span> utilizzate per testare il comportamento del codice. L’esempio precedente include il file header principale di GoogleTest e mostra alcune asserzioni di base.</p>
<p>Per buildare il codice, si crea un file denominato <code class="docutils literal notranslate"><span class="pre">BUILD</span></code> nella stessa directory con il seguente contenuto:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cc_test</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;hello_test&quot;</span><span class="p">,</span>
    <span class="n">size</span> <span class="o">=</span> <span class="s2">&quot;small&quot;</span><span class="p">,</span>
    <span class="n">srcs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;hello_test.cc&quot;</span><span class="p">],</span>
    <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;@googletest//:gtest&quot;</span><span class="p">,</span>
        <span class="s2">&quot;@googletest//:gtest_main&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">cc_test</span></code> rule declares the C++ test binary you want to build, and links to the GoogleTest library (<code class="docutils literal notranslate"><span class="pre">&#64;googletest//:gtest&quot;</span></code>) and the GoogleTest <code class="docutils literal notranslate"><span class="pre">main()</span></code> function (<code class="docutils literal notranslate"><span class="pre">&#64;googletest//:gtest_main</span></code>). Per ulteriori informazioni sui file Bazel <code class="docutils literal notranslate"><span class="pre">BUILD</span></code>, vedere il <a class="reference external" href="https://docs.bazel.build/versions/main/tutorial/cpp.html">Bazel C++ Tutorial</a>.</p>
<p>{: .callout .note} NOTE: In the example below, we assume Clang or GCC and set <code class="docutils literal notranslate"><span class="pre">--cxxopt=-std=c++17</span></code> to ensure that GoogleTest is compiled as C++17 instead of the compiler’s default setting. For MSVC, the equivalent would be <code class="docutils literal notranslate"><span class="pre">--cxxopt=/std:c++17</span></code>. Vedere <span class="xref myst">Supported Platforms</span> per ulteriori dettagli sulle versioni dei linguaggi supportate.</p>
<p>Ora si possono buildare ed eseguire il test:</p>
<pre>
<strong>$ bazel test --cxxopt=-std=c++17 --test_output=all //:hello_test</strong>
INFO: Analyzed target //:hello_test (26 packages loaded, 362 targets configured).
INFO: Found 1 test target...
INFO: From Testing //:hello_test:
==================== Test output for //:hello_test:
Running main() from gmock_main.cc
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from HelloTest
[ RUN      ] HelloTest.BasicAssertions
[       OK ] HelloTest.BasicAssertions (0 ms)
[----------] 1 test from HelloTest (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. (0 ms total)
[  PASSED  ] 1 test.
================================================================================
Target //:hello_test up-to-date:
  bazel-bin/hello_test
INFO: Elapsed time: 4.190s, Critical Path: 3.05s
INFO: 27 processes: 8 internal, 19 linux-sandbox.
INFO: Build completed successfully, 27 total actions
//:hello_test                                                     PASSED in 0.1s

INFO: Build completed successfully, 27 total actions
</pre>
<p>Congratulazioni! È stato creato ed eseguito correttamente un file binario di prova utilizzando GoogleTest.</p>
</section>
<section id="next-steps">
<h3>Passi successivi<a class="headerlink" href="#next-steps" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><span class="xref myst">Consultare la Guida</span> per iniziare a scrivere semplici test.</p></li>
<li><p><span class="xref myst">Esaminare gli esempi di codice</span> per altri esempi che mostrano come utilizzare le varie funzioni di GoogleTest.</p></li>
</ul>
</section>
</section>
<span id="document-docs/quickstart-cmake"></span><section id="quickstart-building-with-cmake">
<h2>Quickstart: Il Building con CMake<a class="headerlink" href="#quickstart-building-with-cmake" title="Link to this heading">¶</a></h2>
<p>Questo tutorial ha lo scopo rendere operativi con l’uso di GoogleTest con CMake. Se è la prima volta che si usa GoogleTest, o c’è bisogno di un ripasso, consigliamo questo tutorial come punto di partenza. Se il progetto utilizza Bazel, consultare invece <span class="xref myst">Quickstart for Bazel</span>.</p>
<section id="prerequisites">
<h3>Prerequisiti<a class="headerlink" href="#prerequisites" title="Link to this heading">¶</a></h3>
<p>Per questo tutorial, c’è bisogno di:</p>
<ul class="simple">
<li><p>Un sistema operativo compatibile (ad esempio Linux, macOS, Windows).</p></li>
<li><p>A compatible C++ compiler that supports at least C++17.</p></li>
<li><p><a class="reference external" href="https://cmake.org/">CMake</a> e uno strumento di build compatibile per il progetto.</p>
<ul>
<li><p>Gli strumenti di build compatibili includono <a class="reference external" href="https://www.gnu.org/software/make/">Make</a>, <a class="reference external" href="https://ninja-build.org/">Ninja</a> ed altri - consultare <a class="reference external" href="https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html">CMake Generators</a> per ulteriori informazioni.</p></li>
</ul>
</li>
</ul>
<p>Vedere <span class="xref myst">Supported Platforms</span> per ulteriori informazioni sulle piattaforme compatibili con GoogleTest.</p>
<p>Se Bazel non è ancora installato, consultare la <a class="reference external" href="https://cmake.org/install">CMake installation guide</a>.</p>
<p>{: .callout .note} Nota: I comandi del terminale in questo tutorial mostrano un prompt della shell Unix, ma funzionano anche sulla riga di comando di Windows.</p>
</section>
<section id="set-up-a-project">
<h3>Preparazione di un progetto<a class="headerlink" href="#set-up-a-project" title="Link to this heading">¶</a></h3>
<p>CMake usa un file chiamato <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> per configurare il sistema di build per un progetto. Si utilizzerà questo file per impostare il progetto e per dichiarare una dipendenza da GoogleTest.</p>
<p>Innanzitutto, si crea una directory per il progetto:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mkdir my_project &amp;&amp; cd my_project
</pre></div>
</div>
<p>Poi, si creerà il file <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> e si dichiarerà una dipendenza da GoogleTest. Esistono molti modi per esprimere le dipendenze nell’ecosistema CMake; in questa guida rapida si userà <code class="docutils literal notranslate"><span class="pre">FetchContent</span></code> di CMake](https://cmake.org/cmake/help/latest/module/FetchContent.html). Per farlo, nella directory del progetto (<code class="docutils literal notranslate"><span class="pre">my_project</span></code>), si crea un file chiamato <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> con i seguenti contenuti:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.14</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s">my_project</span><span class="p">)</span>

<span class="c"># GoogleTest requires at least C++17</span>
<span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span><span class="w"> </span><span class="s">17</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD_REQUIRED</span><span class="w"> </span><span class="s">ON</span><span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="s">FetchContent</span><span class="p">)</span>
<span class="nb">FetchContent_Declare</span><span class="p">(</span>
<span class="w">  </span><span class="s">googletest</span>
<span class="w">  </span><span class="s">URL</span><span class="w"> </span><span class="s">https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip</span>
<span class="p">)</span>
<span class="c"># For Windows: Prevent overriding the parent project&#39;s compiler/linker settings</span>
<span class="nb">set</span><span class="p">(</span><span class="s">gtest_force_shared_crt</span><span class="w"> </span><span class="s">ON</span><span class="w"> </span><span class="s">CACHE</span><span class="w"> </span><span class="s">BOOL</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="w"> </span><span class="s">FORCE</span><span class="p">)</span>
<span class="nb">FetchContent_MakeAvailable</span><span class="p">(</span><span class="s">googletest</span><span class="p">)</span>
</pre></div>
</div>
<p>La configurazione precedente dichiara una dipendenza da GoogleTest che viene scaricato da GitHub. Nell’esempio precedente, <code class="docutils literal notranslate"><span class="pre">03597a01ee50ed33e9dfd640b249b4be3799d395</span></code> è l’hash del commit Git della versione di GoogleTest da utilizzare; consigliamo di aggiornare spesso l’hash in modo che punti alla versione più recente.</p>
<p>Per ulteriori informazioni su come creare i file <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code>, consultare il <a class="reference external" href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">Tutorial su CMake</a>.</p>
</section>
<section id="create-and-run-a-binary">
<h3>Crea ed eseguire un file binario<a class="headerlink" href="#create-and-run-a-binary" title="Link to this heading">¶</a></h3>
<p>Con GoogleTest dichiarato come dipendenza, se ne può utilizzare il codice all’interno del progetto.</p>
<p>Per esempio, creare un file chiamato <code class="docutils literal notranslate"><span class="pre">hello_test.cc</span></code> nella directory <code class="docutils literal notranslate"><span class="pre">my_project</span></code> col seguente contenuto:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gtest/gtest.h&gt;</span>

<span class="c1">// Demonstrate some basic assertions.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">HelloTest</span><span class="p">,</span><span class="w"> </span><span class="n">BasicAssertions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Expect two strings not to be equal.</span>
<span class="w">  </span><span class="n">EXPECT_STRNE</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Expect equality.</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>GoogleTest fornisce <span class="xref myst">asserzioni</span> utilizzate per testare il comportamento del codice. L’esempio precedente include il file header principale di GoogleTest e mostra alcune asserzioni di base.</p>
<p>Per creare il codice, si aggiunge quanto segue alla fine del file <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">enable_testing</span><span class="p">()</span>

<span class="nb">add_executable</span><span class="p">(</span>
<span class="w">  </span><span class="s">hello_test</span>
<span class="w">  </span><span class="s">hello_test.cc</span>
<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>
<span class="w">  </span><span class="s">hello_test</span>
<span class="w">  </span><span class="s">GTest::gtest_main</span>
<span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="s">GoogleTest</span><span class="p">)</span>
<span class="nb">gtest_discover_tests</span><span class="p">(</span><span class="s">hello_test</span><span class="p">)</span>
</pre></div>
</div>
<p>La configurazione precedente abilita il test in CMake, dichiara il file binario di test C++ che si desidera buildare (<code class="docutils literal notranslate"><span class="pre">hello_test</span></code>) e lo «linka» a GoogleTest (<code class="docutils literal notranslate"><span class="pre">gtest_main</span></code>). Le ultime due righe consentono al runner dei test di CMake di scoprire i test inclusi nel file binario, utilizzando il <a class="reference external" href="https://cmake.org/cmake/help/git-stage/module/GoogleTest.html">modulo <code class="docutils literal notranslate"><span class="pre">GoogleTest</span></code> di CMake</a>.</p>
<p>Ora si possono buildare ed eseguire il test:</p>
<pre>
<strong>my_project$ cmake -S . -B build</strong>
-- The C compiler identification is GNU 10.2.1
-- The CXX compiler identification is GNU 10.2.1
...
-- Build files have been written to: .../my_project/build

<strong>my_project$ cmake --build build</strong>
Scanning dependencies of target gtest
...
[100%] Built target gmock_main

<strong>my_project$ cd build && ctest</strong>
Test project .../my_project/build
    Start 1: HelloTest.BasicAssertions
1/1 Test #1: HelloTest.BasicAssertions ........   Passed    0.00 sec

100% tests passed, 0 tests failed out of 1

Total Test time (real) =   0.01 sec
</pre>
<p>Congratulazioni! È stato creato ed eseguito correttamente un file binario di prova utilizzando GoogleTest.</p>
</section>
<section id="next-steps">
<h3>Passi successivi<a class="headerlink" href="#next-steps" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><span class="xref myst">Consultare la Guida</span> per iniziare a scrivere semplici test.</p></li>
<li><p><span class="xref myst">Esaminare gli esempi di codice</span> per altri esempi che mostrano come utilizzare le varie funzioni di GoogleTest.</p></li>
</ul>
</section>
</section>
</div>
</section>
<section id="guides">
<h1>Guide<a class="headerlink" href="#guides" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-docs/primer"></span><section id="googletest-primer">
<h2>Guida di GoogleTest<a class="headerlink" href="#googletest-primer" title="Link to this heading">¶</a></h2>
<section id="introduction-why-googletest">
<h3>Introduzione: Perché GoogleTest?<a class="headerlink" href="#introduction-why-googletest" title="Link to this heading">¶</a></h3>
<p><em>GoogleTest</em> aiuta a scrivere meglio i test di C++.</p>
<p>GoogleTest è un framework per i test sviluppato dal team «Testing Technology» tenendo presenti i requisiti e i vincoli specifici di Google. Sia se si lavora su Linux, su Windows, o su Mac, se si scrive codice C++, GoogleTest può essere utile. Supporta <em>qualsiasi</em> tipo di test, non solo le «unit test».</p>
<p>Quindi cosa rende buon un test e come si inserisce GoogleTest? Noi crediamo che:</p>
<ol class="arabic simple">
<li><p>I test dovrebbero essere <em>independenti</em> e <em>ripetibili</em>. È seccante eseguire il debug di un test che ha esito positivo o negativo a seconda di altri test. GoogleTest isola i test eseguendo ciascuno di essi su un oggetto diverso. Quando un test fallisce, GoogleTest consente di eseguirlo in isolamento per un debug rapido.</p></li>
<li><p>I test dovrebbero essere ben <em>organizzati</em> e riflettere la struttura del codice testato. GoogleTest raggruppa i test correlati in suite di test che possono condividere dati e subroutine. Questo schema comune è facile da riconoscere e semplifica la manutenzione dei test. Tale coerenza è particolarmente utile quando si cambia progetto e si inizia a lavorare su una nuova base di codice.</p></li>
<li><p>I test dovrebbero essere <em>portabili</em> e <em>riutilizzabili</em>. Google possieme molto codice indipendente dalla piattaforma; anche i suoi test dovrebbero anche essere indipendenti dalla piattaforma. GoogleTest funziona su diversi sistemi operativi, con vari compilatori, con o senza eccezioni, quindi i test di GoogleTest possono funzionare con una varietà di configurazioni.</p></li>
<li><p>Quando i test falliscono, dovrebbero fornire quante più <em>informazioni</em> possibili sul problema. GoogleTest non si ferma al primo fallimento del test. Ma, interrompe solo il test corrente e continua col successivo. È inoltre possibile impostare test che riportino ad errori non fatali dopo i quali il test corrente continua. Pertanto, si possono rilevare e correggere più bug in un singolo ciclo di esecuzione-modifica-compilazione.</p></li>
<li><p>Il framework di testing dovrebbe liberare gli autori dalle «faccende domestiche» e consentire loro di concentrarsi sul <em>contenuto</em> del test. GoogleTest tiene traccia automaticamente di tutti i test definiti e non richiede all’utente di elencarli per eseguirli.</p></li>
<li><p>I test dovrebbero essere <em>veloci</em>. Con GoogleTest si possono le risorse condivise tra i test e impegnarsi per l’installazione/de-installazione una sola volta, senza che i test dipendano gli uni dagli altri.</p></li>
</ol>
<p>Dat che GoogleTest è basato sulla popolare architettura xUnit, ci si sentirà come a casa se si è già utenti di JUnit o di PyUnit. In caso contrario, ci vorranno circa 10 minuti per apprendere le nozioni di base e cominciare. Quindi andiamo!</p>
</section>
<section id="beware-of-the-nomenclature">
<h3>Attenzione alla Nomenclatura<a class="headerlink" href="#beware-of-the-nomenclature" title="Link to this heading">¶</a></h3>
<p>{: .callout .note} <em>Nota:</em> Potrebbe verificarsi un po” di confusione derivante dalle diverse definizioni dei termini <em>Test</em>, <em>Test Case</em> e <em>Test Suite</em>, quindi attenzione a non confonderli.</p>
<p>Storicamente, GoogleTest ha iniziato a utilizzare il termine <em>Test Case</em> per raggruppare test correlati, mentre le pubblicazioni attuali, inclusi i materiali dell’International Software Testing Qualifications Board (<a class="reference external" href="https://www.istqb.org/">ISTQB</a>) e vari libri di testo sulla qualità del software, utilizzano il termine <em>[Test Suite][istqb test suite]</em> per questo.</p>
<p>Il termine correlato <em>Test</em>, così come viene utilizzato in GoogleTest, corrisponde al termine <em>[Test Case][istqb test case]</em> di ISTQB e di altri.</p>
<p>Il termine <em>Test</em> ha comunemente un senso sufficientemente ampio, inclusa la definizione di <em>Test Case</em>, di ISTQB, quindi non è un grosso problema. Ma il termine <em>Test Case</em> così come è stato utilizzato in Google Test ha un senso contraddittorio e quindi crea confusione.</p>
<p>GoogleTest ha recentemente iniziato a sostituire il termine <em>Test Case</em> con <em>Test Suite</em>. L’API preferita è <em>TestSuite</em>. La vecchia API TestCase viene lentamente deprecata e sottoposta a refactoring.</p>
<p>Si prega quindi di prestare attenzione alle diverse definizioni dei termini:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-left"><p>Significato</p></th>
<th class="head text-left"><p>Termine GoogleTest</p></th>
<th class="head text-left"><p>Termine <a class="reference external" href="https://www.istqb.org/">ISTQB</a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p>Testare un particolare path del programma con valori di input specifici e verificare i risultati</p></td>
<td class="text-left"><p><a class="reference internal" href="#simple-tests">TEST()</a></p></td>
<td class="text-left"><p><a class="reference external" href="https://glossary.istqb.org/en_US/term/test-case">Test Case</a></p></td>
</tr>
</tbody>
</table>
</section>
<section id="basic-concepts">
<h3>Concetti Base<a class="headerlink" href="#basic-concepts" title="Link to this heading">¶</a></h3>
<p>Quando si usa GoogleTest, si comincia scrivendo <em>asserzioni</em>, ovvero affermazioni che verificano se una condizione è vera. Il risultato di un’asserzione può essere <em>success</em>, <em>nonfatal failure</em> o <em>fatal failure</em>. Se avviane una «fatal failure», interrompe la funzione corrente; altrimenti il programma continua normalmente.</p>
<p><em>Tests</em> utilizzano le asserzioni per verificare il comportamento del codice in esame. Se un test va in crash o ha fallisce un’asserzione, allora <em>fail</em>; altrimenti <em>succeeds</em>.</p>
<p>Una <em>test suite</em> contiene uno o più test. I test si dovrebbero raggruppare in test suite che riflettono la struttura del codice in esame. Quando più test, in una test suite, devono condividere oggetti e subroutine comuni, si possono inserire in una classe <em>test fixture</em>.</p>
<p>Un <em>test program</em> può contenere più test suite.</p>
<p>Spiegheremo ora come scrivere un «test program», partendo dal livello della singola asserzione e costruendo poi «test» e «test suite».</p>
</section>
<section id="assertions">
<h3>Le Asserzioni<a class="headerlink" href="#assertions" title="Link to this heading">¶</a></h3>
<p>Le asserzioni di GoogleTest sono macro che assomigliano alle chiamate alle funzioni. Una classe o una funzione si può testare facendo asserzioni sul suo comportamento. Quando un’asserzione fallisce, GoogleTest stampa il file sorgente dell’asserzione e la posizione del numero di riga, insieme a un messaggio di errore. Si può anche avere un messaggio di errore personalizzato che verrà aggiunto al messaggio di GoogleTest.</p>
<p>Le asserzioni si presentano in coppie che mettono alla prova la stessa cosa ma hanno effetti diversi sulla funzione corrente. Le versioni <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code> generano errori fatali quando falliscono e <strong>interrompono la funzione corrente</strong>. Le versioni <code class="docutils literal notranslate"><span class="pre">EXPECT_*</span></code> generano errori non fatali, che non interrompono la funzione corrente. Solitamente si preferiscono le <code class="docutils literal notranslate"><span class="pre">EXPECT_*</span></code>, poiché consentono di segnalare più di un errore in un test. Tuttavia, si usa <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code> se non ha senso continuare quando l’asserzione in questione fallisce.</p>
<p>Poiché un <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code> non riuscito ritorna immediatamente dalla funzione corrente, probabilmente saltando il codice di pulizia successivo, potrebbe causare dei «memory leak». A seconda della natura del leak, potrebbe valere o meno la pena risolverlo, quindi lo si tenga a mente se si riceve un errore sul controllo dell’heap oltre agli errori dell’asserzione.</p>
<p>Per avere un messaggio di errore personalizzato, è sufficiente inserirlo nella macro utilizzando l’operatore <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> o una sequenza di tali operatori. Esaminare l’esempio seguente, utilizzando le macro <a class="reference internal" href="#reference/assertions.md#EXPECT_EQ"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">ASSERT_EQ</span></code> e <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ</span></code></span></a> per verificare l’uguaglianza dei valori:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Vectors x and y are of unequal length&quot;</span><span class="p">;</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Vectors x and y differ at index &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Tutto ciò che può essere inviato a un <code class="docutils literal notranslate"><span class="pre">ostream</span></code> e può essere inviato ad una macro di asserzione–in particolare, stringhe C e oggetti <code class="docutils literal notranslate"><span class="pre">string</span></code>. Se una stringa wide (<code class="docutils literal notranslate"><span class="pre">wchar_t*</span></code>, <code class="docutils literal notranslate"><span class="pre">TCHAR*</span></code> in modalità <code class="docutils literal notranslate"><span class="pre">UNICODE</span></code> su Windows, o <code class="docutils literal notranslate"><span class="pre">std::wstring</span></code>) viene inviata in streaming a un’asserzione, verrà tradotto in UTF-8 una volta stampato.</p>
<p>GoogleTest fornisce una raccolta di asserzioni per verificare il comportamento del codice in vari modi. Si possono controllare le condizioni booleane, confrontare valori in base a operatori relazionali, verificare valori stringa, valori in virgola mobile e molto altro. Esistono anche asserzioni che consentono di verificare stati più complessi fornendo predicati personalizzati. Per l’elenco completo delle asserzioni fornite da GoogleTest, consultare i <a class="reference internal" href="#reference/assertions.md"><span class="xref myst">Riferimenti sulle Asserzioni</span></a>.</p>
</section>
<section id="simple-tests">
<h3>Test Semplici<a class="headerlink" href="#simple-tests" title="Link to this heading">¶</a></h3>
<p>Per creare un test:</p>
<ol class="arabic simple">
<li><p>Si usa la macro <code class="docutils literal notranslate"><span class="pre">TEST()</span></code> per definire e dare un nome a una funzione di test. Queste sono normali funzioni C++ che non restituiscono un valore.</p></li>
<li><p>In questa funzione, insieme a qualsiasi istruzione C++ valida che si voglia includere, si utilizzano le varie asserzioni di GoogleTest per verificare i valori.</p></li>
<li><p>Il risultato del test è determinato dalle asserzioni; se una qualsiasi asserzione nel test fallisce (in modo fatale o non fatale), o se il test fallisce, l’intero test fallisce. Altrimenti, è riuscito.</p></li>
</ol>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">TestSuiteName</span><span class="p">,</span><span class="w"> </span><span class="n">TestName</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Gli argomenti di <code class="docutils literal notranslate"><span class="pre">TEST()</span></code> vanno dal generale allo specifico. Il <em>primo</em> argomento è il nome della «test suite» e il <em>secondo</em> argomento è il nome del test nella «test suite». Entrambi i nomi devono essere identificatori C++ validi e non devono contenere underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>). Il <em>nome completo</em> di un test è costituito dalla test suite che lo contiene e dal suo nome individuale. I test di diverse test suite possono avere lo stesso nome individuale.</p>
<p>Ad esempio, prendiamo una semplice funzione intera:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">Factorial</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w">  </span><span class="c1">// Returns the factorial of n</span>
</pre></div>
</div>
<p>Una test suite per questa funzione potrebbe essere simile a:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Tests factorial of 0.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">FactorialTest</span><span class="p">,</span><span class="w"> </span><span class="n">HandlesZeroInput</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Tests factorial of positive numbers.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">FactorialTest</span><span class="p">,</span><span class="w"> </span><span class="n">HandlesPositiveInput</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span><span class="w"> </span><span class="mi">40320</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>GoogleTest raggruppa i risultati dei test per «test suite», quindi i test logicamente correlati dovrebbero trovarsi nella stessa test suite; in altre parole, il primo argomento del loro <code class="docutils literal notranslate"><span class="pre">TEST()</span></code> dovrebbe essere lo stesso. Nell’esempio precedente, abbiamo due test, <code class="docutils literal notranslate"><span class="pre">HandlesZeroInput</span></code> e <code class="docutils literal notranslate"><span class="pre">HandlesPositiveInput</span></code>, che appartengono alla test suite <code class="docutils literal notranslate"><span class="pre">FactorialTest</span></code>.</p>
<p>Quando si dà un nome alle test suite e ai test, si deve seguire la stessa convenzione usata per <a class="reference external" href="https://google.github.io/styleguide/cppguide.html#Function_Names">denominare funzioni e classi</a>.</p>
<p><strong>Disponibilità</strong>: Linux, Windows, Mac.</p>
</section>
<section id="test-fixtures-using-the-same-data-configuration-for-multiple-tests-same-data-multiple-tests">
<h3>Test Fixture: Uso della Stessa Configurazione dei Dati per Più Test {#same-data-multiple-tests}<a class="headerlink" href="#test-fixtures-using-the-same-data-configuration-for-multiple-tests-same-data-multiple-tests" title="Link to this heading">¶</a></h3>
<p>Se ci si ritrova a scrivere due o più test che operano su dati simili, si può usare una <em>test fixture</em>. Questa consente di riutilizzare la stessa configurazione di oggetti per più test.</p>
<p>Per creare una fixture:</p>
<ol class="arabic simple">
<li><p>Si deriva una classe da <code class="docutils literal notranslate"><span class="pre">testing::Test</span></code> . Il body inizia con <code class="docutils literal notranslate"><span class="pre">protected:</span></code>, per accedere ai membri della fixture dalle sottoclassi.</p></li>
<li><p>All’interno della classe, si dichiarano tutti gli oggetti che si intendono usare.</p></li>
<li><p>Se necessario, si scrive un costruttore di default o una funzione <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> per preparare gli oggetti per ciascun test. Un errore comune è scrivere <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> come <strong><code class="docutils literal notranslate"><span class="pre">Setup()</span></code></strong> con una <code class="docutils literal notranslate"><span class="pre">u</span></code> minuscola - Usare <code class="docutils literal notranslate"><span class="pre">override</span></code> in C++11 per essere sicuri di scriverlo correttamente.</p></li>
<li><p>Se necessario, scrivere un distruttore o una funzione <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> per rilasciare eventuali risorse allocate in <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code>. Per sapere quando usare il costruttore/distruttore e quando usare <code class="docutils literal notranslate"><span class="pre">SetUp()/TearDown()</span></code>, leggere le <span class="xref myst">FAQ</span>.</p></li>
<li><p>Se necessario, definire delle subroutine da condividere tra i test.</p></li>
</ol>
<p>Quando si usa una fixture, si usa <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code> anziché <code class="docutils literal notranslate"><span class="pre">TEST()</span></code> in quanto consente di accedere a oggetti e subroutine nella fixture di test:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">TestFixtureClassName</span><span class="p">,</span><span class="w"> </span><span class="n">TestName</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A differenza di <code class="docutils literal notranslate"><span class="pre">TEST()</span></code>, in <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code> il primo argomento deve essere il nome della classe della fixture di test. (<code class="docutils literal notranslate"><span class="pre">_F</span></code> sta per «Fixture»). Per questa macro non è specificato alcun nome di test suite.</p>
<p>Sfortunatamente, il sistema delle macro di C++ non ci consente di creare un’unica macro per gestire entrambi i tipi di test. L’utilizzo della macro errata provoca un errore del compilatore.</p>
<p>Inoltre, si deve definire una classe per la fixture di test prima di usarla in una <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code>, altrimenti si riceve l’errore del compilatore «<code class="docutils literal notranslate"><span class="pre">virtual</span> <span class="pre">outside</span> <span class="pre">class</span> <span class="pre">declaration</span></code>».</p>
<p>Per ogni test definito con <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code>, GoogleTest creerà una <em>nuova</em> fixture a runtime, lo inizializzerà immediatamente tramite <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code>, esegue il test, ripulisce chiamando <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> ed esegue il delete della fixture di test. Si tenga presente che test diversi nella stessa suite di test hanno oggetti fixture di test diversi e GoogleTest elimina sempre una fixture di test prima di creare quella successiva. GoogleTest <strong>non</strong> riutilizza la stessa fixture per più test. Qualsiasi modifica apportata da un test alla fixture non influisce sugli altri test.</p>
<p>Ad esempio, scriviamo i test per una classe di una coda FIFO chiamata <code class="docutils literal notranslate"><span class="pre">Queue</span></code>, che ha la seguente interfaccia:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">E</span><span class="o">&gt;</span><span class="w">  </span><span class="c1">// E is the element type.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Queue</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Queue</span><span class="p">();</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">Enqueue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">E</span><span class="o">&amp;</span><span class="w"> </span><span class="n">element</span><span class="p">);</span>
<span class="w">  </span><span class="n">E</span><span class="o">*</span><span class="w"> </span><span class="nf">Dequeue</span><span class="p">();</span><span class="w">  </span><span class="c1">// Returns NULL if the queue is empty.</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Innanzitutto, si definisce una classe fixture. Per convenzione, si da il nome <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> dove <code class="docutils literal notranslate"><span class="pre">Foo</span></code> è la classe da testare.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">QueueTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="n">QueueTest</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// q0_ remains empty</span>
<span class="w">     </span><span class="n">q1_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">     </span><span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">     </span><span class="n">q2_</span><span class="p">.</span><span class="n">Enqueue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ~QueueTest() override = default;</span>

<span class="w">  </span><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q0_</span><span class="p">;</span>
<span class="w">  </span><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q1_</span><span class="p">;</span>
<span class="w">  </span><span class="n">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q2_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In this case, we don’t need to define a destructor or a <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> method,
because the implicit destructor generated by the compiler will perform all of
the necessary cleanup.</p>
<p>Ora scriveremo i test utilizzando <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code> e questa fixture.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span><span class="w"> </span><span class="n">IsEmptyInitially</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">q0_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">QueueTest</span><span class="p">,</span><span class="w"> </span><span class="n">DequeueWorks</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q0_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q1_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
<span class="w">  </span><span class="n">ASSERT_NE</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">q1_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q2_</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
<span class="w">  </span><span class="n">ASSERT_NE</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">q2_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Quanto sopra utilizza entrambe le asserzioni <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code> e <code class="docutils literal notranslate"><span class="pre">EXPECT_*</span></code>. La regola pratica è quella di utilizzare <code class="docutils literal notranslate"><span class="pre">EXPECT_*</span></code> quando si desidera che il test continui a scoprire altri errori dopo il fallimento dell’asserzione e utilizzare <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code> quando continuare dopo il fallimento non ha senso. Ad esempio, la seconda asserzione nel test <code class="docutils literal notranslate"><span class="pre">Dequeue</span></code> è <code class="docutils literal notranslate"><span class="pre">ASSERT_NE(n,</span> <span class="pre">nullptr)</span></code>, poiché in seguito dobbiamo dereferenziare il puntatore <code class="docutils literal notranslate"><span class="pre">n</span></code>, che porterebbe a un segfault quando <code class="docutils literal notranslate"><span class="pre">n</span></code> è <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>Quando vengono eseguiti questi test, accade quanto segue:</p>
<ol class="arabic simple">
<li><p>GoogleTest costruisce un oggetto <code class="docutils literal notranslate"><span class="pre">QueueTest</span></code> (chiamiamolo <code class="docutils literal notranslate"><span class="pre">t1</span></code>).</p></li>
<li><p>Il primo test (<code class="docutils literal notranslate"><span class="pre">IsEmptyInitially</span></code>) viene eseguito su <code class="docutils literal notranslate"><span class="pre">t1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t1</span></code> viene distrutto.</p></li>
<li><p>I passaggi precedenti vengono ripetuti su un altro oggetto <code class="docutils literal notranslate"><span class="pre">QueueTest</span></code>, questa volta eseguendo il test <code class="docutils literal notranslate"><span class="pre">DequeueWorks</span></code>.</p></li>
</ol>
<p><strong>Disponibilità</strong>: Linux, Windows, Mac.</p>
</section>
<section id="invoking-the-tests">
<h3>Invocare i Test<a class="headerlink" href="#invoking-the-tests" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">TEST()</span></code> e <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code> registrano implicitamente i loro test con GoogleTest. Pertanto, a differenza di molti altri framework di test C++, non è necessario elencare nuovamente tutti i test definiti per eseguirli.</p>
<p>Dopo aver definito tuoi test, si possono eseguire con <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>, che restituisce <code class="docutils literal notranslate"><span class="pre">0</span></code> se tutti i test hanno esito positivo, o <code class="docutils literal notranslate"><span class="pre">1</span></code> in caso contrario. Notare che <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code> esegue <em>tutti i test</em> nella [link unit]–possono appartenere a diverse test suite, o anche a diversi file sorgenti.</p>
<p>Quando viene richiamata, la macro <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>:</p>
<ul class="simple">
<li><p>Salva lo stato di tutti i flag di GoogleTest.</p></li>
<li><p>Crea un oggetto fixture per il primo test.</p></li>
<li><p>Lo inizializza tramite <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code>.</p></li>
<li><p>Esegue il test sull’oggetto fixture.</p></li>
<li><p>Ripulisce la fixture tramite <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code>.</p></li>
<li><p>Cancella la fixture.</p></li>
<li><p>Ripristina lo stato di tutti i flag di GoogleTest.</p></li>
<li><p>Ripete i passaggi precedenti per il test successivo, fino all’esecuzione di tutti i test.</p></li>
</ul>
<p>Se si verifica un errore irreversibile, i passaggi successivi verranno saltati.</p>
<p>{: .callout .important}</p>
<blockquote>
<div><p>IMPORTANTE: <strong>Non</strong> si deve ignorare il valore di ritorno di <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code> altrimenti si riceve un errore del compilatore. La logica di questa progettazione è che il servizio di test automatizzato determina se un test è stato superato in base al suo codice di uscita, non all’output stdout/stderr; quindi la funzione <code class="docutils literal notranslate"><span class="pre">main()</span></code> deve restituire il valore di <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>.</p>
<p>Inoltre, si deve chiamare <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code> solo <strong>una volta</strong>. Chiamandola più volte, si entra in conflitto con delle funzionalità avanzate di GoogleTest (ad esempio, i <span class="xref myst">death tests</span>) e quindi non è supportato.</p>
</div></blockquote>
<p><strong>Disponibilità</strong>: Linux, Windows, Mac.</p>
</section>
<section id="writing-the-main-function">
<h3>Scrivere la Funzione main()<a class="headerlink" href="#writing-the-main-function" title="Link to this heading">¶</a></h3>
<p>La maggior parte degli utenti <em>non</em> dovrebbe aver bisogno di scrivere la propria funzione <code class="docutils literal notranslate"><span class="pre">main</span></code> e linkare invece <code class="docutils literal notranslate"><span class="pre">gtest_main</span></code> (al contrario di <code class="docutils literal notranslate"><span class="pre">gtest</span></code>), che definisce un punto di ingresso adeguato. Per i dettagli vedere la fine di questa sezione. Il resto di questa sezione dovrebbe applicarsi solo quando è necessario fare qualcosa di personalizzato prima dell’esecuzione dei test che non possa essere espresso nell’ambito delle fixture e delle test suite.</p>
<p>Se si scrive la propria funzione <code class="docutils literal notranslate"><span class="pre">main</span></code>, essa deve restituire il valore di <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>.</p>
<p>Si può iniziare da questo prototipo:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;this/package/foo.h&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gtest/gtest.h&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">my</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">project</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// The fixture for testing class Foo.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// You can remove any or all of the following functions if their bodies would</span>
<span class="w">  </span><span class="c1">// be empty.</span>

<span class="w">  </span><span class="n">FooTest</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// You can do set-up work for each test here.</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="o">~</span><span class="n">FooTest</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// You can do clean-up work that doesn&#39;t throw exceptions here.</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// If the constructor and destructor are not enough for setting up</span>
<span class="w">  </span><span class="c1">// and cleaning up each test, you can define the following methods:</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SetUp</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Code here will be called immediately after the constructor (right</span>
<span class="w">     </span><span class="c1">// before each test).</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">TearDown</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="c1">// Code here will be called immediately after each test (right</span>
<span class="w">     </span><span class="c1">// before the destructor).</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Class members declared here can be used by all tests in the test suite</span>
<span class="w">  </span><span class="c1">// for Foo.</span>
<span class="p">};</span>

<span class="c1">// Tests that the Foo::Bar() method does Abc.</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">MethodBarDoesAbc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">input_filepath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;this/package/testdata/myinputfile.dat&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">output_filepath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;this/package/testdata/myoutputfile.dat&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">Foo</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">Bar</span><span class="p">(</span><span class="n">input_filepath</span><span class="p">,</span><span class="w"> </span><span class="n">output_filepath</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Tests that Foo does Xyz.</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesXyz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Exercises the Xyz feature of Foo.</span>
<span class="p">}</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace project</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace my</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">testing</span><span class="o">::</span><span class="n">InitGoogleTest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La funzione <code class="docutils literal notranslate"><span class="pre">testing::InitGoogleTest()</span></code> analizza la riga di comando per i flag di GoogleTest e rimuove tutti i flag riconosciuti. Ciò consente all’utente di controllare il comportamento di un programma di test tramite vari flag, di cui parleremo nella <span class="xref myst">AdvancedGuide</span>. Si <strong>deve</strong> chiamare questa funzione prima di chiamare <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>, altrimenti i flag non verranno inizializzati correttamente.</p>
<p>Su Windows, <code class="docutils literal notranslate"><span class="pre">InitGoogleTest()</span></code> funziona anche con stringhe estese [wide], quindi può essere utilizzato anche in programmi compilati in modalità <code class="docutils literal notranslate"><span class="pre">UNICODE</span></code>.</p>
<p>Ma forse si sta pensando che scrivere tutte queste funzioni di <code class="docutils literal notranslate"><span class="pre">main</span></code> sia troppo? Siamo completamente d’accordo ed è per questo che Google Test fornisce un’implementazione di base di main(). Se soddisfa le esigenze, basta linkare il test alla libreria <code class="docutils literal notranslate"><span class="pre">gtest_main</span></code> e si è a posto.</p>
<p>{: .callout .note} NOTA: <code class="docutils literal notranslate"><span class="pre">ParseGUnitFlags()</span></code> è deprecato a favore di <code class="docutils literal notranslate"><span class="pre">InitGoogleTest()</span></code>.</p>
</section>
<section id="known-limitations">
<h3>Limitazioni Note<a class="headerlink" href="#known-limitations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>Google Test è progettato per essere thread-safe. L’implementazione è thread-safe sui sistemi in cui è disponibile la libreria <code class="docutils literal notranslate"><span class="pre">pthreads</span></code>. Al momento è <em>unsafe</em> utilizzare le asserzioni di Google Test da due thread contemporaneamente su altri sistemi (ad esempio Windows). Nella maggior parte dei test questo non è un problema poiché di solito le asserzioni vengono fatte nel thread principale. Se si vuole aiutare, ci si può offrire volontari per implementare le primitive di sincronizzazione necessarie in <code class="docutils literal notranslate"><span class="pre">gtest-port.h</span></code> per la propria piattaforma.</p></li>
</ul>
</section>
</section>
<span id="document-docs/advanced"></span><section id="advanced-googletest-topics">
<h2>Argomenti avanzati di GoogleTest<a class="headerlink" href="#advanced-googletest-topics" title="Link to this heading">¶</a></h2>
<section id="introduction">
<h3>Introduzione<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h3>
<p>Dopo aver letto la <span class="xref myst">Guida di GoogleTest</span> e imparato a scrivere test utilizzando GoogleTest, è il momento di imparare dei nuovi trucchi. Questo documento illustrerà altre asserzioni e come costruire messaggi di errore complessi, propagare errori fatali, riutilizzare e velocizzare fixture e utilizzare vari flag con i test.</p>
</section>
<section id="more-assertions">
<h3>Altre Asserzioni<a class="headerlink" href="#more-assertions" title="Link to this heading">¶</a></h3>
<p>Questa sezione copre alcune asserzioni usate meno frequentemente, ma comunque significative.</p>
<section id="explicit-success-and-failure">
<h4>Successi e Fallimento Espliciti<a class="headerlink" href="#explicit-success-and-failure" title="Link to this heading">¶</a></h4>
<p>Vedere <a class="reference internal" href="#reference/assertions.md#success-failure"><span class="xref myst">Explicit Success and Failure</span></a> nei «Riferimenti sulle Asserzioni».</p>
</section>
<section id="exception-assertions">
<h4>Asserzioni di Eccezioni<a class="headerlink" href="#exception-assertions" title="Link to this heading">¶</a></h4>
<p>Vedere <a class="reference internal" href="#reference/assertions.md#exceptions"><span class="xref myst">Exception Assertions</span></a> nelle «Asserzioni di Eccezioni».</p>
</section>
<section id="predicate-assertions-for-better-error-messages">
<h4>Asserzioni di Predicati per del Migliori Messaggi di Errore<a class="headerlink" href="#predicate-assertions-for-better-error-messages" title="Link to this heading">¶</a></h4>
<p>Anche se GoogleTest dispone di un ricco insieme di asserzioni, queste non potranno mai essere complete, poiché è impossibile (e non è nemmeno una buona idea) prevedere tutti gli scenari in cui un utente potrebbe imbattersi. Pertanto, a volte un utente deve utilizzare <code class="docutils literal notranslate"><span class="pre">EXPECT_TRUE()</span></code> per verificare un’espressione complessa, in mancanza di una macro migliore. Questo ha il problema di non mostrare i valori delle parti dell’espressione, rendendo difficile capire cosa è andato storto. Come soluzione alternativa, alcuni utenti scelgono di costruirsi da soli il messaggio di errore, accodandolo a <code class="docutils literal notranslate"><span class="pre">EXPECT_TRUE()</span></code>. Tuttavia, ciò risulta problematico, soprattutto quando l’espressione presenta effetti collaterali o è costosa da valutare.</p>
<p>GoogleTest offre tre diverse opzioni per risolvere questo problema:</p>
<section id="using-an-existing-boolean-function">
<h5>Utilizzo di una Funzione Booleana Esistente<a class="headerlink" href="#using-an-existing-boolean-function" title="Link to this heading">¶</a></h5>
<p>Se c’è già una funzione o un funtore che restituisce <code class="docutils literal notranslate"><span class="pre">bool</span></code> (o un tipo che può essere convertito implicitamente in <code class="docutils literal notranslate"><span class="pre">bool</span></code>), lo si può usare in un <em>predicate assertion</em> (asserzione di predicato) per ottenere gratuitamente la stampa degli argomenti della funzione. Vedere <a class="reference internal" href="#reference/assertions.md#EXPECT_PRED"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_PRED*</span></code></span></a> nei «Riferimenti sulle Asserzioni» per i dettagli.</p>
</section>
<section id="using-a-function-that-returns-an-assertionresult">
<h5>Utilizzo di una Funzione che Restituisce un AssertionResult<a class="headerlink" href="#using-a-function-that-returns-an-assertionresult" title="Link to this heading">¶</a></h5>
<p>Sebbene <code class="docutils literal notranslate"><span class="pre">EXPECT_PRED*()</span></code> e similli siano utili per un lavoro veloce, la sintassi non è soddisfacente: si devono usare macro diverse per caratteristiche diverse, e sembra più Lisp che C++. La classe <code class="docutils literal notranslate"><span class="pre">::testing::AssertionResult</span></code> risolve questo problema.</p>
<p>Un oggetto <code class="docutils literal notranslate"><span class="pre">AssertionResult</span></code> rappresenta il risultato di un’asserzione (sia che si tratti di un successo che di un fallimento, e un messaggio associato). Un <code class="docutils literal notranslate"><span class="pre">AssertionResult</span></code> si può creare utilizzando una di queste funzioni «factory»:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">testing</span><span class="w"> </span><span class="p">{</span>

<span class="c1">// Returns an AssertionResult object to indicate that an assertion has</span>
<span class="c1">// succeeded.</span>
<span class="n">AssertionResult</span><span class="w"> </span><span class="nf">AssertionSuccess</span><span class="p">();</span>

<span class="c1">// Returns an AssertionResult object to indicate that an assertion has</span>
<span class="c1">// failed.</span>
<span class="n">AssertionResult</span><span class="w"> </span><span class="nf">AssertionFailure</span><span class="p">();</span>

<span class="p">}</span>
</pre></div>
</div>
<p>È poi possibile utilizzare l’operatore <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> per lo streaming dei messaggi all’oggetto <code class="docutils literal notranslate"><span class="pre">AssertionResult</span></code>.</p>
<p>Per avere messaggi più leggibili nelle asserzioni booleane (ad esempio <code class="docutils literal notranslate"><span class="pre">EXPECT_TRUE()</span></code>), si scrive una funzione predicato che restituisca <code class="docutils literal notranslate"><span class="pre">AssertionResult</span></code> anziché <code class="docutils literal notranslate"><span class="pre">bool</span></code>. Per esempio, se si definisce <code class="docutils literal notranslate"><span class="pre">IsEven()</span></code> come:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionResult</span><span class="w"> </span><span class="nf">IsEven</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionSuccess</span><span class="p">();</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionFailure</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is odd&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>invece di:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsEven</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>l’asserzione fallita, <code class="docutils literal notranslate"><span class="pre">EXPECT_TRUE(IsEven(Fib(4)))</span></code>, stamperà:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Value of: IsEven(Fib(4))
  Actual: false (3 is odd)
Expected: true
</pre></div>
</div>
<p>invece di un più opaco</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Value of: IsEven(Fib(4))
  Actual: false
Expected: true
</pre></div>
</div>
<p>Per ottenere messaggi informativi anche in <code class="docutils literal notranslate"><span class="pre">EXPECT_FALSE</span></code> e in <code class="docutils literal notranslate"><span class="pre">ASSERT_FALSE</span></code> (un terzo delle asserzioni booleane nel codebase di Google sono negative) e si è d’accordo nel rendere il predicato più lento in il caso di successo, si può fornire un messaggio in caso di successo:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionResult</span><span class="w"> </span><span class="nf">IsEven</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionSuccess</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is even&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionFailure</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; is odd&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Quindi verrà stampata l’istruzione <code class="docutils literal notranslate"><span class="pre">EXPECT_FALSE(IsEven(Fib(6)))</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  Value of: IsEven(Fib(6))
     Actual: true (8 is even)
  Expected: false
</pre></div>
</div>
</section>
<section id="using-a-predicate-formatter">
<h5>Utilizzo di un Predicato-Formatter<a class="headerlink" href="#using-a-predicate-formatter" title="Link to this heading">¶</a></h5>
<p>Se si ritiene insoddisfacente il messaggio di default generato da <a class="reference internal" href="#reference/assertions.md#EXPECT_PRED"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_PRED*</span></code></span></a> e da <a class="reference internal" href="#reference/assertions.md#EXPECT_TRUE"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_TRUE</span></code></span></a> o alcuni argomenti del predicato supportano lo streaming su <code class="docutils literal notranslate"><span class="pre">ostream</span></code>, si possono alternativamente utilizzare <em>predicate-formatter assertions</em> per personalizzare <em>completamente</em> la modalità di formattazione del messaggio. Vedere <a class="reference internal" href="#reference/assertions.md#EXPECT_PRED_FORMAT"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_PRED_FORMAT*</span></code></span></a> nei «Riferimenti sulle Asserzioni» per i dettagli.</p>
</section>
</section>
<section id="floating-point-comparison">
<h4>Confronto in Virgola Mobile<a class="headerlink" href="#floating-point-comparison" title="Link to this heading">¶</a></h4>
<p>Vedere <a class="reference internal" href="#reference/assertions.md#floating-point"><span class="xref myst">Floating-Point Comparison</span></a> nei «Riferimenti sulle Asserzioni».</p>
<section id="floating-point-predicate-format-functions">
<h5>Predicato in Virgola Mobile-Funzioni di Formattazione<a class="headerlink" href="#floating-point-predicate-format-functions" title="Link to this heading">¶</a></h5>
<p>Alcune operazioni in virgola mobile sono utili, ma non vengono utilizzate tanto spesso. Per evitare un’esplosione di nuove macro, le forniamo come funzioni in formato predicato, utilizzabili nella macro di asserzione del predicato <a class="reference internal" href="#reference/assertions.md#EXPECT_PRED_FORMAT"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_PRED_FORMAT2</span></code></span></a>, ad esempio:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">FloatLE</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoubleLE</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_PRED_FORMAT2</span><span class="p">(</span><span class="n">FloatLE</span><span class="p">,</span><span class="w"> </span><span class="n">val1</span><span class="p">,</span><span class="w"> </span><span class="n">val2</span><span class="p">);</span>
<span class="n">EXPECT_PRED_FORMAT2</span><span class="p">(</span><span class="n">DoubleLE</span><span class="p">,</span><span class="w"> </span><span class="n">val1</span><span class="p">,</span><span class="w"> </span><span class="n">val2</span><span class="p">);</span>
</pre></div>
</div>
<p>Il codice precedente controlla che <code class="docutils literal notranslate"><span class="pre">val1</span></code> sia inferiore o approssimativamente uguale a <code class="docutils literal notranslate"><span class="pre">val2</span></code>.</p>
</section>
</section>
<section id="asserting-using-gmock-matchers">
<h4>Asserzioni con l’uso dei Matcher di gMock<a class="headerlink" href="#asserting-using-gmock-matchers" title="Link to this heading">¶</a></h4>
<p>Vedere <a class="reference internal" href="#reference/assertions.md#EXPECT_THAT"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_THAT</span></code></span></a> nelle «Asserzioni di Eccezioni».</p>
</section>
<section id="more-string-assertions">
<h4>Altre Asserzioni di Stringa<a class="headerlink" href="#more-string-assertions" title="Link to this heading">¶</a></h4>
<p>(Se non è stato fatto, è opportuno leggere prima la sezione <a class="reference internal" href="#asserting-using-gmock-matchers">precedente</a>).</p>
<p>Si possono usare i <a class="reference internal" href="#reference/matchers.md#string-matchers"><span class="xref myst">matcher di stringhe</span></a> di gMock con <a class="reference internal" href="#reference/assertions.md#EXPECT_THAT"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_THAT</span></code></span></a> per fare altri tipi di confronti tra stringhe (sotto-stringa, prefisso, suffisso, espressione regolare, ecc.). Per esempio,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">HasSubstr</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MatchesRegex</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">ASSERT_THAT</span><span class="p">(</span><span class="n">foo_string</span><span class="p">,</span><span class="w"> </span><span class="n">HasSubstr</span><span class="p">(</span><span class="s">&quot;needle&quot;</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">bar_string</span><span class="p">,</span><span class="w"> </span><span class="n">MatchesRegex</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\\</span><span class="s">w*</span><span class="se">\\</span><span class="s">d+&quot;</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="windows-hresult-assertions">
<h4>Asserzioni HRESULT di Windows<a class="headerlink" href="#windows-hresult-assertions" title="Link to this heading">¶</a></h4>
<p>Vedere <a class="reference internal" href="#reference/assertions.md#HRESULT"><span class="xref myst">Windows HRESULT Assertions</span></a> nelle «Asserzioni di Eccezioni».</p>
</section>
<section id="type-assertions">
<h4>Tipi di Asserzioni<a class="headerlink" href="#type-assertions" title="Link to this heading">¶</a></h4>
<p>Si può chiamare la funzione</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">StaticAssertTypeEq</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>per asserire (affermare) che i tipi <code class="docutils literal notranslate"><span class="pre">T1</span></code> e <code class="docutils literal notranslate"><span class="pre">T2</span></code> sono gli stessi. La funzione non fa nulla se l’asserzione è soddisfatta. Se i tipi sono diversi, la chiamata alla funzione non verrà compilata, il messaggio di errore del compilatore dirà che <code class="docutils literal notranslate"><span class="pre">T1</span> <span class="pre">e</span> <span class="pre">T2</span> <span class="pre">non</span> <span class="pre">sono</span> <span class="pre">dello</span> <span class="pre">stesso</span> <span class="pre">tipo</span></code> e molto probabilmente (a seconda del compilatore) mostrerà i valori effettivi di <code class="docutils literal notranslate"><span class="pre">T1</span></code> e di <code class="docutils literal notranslate"><span class="pre">T2</span></code>. Ciò è utile principalmente all’interno del codice template.</p>
<p><strong>Avvertenza</strong>: Se utilizzato all’interno di una funzione membro di una classe template o di una funzione template, <code class="docutils literal notranslate"><span class="pre">StaticAssertTypeEq&lt;T1,</span> <span class="pre">T2&gt;()</span></code> è efficace solo se viene istanziata la funzione. Ad esempio, dato:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">Bar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">StaticAssertTypeEq</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>il codice:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Test1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>non genererà un errore del compilatore, poiché <code class="docutils literal notranslate"><span class="pre">Foo&lt;bool&gt;::Bar()</span></code> non viene mai effettivamente istanziato. Occorre, invece:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Test2</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>per causare un errore del compilatore.</p>
</section>
<section id="assertion-placement">
<h4>Posizionamento delle Asserzioni<a class="headerlink" href="#assertion-placement" title="Link to this heading">¶</a></h4>
<p>Le asserzioni si possono usare in qualsiasi funzione C++. In particolare, non deve essere un metodo della classe fixture del test. L’unico vincolo è che le asserzioni che generano un errore irreversibile (<code class="docutils literal notranslate"><span class="pre">FAIL*</span></code> e <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code>) sono utilizzabili solo nelle funzioni che restituiscono void. Questa è una conseguenza del fatto che Google non utilizza le eccezioni. Inserendola in una funzione non void si otterrà un errore di compilazione confuso del tipo <code class="docutils literal notranslate"><span class="pre">&quot;error:</span> <span class="pre">void</span> <span class="pre">value</span> <span class="pre">not</span> <span class="pre">ignored</span> <span class="pre">as</span> <span class="pre">it</span> <span class="pre">ought</span> <span class="pre">to</span> <span class="pre">be&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;cannot</span> <span class="pre">initialize</span> <span class="pre">return</span> <span class="pre">object</span> <span class="pre">of</span> <span class="pre">type</span> <span class="pre">'bool'</span> <span class="pre">with</span> <span class="pre">an</span> <span class="pre">rvalue</span> <span class="pre">of</span> <span class="pre">type</span> <span class="pre">'void'&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;error:</span> <span class="pre">no</span> <span class="pre">viable</span> <span class="pre">conversion</span> <span class="pre">from</span> <span class="pre">'void'</span> <span class="pre">to</span> <span class="pre">'string'&quot;</span></code>.</p>
<p>Per usare asserzioni fatali in una funzione che restituisce non void, un’opzione è fare in modo che la funzione restituisca il valore in un parametro di output. Per esempio, si può riscrivere <code class="docutils literal notranslate"><span class="pre">T2</span> <span class="pre">Foo(T1</span> <span class="pre">x)</span></code> in <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">Foo(T1</span> <span class="pre">x,</span> <span class="pre">T2*</span> <span class="pre">result)</span></code>. <code class="docutils literal notranslate"><span class="pre">*result</span></code> deve contenere un valore sensato anche quando la funzione ritorna prematuramente. Dato che la funzione ora restituisce <code class="docutils literal notranslate"><span class="pre">void</span></code>, si può utilizzare qualsiasi asserzione al suo interno.</p>
<p>Se non è possibile cambiare il tipo della funzione, si devono semplicemente usare asserzioni che generano errori non fatali, come <code class="docutils literal notranslate"><span class="pre">ADD_FAILURE*</span></code> e <code class="docutils literal notranslate"><span class="pre">EXPECT_*</span></code>.</p>
<p>{: .callout .note} NOTA: Costruttori e distruttori non sono considerati funzioni che restituiscono void, secondo le specifiche del linguaggio C++, e quindi non è possibile utilizzare asserzioni fatali al loro interno; provandoci si riceverà un errore di compilazione. Invece, o si chiama <code class="docutils literal notranslate"><span class="pre">abort</span></code> e si manda in crash tutto l’eseguibile del test, oppure si inserisce l’asserzione fatale in una funzione <code class="docutils literal notranslate"><span class="pre">SetUp</span></code>/<code class="docutils literal notranslate"><span class="pre">TearDown</span></code>; vedere <span class="xref myst">constructor/destructor vs. <code class="docutils literal notranslate"><span class="pre">SetUp</span></code>/<code class="docutils literal notranslate"><span class="pre">TearDown</span></code></span></p>
<p>{: .callout .warning} ATTENZIONE: Un’asserzione fatale in una funzione helper (metodo privato che restituisce void) chiamata da un costruttore o da un distruttore non termina il test corrente, come potrebbe suggerire l’intuito: ritorna semplicemente dal costruttore o anticipatamente dal distruttore, forse lasciando l’oggetto in uno stato di parzialmente creato o di parzialmente distrutto! Quasi certamente si vuole, invece, <code class="docutils literal notranslate"><span class="pre">abort</span></code>ire o usare <code class="docutils literal notranslate"><span class="pre">SetUp</span></code>/<code class="docutils literal notranslate"><span class="pre">TearDown</span></code>.</p>
</section>
</section>
<section id="skipping-test-execution">
<h3>Saltare l’esecuzione del test<a class="headerlink" href="#skipping-test-execution" title="Link to this heading">¶</a></h3>
<p>Per quanto riguarda le asserzioni <code class="docutils literal notranslate"><span class="pre">SUCCEED()</span></code> e <code class="docutils literal notranslate"><span class="pre">FAIL()</span></code>, si può evitare l’esecuzione dei test successivi a runtime con la macro <code class="docutils literal notranslate"><span class="pre">GTEST_SKIP()</span></code>. Ciò è utile quando si devono verificare le precondizioni del sistema sotto test durante il runtime e saltare i test in modo significativo.</p>
<p><code class="docutils literal notranslate"><span class="pre">GTEST_SKIP()</span></code> è utilizzabile nei casi di test individuali o nei metodi <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> di una classe derivata da <code class="docutils literal notranslate"><span class="pre">::testing::Environment</span></code> o da <code class="docutils literal notranslate"><span class="pre">::testing::Test</span></code>. Per esempio:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">SkipTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesSkip</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GTEST_SKIP</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Skipping single test&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">FAIL</span><span class="p">();</span><span class="w">  </span><span class="c1">// Won&#39;t fail; it won&#39;t be executed</span>
<span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SkipFixture</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SetUp</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">GTEST_SKIP</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Skipping all tests for this fixture&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Tests for SkipFixture won&#39;t be executed.</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">SkipFixture</span><span class="p">,</span><span class="w"> </span><span class="n">SkipsOneTest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FAIL</span><span class="p">();</span><span class="w">  </span><span class="c1">// Won&#39;t fail; it won&#39;t be executed</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Come con le macro delle asserzioni, si può accodare un messaggio personalizzato in <code class="docutils literal notranslate"><span class="pre">GTEST_SKIP()</span></code>.</p>
</section>
<section id="teaching-googletest-how-to-print-your-values">
<h3>Insegnare a GoogleTest Come Stampare i Propri Valori<a class="headerlink" href="#teaching-googletest-how-to-print-your-values" title="Link to this heading">¶</a></h3>
<p>Quando un’asserzione di test come <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ</span></code> fallisce, GoogleTest stampa i valori degli argomenti per eseguire il debug. Lo fa utilizzando una stampante con valori estensibile dall’utente.</p>
<p>Questa stampante sa lavorare con i tipi nativi di C++, gli array, i contenitori STL e qualsiasi tipo che supporti l’operatore <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>. Per gli altri tipi, stampa i byte grezzi nel valore e spera che l’utente possa capirlo.</p>
<p>Come accennato in precedenza, la stampante è <em>extensible</em>. Ciò significa che le si può insegnare a stampare un proprio tipo particolare piuttosto che eseguirne il dump dei byte. Per farlo, si definisce un overload di <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code> come una funzione template <code class="docutils literal notranslate"><span class="pre">friend</span></code> per il proprio tipo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// We want GoogleTest to be able to print instances of this.</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// Provide a friend overload.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Sink</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">AbslStringify</span><span class="p">(</span><span class="n">Sink</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sink</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">absl</span><span class="o">::</span><span class="n">Format</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sink</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(%d, %d)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// If you can&#39;t declare the function in the class it&#39;s important that the</span>
<span class="c1">// AbslStringify overload is defined in the SAME namespace that defines Point.</span>
<span class="c1">// C++&#39;s look-up rules rely on that.</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">EnumWithStringify</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">kMany</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">kChoices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Sink</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">AbslStringify</span><span class="p">(</span><span class="n">Sink</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sink</span><span class="p">,</span><span class="w"> </span><span class="n">EnumWithStringify</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">absl</span><span class="o">::</span><span class="n">Format</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sink</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EnumWithStringify</span><span class="o">::</span><span class="n">kMany</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;Many&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Choices&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace foo</span>
</pre></div>
</div>
<p>{: .callout .note} Nota: <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code> usa un generico buffer «sink» per costruire la sua stringa. For more information about supported operations on <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code>”s sink, see <a class="reference external" href="https://abseil.io/docs/cpp/guides/abslstringify">the <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code> documentation</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code> può anche usare l’identificatore di tipo «tuttofare» <code class="docutils literal notranslate"><span class="pre">%v</span></code> di <code class="docutils literal notranslate"><span class="pre">absl::StrFormat</span></code>”, all’interno delle proprie stringhe di formato per eseguire la deduzione del tipo. Il <code class="docutils literal notranslate"><span class="pre">Point</span></code> sopra potrebbe, per esempio, essere formattato come <code class="docutils literal notranslate"><span class="pre">&quot;(%v,</span> <span class="pre">%v)&quot;</span></code> e dedurre i valori <code class="docutils literal notranslate"><span class="pre">int</span></code> come <code class="docutils literal notranslate"><span class="pre">%d</span></code>.</p>
<p>A volte, <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code> potrebbe non essere un’opzione: il team potrebbe voler stampare tipi con informazioni di debug aggiuntive solo a scopo di test. Se è così, si può definire una funzione <code class="docutils literal notranslate"><span class="pre">PrintTo()</span></code> come questa:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;ostream&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">PrintTo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// If you can&#39;t declare the function in the class it&#39;s important that PrintTo()</span>
<span class="c1">// is defined in the SAME namespace that defines Point.  C++&#39;s look-up rules</span>
<span class="c1">// rely on that.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">PrintTo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Point</span><span class="o">&amp;</span><span class="w"> </span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace foo</span>
</pre></div>
</div>
<p>Se è stato definito sia <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code> che <code class="docutils literal notranslate"><span class="pre">PrintTo()</span></code>, quest’ultimo verrà utilizzato da GoogleTest. Ciò consente di personalizzare il modo in cui il valore appare nell’output di GoogleTest senza influenzare il codice che si basa sul comportamento di <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code>.</p>
<p>Se si dispone di un operatore <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> esistente e si vuol definire un <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code>, quest’ultimo verrà utilizzato per la stampa di GoogleTest.</p>
<p>Per stampare in proprio un valore <code class="docutils literal notranslate"><span class="pre">x</span></code> utilizzando la stampante dei valori di GoogleTest, basta chiamare <code class="docutils literal notranslate"><span class="pre">::testing::PrintToString(x)</span></code>, che restituisce una <code class="docutils literal notranslate"><span class="pre">std::string</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">point_ints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetPointIntVector</span><span class="p">();</span>

<span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">IsCorrectPointIntVector</span><span class="p">(</span><span class="n">point_ints</span><span class="p">))</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;point_ints = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">PrintToString</span><span class="p">(</span><span class="n">point_ints</span><span class="p">);</span>
</pre></div>
</div>
<p>For more details regarding <code class="docutils literal notranslate"><span class="pre">AbslStringify()</span></code> and its integration with other
libraries, see
<a class="reference external" href="https://abseil.io/docs/cpp/guides/abslstringify">the documentation</a>.</p>
</section>
<section id="regular-expression-syntax">
<h3>Sintassi delle Espressioni Regolari<a class="headerlink" href="#regular-expression-syntax" title="Link to this heading">¶</a></h3>
<p>Quando si builda con Bazel e utilizzando Abseil, GoogleTest usa la sintassi <a class="reference external" href="https://github.com/google/re2/wiki/Syntax">RE2</a>. Otherwise, for POSIX systems (Linux, Cygwin, Mac), GoogleTest uses the <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html#tag_09_04">POSIX extended regular expression</a> syntax. Per conoscere la sintassi POSIX, si potrebbe leggere questa <a class="reference external" href="https://en.wikipedia.org/wiki/Regular_expression#POSIX_extended">voce di Wikipedia</a>.</p>
<p>Su Windows, GoogleTest utilizza la propria semplice implementazione di espressioni regolari. Mancano molte funzionalità. Ad esempio, non supportiamo l’unione (<code class="docutils literal notranslate"><span class="pre">&quot;x|y&quot;</span></code>), il raggruppamento (<code class="docutils literal notranslate"><span class="pre">&quot;(xy)&quot;</span></code>), le parentesi quadre (<code class="docutils literal notranslate"><span class="pre">&quot;[xy]&quot;</span></code>) e il conteggio delle ripetizioni (<code class="docutils literal notranslate"><span class="pre">&quot;x{5,7}&quot;</span></code>), tra le altre cose. Di seguito è riportato ciò che supportiamo (<code class="docutils literal notranslate"><span class="pre">A</span></code> indica un carattere letterale, un punto (<code class="docutils literal notranslate"><span class="pre">.</span></code>), o una singola sequenza di escape <code class="docutils literal notranslate"><span class="pre">\\</span> </code>; <code class="docutils literal notranslate"><span class="pre">x</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span></code> denotano espressioni regolari):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Espressione</p></th>
<th class="head"><p>Significato</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
<td><p>corrisponde a qualsiasi carattere letterale <code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\d</span></code></p></td>
<td><p>corrisponde a qualsiasi cifra decimale</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\\D</span></code></p></td>
<td><p>corrisponde a qualsiasi carattere che non sia una cifra decimale</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\f</span></code></p></td>
<td><p>corisponde a <code class="docutils literal notranslate"><span class="pre">\f</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\\n</span></code></p></td>
<td><p>corisponde a <code class="docutils literal notranslate"><span class="pre">\n</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\r</span></code></p></td>
<td><p>corisponde a <code class="docutils literal notranslate"><span class="pre">\r</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\\s</span></code></p></td>
<td><p>corrisponde a qualsiasi spazio “bianco” ASCII, incluso <code class="docutils literal notranslate"><span class="pre">\n</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\S</span></code></p></td>
<td><p>corrisponde a qualsiasi carattere che non sia uno spazio “bianco”</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\\t</span></code></p></td>
<td><p>corisponde a <code class="docutils literal notranslate"><span class="pre">\t</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\v</span></code></p></td>
<td><p>corisponde a <code class="docutils literal notranslate"><span class="pre">\v</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\\w</span></code></p></td>
<td><p>corrisponde a qualsiasi lettera, <code class="docutils literal notranslate"><span class="pre">_</span></code>, o cifra decimale</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">\\W</span></code></p></td>
<td><p>corrisponde a qualsiasi carattere che non corrisponde a <code class="docutils literal notranslate"><span class="pre">\\w</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">\\c</span></code></p></td>
<td><p>corrisponde a qualsiasi carattere letterale <code class="docutils literal notranslate"><span class="pre">c</span></code>, che deve essere un segno di punteggiatura</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
<td><p>corrisponde a qualsiasi carattere singolo tranne <code class="docutils literal notranslate"><span class="pre">\n</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">A?</span></code></p></td>
<td><p>corrisponde a 0 o 1 occorrenze di <code class="docutils literal notranslate"><span class="pre">A</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">A*</span></code></p></td>
<td><p>corrisponde a 0 o più occorrenze di <code class="docutils literal notranslate"><span class="pre">A</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">A+</span></code></p></td>
<td><p>corrisponde a 0 o più occorrenze di <code class="docutils literal notranslate"><span class="pre">A</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>corrisponde all’inizio di una stringa (non a quello di ogni riga)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">$</span></code></p></td>
<td><p>corrisponde alla fine di una stringa (non a quella di ogni riga)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">xy</span></code></p></td>
<td><p>corrisponde a <code class="docutils literal notranslate"><span class="pre">x</span></code> seguito da <code class="docutils literal notranslate"><span class="pre">y</span></code></p></td>
</tr>
</tbody>
</table>
<p>Per aiutare a determinare quale funzionalità è disponibile sul sistema, GoogleTest definisce le macro per governare quale espressione regolare sta utilizzando. Le macro sono: <code class="docutils literal notranslate"><span class="pre">GTEST_USES_SIMPLE_RE=1</span></code> o <code class="docutils literal notranslate"><span class="pre">GTEST_USES_POSIX_RE=1</span></code>. Per far funzionare in ogni caso i death test, si può usare <code class="docutils literal notranslate"><span class="pre">#if</span></code> con queste macro o usare solo la sintassi più limitata.</p>
</section>
<section id="death-tests">
<h3>I Death Test<a class="headerlink" href="#death-tests" title="Link to this heading">¶</a></h3>
<p>In molte applicazioni sono presenti asserzioni che possono causare errori dell’applicazione se una condizione non viene soddisfatta. Questi controlli di coerenza, per verificare che il programma sia in uno stato sicuramente buono, sono destinati a fallire il prima possibile dopo che uno stato del programma viene corrotto. Se l’asserzione verifica la condizione sbagliata, il programma potrebbe procedere in uno stato errato, che potrebbe portare al danneggiamento della memoria, a buchi di sicurezza o peggio. Pertanto è di vitale importanza verificare che tali affermazioni funzionino come previsto.</p>
<p>Since these precondition checks cause the processes to die, we call such tests <em>death tests</em>. Più in generale, qualsiasi test che controlli se un programma termini (tranne che per un’eccezione) nel modo previsto è un «death test».</p>
<p>Si noti che se un pezzo di codice genera un’eccezione, non la si considera «morte» ai fini dei «death test», poiché il chiamante del codice potrebbe rilevare l’eccezione ed evitare il crash. Per verificare le eccezioni generate dal codice, consultare <a class="reference internal" href="#ExceptionAssertions"><span class="xref myst">Exception Assertions</span></a>.</p>
<p>Per testare gli errori <code class="docutils literal notranslate"><span class="pre">EXPECT_*()/ASSERT_*()</span></code> nel codice, consultare <a class="reference internal" href="#catching-failures">«Catching» degli Errori</a>.</p>
<section id="how-to-write-a-death-test">
<h4>Come Scrivere un Death Test<a class="headerlink" href="#how-to-write-a-death-test" title="Link to this heading">¶</a></h4>
<p>GoogleTest fornisce macro di asserzioni per supportare i death test. Vedere <a class="reference internal" href="#reference/assertions.md#death"><span class="xref myst">Death Assertions</span></a> nei «Riferimenti sulle Asserzioni» per i dettagli.</p>
<p>Per scrivere un death test, basta usare una delle macro nella funzione di test. Per esempio,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// This death test uses a compound statement.</span>
<span class="w">  </span><span class="n">ASSERT_DEATH</span><span class="p">({</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="n">Foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="s">&quot;Error on line .* of Foo()&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">NormalExit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EXPECT_EXIT</span><span class="p">(</span><span class="n">NormalExit</span><span class="p">(),</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">ExitedWithCode</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Success&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">KillProcess</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EXPECT_EXIT</span><span class="p">(</span><span class="n">KillProcess</span><span class="p">(),</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">KilledBySignal</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">),</span>
<span class="w">              </span><span class="s">&quot;Sending myself unblockable signal&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>verifica che:</p>
<ul class="simple">
<li><p>la chiamata a <code class="docutils literal notranslate"><span class="pre">Foo(5)</span></code> provoca la morte del processo con il messaggio di errore indicato,</p></li>
<li><p>la chiamata a <code class="docutils literal notranslate"><span class="pre">NormalExit()</span></code> fa sì che il processo stampi <code class="docutils literal notranslate"><span class="pre">&quot;Success&quot;</span></code> su stderr e esca con il codice di uscita 0, e</p></li>
<li><p>la chiamata a <code class="docutils literal notranslate"><span class="pre">KillProcess()</span></code> termina [kill] il processo con il segnale <code class="docutils literal notranslate"><span class="pre">SIGKILL</span></code>.</p></li>
</ul>
<p>{: .callout .warning}
Warning: If your death test contains mocks and is expecting a specific exit
code, then you must allow the mock objects to be leaked via <code class="docutils literal notranslate"><span class="pre">Mock::AllowLeak</span></code>.
This is because the mock leak detector will exit with its own error code if it
detects a leak.</p>
<p>Se necessario, il corpo della funzione di test può contenere anche altre asserzioni e dichiarazioni.</p>
<p>Notare che un death test si preoccupa solo di tre cose:</p>
<ol class="arabic simple">
<li><p>con l”<code class="docutils literal notranslate"><span class="pre">istruzione</span></code> si abortisce o si esce dal processo?</p></li>
<li><p>(nel caso di <code class="docutils literal notranslate"><span class="pre">ASSERT_EXIT</span></code> e di <code class="docutils literal notranslate"><span class="pre">EXPECT_EXIT</span></code>) lo stato di uscita soddisfa il <code class="docutils literal notranslate"><span class="pre">predicato</span></code>? Oppure (nel caso di <code class="docutils literal notranslate"><span class="pre">ASSERT_DEATH</span></code> e di <code class="docutils literal notranslate"><span class="pre">EXPECT_DEATH</span></code>) lo stato di uscita è diverso da zero? E</p></li>
<li><p>l’output su stderr corrisponde al <code class="docutils literal notranslate"><span class="pre">matcher</span></code>?</p></li>
</ol>
<p>In particolare, se l”<code class="docutils literal notranslate"><span class="pre">istruzione</span></code> genera un errore <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code> o <code class="docutils literal notranslate"><span class="pre">EXPECT_*</span></code>, <strong>non</strong> farà fallire il death test, poiché le asserzioni di GoogleTest non interrompono il processo.</p>
</section>
<section id="death-test-naming">
<h4>Nomenclatura del Death Test<a class="headerlink" href="#death-test-naming" title="Link to this heading">¶</a></h4>
<p>{: .callout .important} IMPORTANTE: Consigliamo vivamente di seguire la convenzione di denominare la <strong>test suite</strong> (not il test) <code class="docutils literal notranslate"><span class="pre">*DeathTest</span></code> quando contiene un death test, come mostrato nell’esempio precedente. La seguente sezione <a class="reference internal" href="#death-tests-and-threads">I Death Test E i Thread</a> spiega il perché.</p>
<p>Se una classe fixture è condivisa tra test normali e death test, si può utilizzare <code class="docutils literal notranslate"><span class="pre">using</span></code> o <code class="docutils literal notranslate"><span class="pre">typedef</span></code> per introdurre un alias per la classe fixture ed evitare di duplicarne il codice:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>

<span class="k">using</span><span class="w"> </span><span class="n">FooDeathTest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FooTest</span><span class="p">;</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesThis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// normal test</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesThat</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// death test</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="how-it-works">
<h4>Come Funziona<a class="headerlink" href="#how-it-works" title="Link to this heading">¶</a></h4>
<p>Vedere <a class="reference internal" href="#reference/assertions.md#death"><span class="xref myst">Death Assertions</span></a> nei «Riferimenti sulle Asserzioni».</p>
</section>
<section id="death-tests-and-threads">
<h4>I Death Test E i Thread<a class="headerlink" href="#death-tests-and-threads" title="Link to this heading">¶</a></h4>
<p>Il motivo dei due stili di death test ha a che fare con la «thread safety». A causa dei noti problemi con il forking in presenza dei thread, i death test dovrebbero essere eseguiti in un contesto a thread singolo. A volte, però, non è possibile organizzare questo tipo di ambiente. Ad esempio, i moduli inizializzati staticamente possono avviare i thread prima che venga raggiunto il main. Una volta creati i thread, potrebbe essere difficile o impossibile ripulirli.</p>
<p>GoogleTest ha tre funzionalità destinate ad aumentare la consapevolezza sui problemi di threading.</p>
<ol class="arabic simple">
<li><p>Viene emesso un warning se sono in esecuzione più thread quando viene riscontrato un death test.</p></li>
<li><p>Le test suite con un nome che termina con «DeathTest» vengono eseguite prima di tutti gli altri test.</p></li>
<li><p>Usa <code class="docutils literal notranslate"><span class="pre">clone()</span></code> invece di <code class="docutils literal notranslate"><span class="pre">fork()</span></code> per lo spawn del processo figlio su Linux (<code class="docutils literal notranslate"><span class="pre">clone()</span></code> non è disponibile su Cygwin né su Mac), in quanto <code class="docutils literal notranslate"><span class="pre">fork()</span></code> è più probabile che causi il blocco [hang] del figlio quando il processo genitore ha più thread.</p></li>
</ol>
<p>È perfettamente corretto creare thread all’interno di una dichiarazione di death test; vengono eseguiti in un processo separato e non possono influenzare il genitore.</p>
</section>
<section id="death-test-styles">
<h4>Stili dei Death Test<a class="headerlink" href="#death-test-styles" title="Link to this heading">¶</a></h4>
<p>Lo stile «threadsafe» del death test è stato introdotto per mitigare i rischi dei test in un ambiente multithread. Scambia un aumento del tempo di esecuzione del test (potenzialmente in modo drammatico) con una migliore sicurezza del thread.</p>
<p>Il framework di test automatizzato non imposta il flag dello stile. Si può scegliere un particolare stile dei death test, impostando il flag a da programma:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">death_test_style</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;threadsafe&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Lo si può fare nel <code class="docutils literal notranslate"><span class="pre">main()</span></code> per impostare lo stile per tutti i death test nel binario o nei singoli test. Ricordarsi che i flag vengono salvati prima di eseguire ciascun test e ripristinati alla fine, quindi non è necessario farlo esplicitamente. Per esempio:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">testing</span><span class="o">::</span><span class="n">InitGoogleTest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="w">  </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">death_test_style</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;fast&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">TestOne</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GTEST_FLAG_SET</span><span class="p">(</span><span class="n">death_test_style</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;threadsafe&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// This test is run in the &quot;threadsafe&quot; style:</span>
<span class="w">  </span><span class="n">ASSERT_DEATH</span><span class="p">(</span><span class="n">ThisShouldDie</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">TestTwo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// This test is run in the &quot;fast&quot; style:</span>
<span class="w">  </span><span class="n">ASSERT_DEATH</span><span class="p">(</span><span class="n">ThisShouldDie</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="caveats">
<h4>Avvertenze<a class="headerlink" href="#caveats" title="Link to this heading">¶</a></h4>
<p>L’argomento <code class="docutils literal notranslate"><span class="pre">statement</span></code> di <code class="docutils literal notranslate"><span class="pre">ASSERT_EXIT()</span></code> può essere qualsiasi istruzione C++ valida. Se lascia la funzione corrente tramite un’istruzione <code class="docutils literal notranslate"><span class="pre">return</span></code> o per un’eccezione, il death test viene considerato fallito. Alcune macro di GoogleTest potrebbero restituire dalla funzione corrente (ad esempio <code class="docutils literal notranslate"><span class="pre">ASSERT_TRUE()</span></code>), quindi sono da evitarle in <code class="docutils literal notranslate"><span class="pre">statement</span></code>.</p>
<p>Poiché <code class="docutils literal notranslate"><span class="pre">statement</span></code> viene eseguito nel processo figlio, qualsiasi effetto collaterale in memoria (ad esempio la modifica di una variabile, il rilascio di memoria, ecc.) da esso causato <em>non</em> sarà osservabile nel processo genitore. In particolare, se si rilascia memoria in un death test, il programma fallirà il controllo dell’heap poiché il processo principale non vedrà mai la memoria recuperata. Per risolvere questo problema, si può</p>
<ol class="arabic simple">
<li><p>cercare di non liberare la memoria in un death test;</p></li>
<li><p>liberare nuovamente la memoria nel processo genitore; o</p></li>
<li><p>non utilizzare l’heap checker nel programma.</p></li>
</ol>
<p>A causa di un dettaglio implementativo, non è possibile inserire più asserzioni di death test sulla stessa riga; in caso contrario la compilazione fallirà con un messaggio di errore non evidente.</p>
<p>Nonostante la migliorata sicurezza dei thread offerta dallo stile del death test «threadsafe», problemi dei thread come deadlock sono ancora possibili in presenza di gestori registrati con <code class="docutils literal notranslate"><span class="pre">pthread_atfork(3)</span></code>.</p>
</section>
</section>
<section id="using-assertions-in-sub-routines">
<h3>Uso delle Asserzioni nelle Sub-routine<a class="headerlink" href="#using-assertions-in-sub-routines" title="Link to this heading">¶</a></h3>
<p>{: .callout .note} Nota: Per inserire una serie di asserzioni di test in una subroutine per verificare una condizione complessa, considerare invece l’utilizzo di <span class="xref myst">un matcher GMock personalizzato</span>. Ciò consente di fornire un messaggio di errore più leggibile in caso di errore ed evitare tutti i problemi descritti di seguito.</p>
<section id="adding-traces-to-assertions">
<h4>Aggiungere Trace alle Asserzioni<a class="headerlink" href="#adding-traces-to-assertions" title="Link to this heading">¶</a></h4>
<p>Se una sub-routine di test viene chiamata da più posti, quando un’asserzione al suo interno fallisce, può essere difficile dire da quale invocazione della sub-routine provenga il fallimento. È possibile alleviare questo problema utilizzando log aggiuntivi o messaggi di errore personalizzati, ma ciò di solito è ingombrante per i test. Una soluzione migliore è quella di utilizzare la macro <code class="docutils literal notranslate"><span class="pre">SCOPED_TRACE</span></code> o l’utility <code class="docutils literal notranslate"><span class="pre">ScopedTrace</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SCOPED_TRACE</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ScopedTrace</span><span class="w"> </span><span class="n">trace</span><span class="p">(</span><span class="s">&quot;file_path&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">line_number</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">);</span>
</pre></div>
</div>
<p>dove <code class="docutils literal notranslate"><span class="pre">message</span></code> può essere qualsiasi cosa accodabile a <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code>. La macro <code class="docutils literal notranslate"><span class="pre">SCOPED_TRACE</span></code> farà sì che il nome del file corrente, il numero di riga e il messaggio specificato vengano aggiunti in ogni messaggio di errore. <code class="docutils literal notranslate"><span class="pre">ScopedTrace</span></code> accetta nomi di file e numeri di riga espliciti negli argomenti, il che è utile per scrivere helper di test. L’effetto verrà annullato quando il controllo lascerà lo scope lessicale corrente.</p>
<p>Per esempio,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mi">10</span><span class="o">:</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Sub1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="mi">11</span><span class="o">:</span><span class="w">   </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Bar</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="mi">12</span><span class="o">:</span><span class="w">   </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Bar</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="mi">13</span><span class="o">:</span><span class="w"> </span><span class="p">}</span>
<span class="mi">14</span><span class="o">:</span>
<span class="mi">15</span><span class="o">:</span><span class="w"> </span><span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="mi">16</span><span class="o">:</span><span class="w">   </span><span class="p">{</span>
<span class="mi">17</span><span class="o">:</span><span class="w">     </span><span class="n">SCOPED_TRACE</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// This trace point will be included in</span>
<span class="mi">18</span><span class="o">:</span><span class="w">                         </span><span class="c1">// every failure in this scope.</span>
<span class="mi">19</span><span class="o">:</span><span class="w">     </span><span class="n">Sub1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="mi">20</span><span class="o">:</span><span class="w">   </span><span class="p">}</span>
<span class="mi">21</span><span class="o">:</span><span class="w">   </span><span class="c1">// Now it won&#39;t.</span>
<span class="mi">22</span><span class="o">:</span><span class="w">   </span><span class="n">Sub1</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
<span class="mi">23</span><span class="o">:</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>potrebbe generare messaggi come questi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>path/to/foo_test.cc:11: Failure
Value of: Bar(n)
Expected: 1
  Actual: 2
Google Test trace:
path/to/foo_test.cc:17: A

path/to/foo_test.cc:12: Failure
Value of: Bar(n + 1)
Expected: 2
  Actual: 3
</pre></div>
</div>
<p>Senza il trace, sarebbe stato difficile sapere da quale invocazione di <code class="docutils literal notranslate"><span class="pre">Sub1()</span></code> provengono rispettivamente i due errori. (Si potrebbe aggiungere un messaggio extra a ciascuna asserzione in <code class="docutils literal notranslate"><span class="pre">Sub1()</span></code> per indicare il valore di <code class="docutils literal notranslate"><span class="pre">n</span></code>, ma è noioso).</p>
<p>Alcuni suggerimenti sull’utilizzo di <code class="docutils literal notranslate"><span class="pre">SCOPED_TRACE</span></code>:</p>
<ol class="arabic simple">
<li><p>Con un messaggio adatto, spesso è sufficiente utilizzare <code class="docutils literal notranslate"><span class="pre">SCOPED_TRACE</span></code> all’inizio di una subroutine, anziché in ciascuna chiamata.</p></li>
<li><p>Quando si chiamano subroutine all’interno di un ciclo, rendere l’iteratore del ciclo parte del messaggio in <code class="docutils literal notranslate"><span class="pre">SCOPED_TRACE</span></code> in modo tale da poter sapere da quale iterazione proviene l’errore.</p></li>
<li><p>A volte il numero di riga del punto del trace è sufficiente per identificare la particolare invocazione di una subroutine. In questo caso, non è necessario scegliere un messaggio univoco per <code class="docutils literal notranslate"><span class="pre">SCOPED_TRACE</span></code>. Basta usare <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>.</p></li>
<li><p>Si può utilizzare <code class="docutils literal notranslate"><span class="pre">SCOPED_TRACE</span></code> in uno scope interno (annidato) quando ce n’è uno nello scope esterno. In questo caso, tutti i trace point attivi verranno inclusi nei messaggi di errore, nell’ordine inverso in cui vengono incontrati.</p></li>
<li><p>Il trace dump è cliccabile in Emacs: premere <code class="docutils literal notranslate"><span class="pre">return</span></code> su un numero di riga e si passerà a quella riga nel file sorgente!</p></li>
</ol>
</section>
<section id="propagating-fatal-failures">
<h4>Propagazione degli Errori Fatali<a class="headerlink" href="#propagating-fatal-failures" title="Link to this heading">¶</a></h4>
<p>A common pitfall when using <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code> and <code class="docutils literal notranslate"><span class="pre">FAIL*</span></code> is not understanding that when they fail they only abort the <em>current function</em>, not the entire test. Per esempio, il seguente test genererà un segfault:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Subroutine</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Generates a fatal failure and aborts the current function.</span>
<span class="w">  </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// The following won&#39;t be executed.</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Subroutine</span><span class="p">();</span><span class="w">  </span><span class="c1">// The intended behavior is for the fatal failure</span>
<span class="w">                 </span><span class="c1">// in Subroutine() to abort the entire test.</span>

<span class="w">  </span><span class="c1">// The actual behavior: the function goes on after Subroutine() returns.</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">  </span><span class="c1">// Segfault!</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Per alleviare questo problema, GoogleTest fornisce tre diverse soluzioni. Potresti utilizzare le eccezioni, le asserzioni <code class="docutils literal notranslate"><span class="pre">(ASSERT|EXPECT)_NO_FATAL_FAILURE</span></code> o la funzione <code class="docutils literal notranslate"><span class="pre">HasFatalFailure()</span></code>. Sono tutte descritte nelle due sottosezioni seguenti.</p>
<section id="asserting-on-subroutines-with-an-exception">
<h5>Asserzione sulle Subroutine con un’eccezione<a class="headerlink" href="#asserting-on-subroutines-with-an-exception" title="Link to this heading">¶</a></h5>
<p>Il seguente codice può trasformare ASSERT-failure in un’eccezione:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ThrowListener</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">EmptyTestEventListener</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnTestPartResult</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestPartResult</span><span class="o">&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestPartResult</span><span class="o">::</span><span class="n">kFatalFailure</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">AssertionException</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">testing</span><span class="o">::</span><span class="n">UnitTest</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">listeners</span><span class="p">().</span><span class="n">Append</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ThrowListener</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Questo listener deve essere aggiunto dopo gli altri listener, se ce ne sono, altrimenti non vedranno <code class="docutils literal notranslate"><span class="pre">OnTestPartResult</span></code> fallire.</p>
</section>
<section id="asserting-on-subroutines">
<h5>Asserzione sulle Subroutine<a class="headerlink" href="#asserting-on-subroutines" title="Link to this heading">¶</a></h5>
<p>Come mostrato sopra, se il test chiama una subroutine che presenta un errore <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code>, il test continuerà dopo il ritorno della subroutine. Questo potrebbe non essere quello che si vuole.</p>
<p>Spesso le persone vogliono che i fallimenti fatali si propaghino come le eccezioni. Per questo GoogleTest offre le seguenti macro:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Asserzione fatale</p></th>
<th class="head"><p>Asserzione non-fatale</p></th>
<th class="head"><p>Verifica</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ASSERT_NO_FATAL_FAILURE(statement);</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">EXPECT_NO_FATAL_FAILURE(statement);</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">statement</span></code> non genera nuovi errori fatali nel thread corrente.</p></td>
</tr>
</tbody>
</table>
<p>Vengono controllati solo gli errori nel thread che esegue l’asserzione per determinare il risultato di questo tipo di asserzioni. Se <code class="docutils literal notranslate"><span class="pre">statement</span></code> crea nuovi thread, gli errori in questi thread vengono ignorati.</p>
<p>Esempi:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ASSERT_NO_FATAL_FAILURE</span><span class="p">(</span><span class="n">Foo</span><span class="p">());</span>

<span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="n">EXPECT_NO_FATAL_FAILURE</span><span class="p">({</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bar</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Le asserzioni provenienti da più thread non sono attualmente supportate in Windows.</p>
</section>
<section id="checking-for-failures-in-the-current-test">
<h5>Verifica degli Errori nel Test Corrente<a class="headerlink" href="#checking-for-failures-in-the-current-test" title="Link to this heading">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">HasFatalFailure()</span></code> nella classe <code class="docutils literal notranslate"><span class="pre">::testing::Test</span></code> restituisce <code class="docutils literal notranslate"><span class="pre">true</span></code> se un’asserzione nel test corrente ha subito un fallimento fatale. Ciò consente alle funzioni di rilevare errori fatali in una subroutine e di tornare anticipatamente.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">HasFatalFailure</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>L’utilizzo tipico, che sostanzialmente simula il comportamento della generazione di un’eccezione, è:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Subroutine</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Aborts if Subroutine() had a fatal failure.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">HasFatalFailure</span><span class="p">())</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// The following won&#39;t be executed.</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Se <code class="docutils literal notranslate"><span class="pre">HasFatalFailure()</span></code> viene utilizzato al di fuori di <code class="docutils literal notranslate"><span class="pre">TEST()</span></code> , <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code> o di una test fixture, si deve aggiungere il prefisso <code class="docutils literal notranslate"><span class="pre">::testing::Test::</span></code>, come in:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="o">::</span><span class="n">HasFatalFailure</span><span class="p">())</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
</pre></div>
</div>
<p>Allo stesso modo, <code class="docutils literal notranslate"><span class="pre">HasNonfatalFailure()</span></code> restituisce <code class="docutils literal notranslate"><span class="pre">true</span></code> se il test corrente ha almeno un errore non fatale e <code class="docutils literal notranslate"><span class="pre">HasFailure()</span></code> restituisce <code class="docutils literal notranslate"><span class="pre">true</span></code> se il test corrente presenta almeno un errore di entrambi i tipi.</p>
</section>
</section>
</section>
<section id="logging-additional-information">
<h3>Log di Informazioni Aggiuntive<a class="headerlink" href="#logging-additional-information" title="Link to this heading">¶</a></h3>
<p>Nel codice del test, si può chiamare <code class="docutils literal notranslate"><span class="pre">RecordProperty(&quot;key&quot;,</span> <span class="pre">value)</span></code> per loggare informazioni aggiuntive, dove <code class="docutils literal notranslate"><span class="pre">value</span></code> può essere una stringa o un <code class="docutils literal notranslate"><span class="pre">int</span></code>. L”<em>ultimo</em> valore registrato per una chiave verrà emesso nell”<a class="reference internal" href="#generating-an-xml-report">XML output</a> se se ne specifica uno. Per esempio, il test</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">WidgetUsageTest</span><span class="p">,</span><span class="w"> </span><span class="n">MinAndMaxWidgets</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">RecordProperty</span><span class="p">(</span><span class="s">&quot;MaximumWidgets&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ComputeMaxUsage</span><span class="p">());</span>
<span class="w">  </span><span class="n">RecordProperty</span><span class="p">(</span><span class="s">&quot;MinimumWidgets&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ComputeMinUsage</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>restituirà XML in questo modo:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="w">  </span>...
<span class="w">    </span><span class="nt">&lt;testcase</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MinAndMaxWidgets&quot;</span><span class="w"> </span><span class="na">file=</span><span class="s">&quot;test.cpp&quot;</span><span class="w"> </span><span class="na">line=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">status=</span><span class="s">&quot;run&quot;</span><span class="w"> </span><span class="na">time=</span><span class="s">&quot;0.006&quot;</span><span class="w"> </span><span class="na">classname=</span><span class="s">&quot;WidgetUsageTest&quot;</span><span class="w"> </span><span class="na">MaximumWidgets=</span><span class="s">&quot;12&quot;</span><span class="w"> </span><span class="na">MinimumWidgets=</span><span class="s">&quot;9&quot;</span><span class="w"> </span><span class="nt">/&gt;</span>
<span class="w">  </span>...
</pre></div>
</div>
<p>{: .callout .note}</p>
<blockquote>
<div><p>NOTA:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RecordProperty()</span></code> è un membro statico della classe <code class="docutils literal notranslate"><span class="pre">Test</span></code>. Pertanto deve avere il prefisso <code class="docutils literal notranslate"><span class="pre">::testing::Test::</span></code> se utilizzato al di fuori del corpo di <code class="docutils literal notranslate"><span class="pre">TEST</span></code> e della classe della fixture.</p></li>
<li><p><em><code class="docutils literal notranslate"><span class="pre">key</span></code></em> deve essere un nome di un attributo XML valido e non può entrare in conflitto con quelli già utilizzati da GoogleTest (<code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">status</span></code>, <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">classname</span></code>, <code class="docutils literal notranslate"><span class="pre">type_param</span></code>, e <code class="docutils literal notranslate"><span class="pre">value_param</span></code>).</p></li>
<li><p>È consentito chiamare <code class="docutils literal notranslate"><span class="pre">RecordProperty()</span></code> al di fuori della durata [lifespan] di un test. Se viene chiamato al di fuori di un test ma tra i metodi <code class="docutils literal notranslate"><span class="pre">SetUpTestSuite()</span></code> e <code class="docutils literal notranslate"><span class="pre">TearDownTestSuite()</span></code> della test suite, verrà attribuito all’elemento XML per la test suite. Se viene chiamato al di fuori di tutte le test suite (ad esempio in un ambiente di test), verrà attribuito all’elemento XML di livello superiore.</p></li>
</ul>
</div></blockquote>
</section>
<section id="sharing-resources-between-tests-in-the-same-test-suite">
<h3>Condivisione delle Risorse Tra Test nella Stessa Test Suite<a class="headerlink" href="#sharing-resources-between-tests-in-the-same-test-suite" title="Link to this heading">¶</a></h3>
<p>GoogleTest crea un nuovo oggetto fixture per ogni test per rendere i test indipendenti e più facili da debuggare. Tuttavia, a volte i test utilizzano risorse costose da configurare, rendendo il modello «one-copy-per-test» proibitivamente costoso.</p>
<p>Se i test non modificano la risorsa, non c’è alcun danno nel condividere una singola copia della risorsa. Pertanto, oltre alla configurazione/dismissione per ogni test, GoogleTest supporta anche la configurazione/dismissione per ogni test suite. Per usarlo:</p>
<ol class="arabic simple">
<li><p>Nella classe della fixture (ad esempio <code class="docutils literal notranslate"><span class="pre">FooTest</span></code>), si dichiarano come <code class="docutils literal notranslate"><span class="pre">static</span></code> alcune variabili membro per contenere le risorse condivise.</p></li>
<li><p>All’esterno della classe fixture (in genere appena sotto di essa), si definiscono tali variabili membro, facoltativamente dando loro valori iniziali.</p></li>
<li><p>Nella stessa classe fixture, si definisce una funzione membro pubblica <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">SetUpTestSuite()</span></code> (ricordarsi di non scriverlo come <strong><code class="docutils literal notranslate"><span class="pre">SetupTestSuite</span></code></strong> con una <code class="docutils literal notranslate"><span class="pre">u</span></code> minuscola!) per impostare le risorse condivise e una funzione <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">void</span> <span class="pre">TearDownTestSuite()</span></code> per eliminarle.</p></li>
</ol>
<p>Questo è tutto! GoogleTest chiama automaticamente <code class="docutils literal notranslate"><span class="pre">SetUpTestSuite()</span></code> prima di eseguire il <em>primo test</em> nella test suite <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> (ovvero prima di creare il primo oggetto <code class="docutils literal notranslate"><span class="pre">FooTest</span></code>) e chiama <code class="docutils literal notranslate"><span class="pre">TearDownTestSuite()</span></code> dopo aver eseguito l”<em>ultimo test</em> al suo interno (ovvero dopo aver eliminato l’ultimo oggetto <code class="docutils literal notranslate"><span class="pre">FooTest</span></code>). Nel mezzo, i test possono utilizzare le risorse condivise.</p>
<p>Da ricordare che l’ordine dei test non è definito, quindi il codice non può dipendere da un test che ne precede o ne segue un altro. Inoltre, i test non devono modificare lo stato di alcuna risorsa condivisa oppure, se modificano lo stato, devono ripristinarlo al suo valore originale prima di passare il controllo al test successivo.</p>
<p>Notare che <code class="docutils literal notranslate"><span class="pre">SetUpTestSuite()</span></code> può essere chiamato più volte per una classe fixture che ha classi derivate, quindi non ci si deve aspettare che il codice nel corpo della funzione venga eseguito solo una volta. Inoltre, le classi derivate hanno ancora accesso alle risorse condivise definite come membri statici, quindi è necessaria un’attenta considerazione quando si gestiscono le risorse condivise per evitare «memory leak» se le risorse condivise non vengono ripulite correttamente in <code class="docutils literal notranslate"><span class="pre">TearDownTestSuite()</span></code>.</p>
<p>Ecco un esempio di configurazione e dismissione «per-test-suite»:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Per-test-suite set-up.</span>
<span class="w">  </span><span class="c1">// Called before the first test in this test suite.</span>
<span class="w">  </span><span class="c1">// Can be omitted if not needed.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">SetUpTestSuite</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">shared_resource_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="p">...;</span>

<span class="w">    </span><span class="c1">// If `shared_resource_` is **not deleted** in `TearDownTestSuite()`,</span>
<span class="w">    </span><span class="c1">// reallocation should be prevented because `SetUpTestSuite()` may be called</span>
<span class="w">    </span><span class="c1">// in subclasses of FooTest and lead to memory leak.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// if (shared_resource_ == nullptr) {</span>
<span class="w">    </span><span class="c1">//   shared_resource_ = new ...;</span>
<span class="w">    </span><span class="c1">// }</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Per-test-suite tear-down.</span>
<span class="w">  </span><span class="c1">// Called after the last test in this test suite.</span>
<span class="w">  </span><span class="c1">// Can be omitted if not needed.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">TearDownTestSuite</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">shared_resource_</span><span class="p">;</span>
<span class="w">    </span><span class="n">shared_resource_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// You can define per-test set-up logic as usual.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SetUp</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// You can define per-test tear-down logic as usual.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">TearDown</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Some expensive resource shared by all tests.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">shared_resource_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">FooTest</span><span class="o">::</span><span class="n">shared_resource_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Test1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">refer</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">shared_resource_</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Test2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">you</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">refer</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">shared_resource_</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>{: .callout .note} NOTA: Sebbene il codice sopra dichiari <code class="docutils literal notranslate"><span class="pre">SetUpTestSuite()</span></code> protected, a volte potrebbe essere necessario dichiararlo pubblico, come quando lo si utilizza con <code class="docutils literal notranslate"><span class="pre">TEST_P</span></code>.</p>
</section>
<section id="global-set-up-and-tear-down">
<h3>Set-Up e Tear-Down Globali<a class="headerlink" href="#global-set-up-and-tear-down" title="Link to this heading">¶</a></h3>
<p>Proprio come è possibile eseguire l’impostazione e la dismissione [tear-down] a livello di test e di test suite, è possibile farlo anche a livello di programma di test. Ecco come.</p>
<p>Per prima cosa, si crea una sottoclasse della classe <code class="docutils literal notranslate"><span class="pre">::testing::Environment</span></code> per definire un ambiente di test, che sappia come impostare e dismettere:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Environment</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Environment</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="o">~</span><span class="n">Environment</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Override this to define how to set up the environment.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SetUp</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// Override this to define how to tear down the environment.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">TearDown</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Poi, si registra un’istanza della classe di ambiente con GoogleTest chiamando la funzione <code class="docutils literal notranslate"><span class="pre">::testing::AddGlobalTestEnvironment()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Environment</span><span class="o">*</span><span class="w"> </span><span class="nf">AddGlobalTestEnvironment</span><span class="p">(</span><span class="n">Environment</span><span class="o">*</span><span class="w"> </span><span class="n">env</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, when <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code> is invoked, it first calls the <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> method. The
tests are then executed, provided that none of the environments have reported
fatal failures and <code class="docutils literal notranslate"><span class="pre">GTEST_SKIP()</span></code> has not been invoked. Finally, <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> is
called.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> and <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> are only invoked if there is at least one
test to be performed. Importantly, <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> is executed even if the test is
not run due to a fatal failure or <code class="docutils literal notranslate"><span class="pre">GTEST_SKIP()</span></code>.</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> and <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> for each iteration depends on the flag
<code class="docutils literal notranslate"><span class="pre">gtest_recreate_environments_when_repeating</span></code>. <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> and <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> are
called for each environment object when the object is recreated for each
iteration. However, if test environments are not recreated for each iteration,
<code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> is called only on the first iteration, and <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> is called only
on the last iteration.</p>
<p>È consentito registrare più oggetti dell’ambiente. In questa suite, il loro <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> verrà chiamato nell’ordine in cui sono registrati, e il loro <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> verrà chiamato nell’ordine inverso.</p>
<p>Si noti che GoogleTest assume la proprietà degli oggetti dell’ambiente registrati. Pertanto <strong>non vanno eliminati</strong> manualmente.</p>
<p>Si deve chiamare <code class="docutils literal notranslate"><span class="pre">AddGlobalTestEnvironment()</span></code> prima di chiamare <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>, probabilmente in <code class="docutils literal notranslate"><span class="pre">main()</span></code>. Se si usa <code class="docutils literal notranslate"><span class="pre">gtest_main</span></code>, lo si deve chiamare prima dell’avvio di <code class="docutils literal notranslate"><span class="pre">main()</span></code> affinché abbia effetto. Un modo per farlo è definire una variabile globale come questa:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">testing</span><span class="o">::</span><span class="n">Environment</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">foo_env</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">testing</span><span class="o">::</span><span class="n">AddGlobalTestEnvironment</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">FooEnvironment</span><span class="p">);</span>
</pre></div>
</div>
<p>Tuttavia, consigliamo vivamente di scrivere il <code class="docutils literal notranslate"><span class="pre">main()</span></code> e di chiamare <code class="docutils literal notranslate"><span class="pre">AddGlobalTestEnvironment()</span></code> lì, poiché fare affidamento sull’inizializzazione delle variabili globali rende il codice più difficile da leggere e potrebbe causare problemi quando si registrano più ambienti da diverse unità di traduzione e gli ambienti hanno dipendenze tra loro (ricordare che il compilatore non garantisce l’ordine in cui vengono inizializzate le variabili globali di diverse unità di traduzione).</p>
</section>
<section id="value-parameterized-tests">
<h3>Test con Valori Parametrizzati<a class="headerlink" href="#value-parameterized-tests" title="Link to this heading">¶</a></h3>
<p>I <em>test con valori parametrizzati</em> consentono di testare il codice con parametri diversi senza scrivere più copie dello stesso test. Ciò è utile in diverse situazioni, ad esempio:</p>
<ul class="simple">
<li><p>Si ha una porzione di codice il cui comportamento è influenzato da uno o più flag della riga di comando. Si vuole essere sicuri che il codice funzioni correttamente per vari valori di questi flag.</p></li>
<li><p>Si vogliono testare diverse implementazioni di un’interfaccia OO.</p></li>
<li><p>Si vuol testare il codice su vari input (ovvero test basati sui dati [data-driven testing]). È facile abusare di questa funzione, quindi è meglio usare il buon senso!</p></li>
</ul>
<section id="how-to-write-value-parameterized-tests">
<h4>Come Scrivere Test con Valori Parametrizzati<a class="headerlink" href="#how-to-write-value-parameterized-tests" title="Link to this heading">¶</a></h4>
<p>Per scrivere test con valori parametrizzati, è necessario innanzitutto definire una classe fixture. Deve essere derivata sia da <code class="docutils literal notranslate"><span class="pre">testing::Test</span></code> che da <code class="docutils literal notranslate"><span class="pre">testing::WithParamInterface&lt;T&gt;</span></code> (quest’ultima è un’interfaccia pura), dove <code class="docutils literal notranslate"><span class="pre">T</span></code> è il tipo dei valori parametrizzati. Per comodità, si può semplicemente derivare la classe fixture da <code class="docutils literal notranslate"><span class="pre">testing::TestWithParam&lt;T&gt;</span></code>, che a sua volta è derivata sia da <code class="docutils literal notranslate"><span class="pre">testing::Test</span></code>
che da <code class="docutils literal notranslate"><span class="pre">testing::WithParamInterface&lt;T&gt;</span></code>. <code class="docutils literal notranslate"><span class="pre">T</span></code> può essere qualsiasi tipo copiabile. Se si tratta di un puntatore semplice [raw], si è responsabili della gestione della durata dei valori puntati.</p>
<p>{: .callout .note} NOTA: Se la fixture definisce <code class="docutils literal notranslate"><span class="pre">SetUpTestSuite()</span></code> o <code class="docutils literal notranslate"><span class="pre">TearDownTestSuite()</span></code> devono essere dichiarati <strong>public</strong> anziché <strong>protected</strong> per poter utilizzare <code class="docutils literal notranslate"><span class="pre">TEST_P</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestWithParam</span><span class="o">&lt;</span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// You can implement all the usual fixture class members here.</span>
<span class="w">  </span><span class="c1">// To access the test parameter, call GetParam() from class</span>
<span class="w">  </span><span class="c1">// TestWithParam&lt;T&gt;.</span>
<span class="p">};</span>

<span class="c1">// Or, when you want to add parameters to a pre-existing fixture class:</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BarTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">BaseTest</span><span class="p">,</span>
<span class="w">                </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">WithParamInterface</span><span class="o">&lt;</span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Poi, si usa la macro <code class="docutils literal notranslate"><span class="pre">TEST_P</span></code> per definire tutti i pattern di test desiderati utilizzando questa fixture. Il suffisso <code class="docutils literal notranslate"><span class="pre">_P</span></code> sta per «parametrizzato» o «pattern», a seconda di come si preferisce pensare.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_P</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesBlah</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Inside a test, access the test parameter with the GetParam() method</span>
<span class="w">  </span><span class="c1">// of the TestWithParam&lt;T&gt; class:</span>
<span class="w">  </span><span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">Blah</span><span class="p">(</span><span class="n">GetParam</span><span class="p">()));</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">TEST_P</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">HasBlahBlah</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Infine, si può utilizzare la macro <code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TEST_SUITE_P</span></code> per istanziare la test suite con qualsiasi set di parametri desiderato. GoogleTest definisce una serie di funzioni per la generazione di parametri di test: vedere i dettagli in <a class="reference internal" href="#reference/testing.md#INSTANTIATE_TEST_SUITE_P"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TEST_SUITE_P</span></code></span></a> nel «Riferimento al Testing».</p>
<p>Ad esempio, la seguente istruzione istanzia i test dalla test suite <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> ciascuno con i valori dei parametrzzati <code class="docutils literal notranslate"><span class="pre">&quot;meeny&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;miny&quot;</span></code> e <code class="docutils literal notranslate"><span class="pre">&quot;moe&quot;</span></code> utilizzando il generatore di parametri <a class="reference internal" href="#reference/testing.md#param-generators"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">Values</span></code></span></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">INSTANTIATE_TEST_SUITE_P</span><span class="p">(</span><span class="n">MeenyMinyMoe</span><span class="p">,</span>
<span class="w">                         </span><span class="n">FooTest</span><span class="p">,</span>
<span class="w">                         </span><span class="n">testing</span><span class="o">::</span><span class="n">Values</span><span class="p">(</span><span class="s">&quot;meeny&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;miny&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;moe&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>{: .callout .note} NOTA: Il codice precedente deve essere inserito nello scope globale o del namespace, non nello scope della funzione.</p>
<p>Il primo argomento di <code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TEST_SUITE_P</span></code> è un nome univoco per l’istanziazione della test suite. L’argomento successivo è il nome del pattern di test e l’ultimo è il <a class="reference internal" href="#reference/testing.md#param-generators"><span class="xref myst">generatore di parametri</span></a> [parameter generator].</p>
<p>L’espressione del generatore di parametri non viene valutata finché GoogleTest non viene inizializzato (tramite <code class="docutils literal notranslate"><span class="pre">InitGoogleTest()</span></code>). Qualsiasi inizializzazione precedente eseguita nella funzione <code class="docutils literal notranslate"><span class="pre">main</span></code> sarà accessibile dal generatore di parametri, ad esempio i risultati del parsing dei flag.</p>
<p>È possibile istanziare un pattern di test più di una volta, quindi per distinguere le diverse istanze del pattern, il nome di istanziazione viene aggiunto come prefisso a quello effettivo della test suite. Ricordarsi di scegliere prefissi univoci per le diverse istanze. I test dell’istanziazione precedente avranno questi nomi:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MeenyMinyMoe/FooTest.DoesBlah/0</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;meeny&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeenyMinyMoe/FooTest.DoesBlah/1</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;miny&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeenyMinyMoe/FooTest.DoesBlah/2</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;moe&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeenyMinyMoe/FooTest.HasBlahBlah/0</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;meeny&quot;</span></code></p></li>
<li><p>MeenyMinyMoe/FooTest.HasBlahBlah/1<code class="docutils literal notranslate"><span class="pre">per</span></code>»miny»`</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeenyMinyMoe/FooTest.HasBlahBlah/2</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;moe&quot;</span></code></p></li>
</ul>
<p>Si possono usare questi nomi in <a class="reference internal" href="#running-a-subset-of-the-tests"><code class="docutils literal notranslate"><span class="pre">--gtest_filter</span></code></a>.</p>
<p>La seguente istruzione istanzia nuovamente tutti i test da <code class="docutils literal notranslate"><span class="pre">FooTest</span></code>, ciascuno con i valori dei parametri <code class="docutils literal notranslate"><span class="pre">&quot;cat&quot;</span></code> e <code class="docutils literal notranslate"><span class="pre">&quot;dog&quot;</span></code> utilizzando il generatore di parametri <a class="reference internal" href="#reference/testing.md#param-generators"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">ValuesIn</span></code></span></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">constexpr</span><span class="w"> </span><span class="n">absl</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">kPets</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;cat&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dog&quot;</span><span class="p">};</span>
<span class="n">INSTANTIATE_TEST_SUITE_P</span><span class="p">(</span><span class="n">Pets</span><span class="p">,</span><span class="w"> </span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">ValuesIn</span><span class="p">(</span><span class="n">kPets</span><span class="p">));</span>
</pre></div>
</div>
<p>I test dell’istanziazione precedente avranno questi nomi:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Pets/FooTest.DoesBlah/0</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;cat&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pets/FooTest.DoesBlah/1</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;dog&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pets/FooTest.HasBlahBlah/0</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;cat&quot;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pets/FooTest.HasBlahBlah/1</span></code> per <code class="docutils literal notranslate"><span class="pre">&quot;dog&quot;</span></code></p></li>
</ul>
<p>Si noti che <code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TEST_SUITE_P</span></code> istanzia <em>tutti</em> i test nella test suite, indipendentemente dal fatto che le loro definizioni vengano prima o <em>dopo</em> la dichiarazione <code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TEST_SUITE_P</span></code>.</p>
<p>Inoltre, per default, ogni <code class="docutils literal notranslate"><span class="pre">TEST_P</span></code> senza un corrispondente <code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TEST_SUITE_P</span></code> provoca un test non riuscito nella test suite <code class="docutils literal notranslate"><span class="pre">GoogleTestVerification</span></code>. Se si dispone di una test suite in cui tale omissione non è un errore, ad esempio è in una libreria che potrebbe essere linkata per altri motivi o dove l’elenco dei casi di test è dinamico e potrebbe essere vuoto, allora questo controllo può essere soppresso taggando la test suite:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">);</span>
</pre></div>
</div>
<p>Esaminare [sample7_unittest.cc] e [sample8_unittest.cc] per altri esempi.</p>
</section>
<section id="creating-value-parameterized-abstract-tests">
<h4>Creazione di Test Astratti con Valori Parametrizzati<a class="headerlink" href="#creating-value-parameterized-abstract-tests" title="Link to this heading">¶</a></h4>
<p>Abbiamo definito e istanziato <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> nello <em>stesso</em> file sorgente. A volte si vorrebbero definire test con valori parametrizzati in una libreria e consentire ad altre persone di crearne un’istanza successivamente. Questo pattern è detto <em>test astratti</em> [abstract tests]. Come esempio della sua applicazione, quando si progetta un’interfaccia è possibile scrivere una suite standard di test astratti (magari utilizzando una funzione factory come parametro di test) e ci si aspetta che tutte le implementazioni dell’interfaccia li superino. Quando qualcuno implementa l’interfaccia, può creare un’istanza della suite per ottenere gratuitamente tutti i test di conformità dell’interfaccia.</p>
<p>Per definire test astratti, si deve organizzare il codice in questo modo:</p>
<ol class="arabic simple">
<li><p>Si inserisce la definizione della classe della fixture parametrizzata (ad esempio <code class="docutils literal notranslate"><span class="pre">FooTest</span></code>) nel file header, ad esempio <code class="docutils literal notranslate"><span class="pre">foo_param_test.h</span></code>. Lo si consideri come una <em>dichiarazione</em> dei test astratti.</p></li>
<li><p>Si inseriscono le definizioni <code class="docutils literal notranslate"><span class="pre">TEST_P</span></code> in <code class="docutils literal notranslate"><span class="pre">foo_param_test.cc</span></code>, che include <code class="docutils literal notranslate"><span class="pre">foo_param_test.h</span></code>. Lo si consideri come <em>implementazione</em> dei test astratti.</p></li>
</ol>
<p>Una volta definiti, se ne può creare un’istanza includendo <code class="docutils literal notranslate"><span class="pre">foo_param_test.h</span></code>, richiamando <code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TEST_SUITE_P()</span></code> e in base alla libreria target che contiene <code class="docutils literal notranslate"><span class="pre">foo_param_test.cc</span></code>. È possibile istanziare la stessa test suite astratta più volte, possibilmente in file sorgenti diversi.</p>
</section>
<section id="specifying-names-for-value-parameterized-test-parameters">
<h4>Specificare i Nomi per i Parametri di test con Valori Parametrizzati<a class="headerlink" href="#specifying-names-for-value-parameterized-test-parameters" title="Link to this heading">¶</a></h4>
<p>L’ultimo argomento facoltativo di <code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TEST_SUITE_P()</span></code> consente all’utente di specificare una funzione o un funtore che genera suffissi personalizzati del nome del test in base ai parametri. La funzione deve accettare un argomento di tipo <code class="docutils literal notranslate"><span class="pre">testing::TestParamInfo&lt;class</span> <span class="pre">ParamType&gt;</span></code> e restituire <code class="docutils literal notranslate"><span class="pre">std::string</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">testing::PrintToStringParamName</span></code> è un generatore di suffissi nativo che restituisce il valore di <code class="docutils literal notranslate"><span class="pre">testing::PrintToString(GetParam())</span></code>. Non funziona con <code class="docutils literal notranslate"><span class="pre">std::string</span></code> né con stringhe C.</p>
<p>{: .callout .note} NOTA: i nomi dei test devono essere non vuoti, univoci e possono contenere solo caratteri alfanumerici ASCII. In particolare, <span class="xref myst">non devono contenere gli underscore</span></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyTestSuite</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestWithParam</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="n">TEST_P</span><span class="p">(</span><span class="n">MyTestSuite</span><span class="p">,</span><span class="w"> </span><span class="n">MyTest</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Example Test Param: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">GetParam</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">INSTANTIATE_TEST_SUITE_P</span><span class="p">(</span><span class="n">MyGroup</span><span class="p">,</span><span class="w"> </span><span class="n">MyTestSuite</span><span class="p">,</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span>
<span class="w">                         </span><span class="n">testing</span><span class="o">::</span><span class="n">PrintToStringParamName</span><span class="p">());</span>
</pre></div>
</div>
<p>Fornire un funtore personalizzato consente un maggiore controllo sulla generazione dei nomi dei parametri dei test, in particolare per i tipi in cui la conversione automatica non genera nomi utili (ad esempio le stringhe come mostrato sopra). L’esempio seguente lo illustra per più parametri, un tipo di enumerazione e una stringa e mostra anche come combinare i generatori. Utilizza una lambda per concisione:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyType</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MY_FOO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">MY_BAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyTestSuite</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestWithParam</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">MyType</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>

<span class="n">INSTANTIATE_TEST_SUITE_P</span><span class="p">(</span>
<span class="w">    </span><span class="n">MyGroup</span><span class="p">,</span><span class="w"> </span><span class="n">MyTestSuite</span><span class="p">,</span>
<span class="w">    </span><span class="n">testing</span><span class="o">::</span><span class="n">Combine</span><span class="p">(</span>
<span class="w">        </span><span class="n">testing</span><span class="o">::</span><span class="n">Values</span><span class="p">(</span><span class="n">MyType</span><span class="o">::</span><span class="n">MY_FOO</span><span class="p">,</span><span class="w"> </span><span class="n">MyType</span><span class="o">::</span><span class="n">MY_BAR</span><span class="p">),</span>
<span class="w">        </span><span class="n">testing</span><span class="o">::</span><span class="n">Values</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">)),</span>
<span class="w">    </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestParamInfo</span><span class="o">&lt;</span><span class="n">MyTestSuite</span><span class="o">::</span><span class="n">ParamType</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(</span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MyType</span><span class="o">::</span><span class="n">MY_FOO</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;Foo&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Bar&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">param</span><span class="p">));</span>
<span class="w">      </span><span class="n">absl</span><span class="o">::</span><span class="n">c_replace_if</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">isalnum</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="sc">&#39;_&#39;</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
</pre></div>
</div>
</section>
</section>
<section id="typed-tests">
<h3>Test Tipizzati<a class="headerlink" href="#typed-tests" title="Link to this heading">¶</a></h3>
<p>Supponiamo di avere più implementazioni della stessa interfaccia e di voler assicurarci che tutte soddisfino alcuni requisiti comuni. Oppure si potrebbero aver definito diversi tipi che dovrebbero essere conformi allo stesso «concept» e si desidera verificarlo. In entrambi i casi, si desidera che la stessa logica di test venga ripetuta per tipi diversi.</p>
<p>Anche se si può scrivere un <code class="docutils literal notranslate"><span class="pre">TEST</span></code> o <code class="docutils literal notranslate"><span class="pre">TEST_F</span></code> per ogni tipo da testare (e si potrebbe anche fattorizzare la logica del test in una funzione template invocata da <code class="docutils literal notranslate"><span class="pre">TEST</span></code>), è noioso e non scalabile: se si vuole che <code class="docutils literal notranslate"><span class="pre">m</span></code> test su <code class="docutils literal notranslate"><span class="pre">n</span></code> tipi, si finirà per scrivere <code class="docutils literal notranslate"><span class="pre">m*n</span></code> <code class="docutils literal notranslate"><span class="pre">TEST</span></code>.</p>
<p>I <em>Test tipizzati</em> consentono di ripetere la stessa logica del test su un elenco di tipi. È necessario scrivere la logica del test solo una volta, anche se è necessario conoscere l’elenco dei tipi quando si scrivono test tipizzati. Ecco come farlo:</p>
<p>Innanzitutto, si definisce una classe fixture template. Dovrebbe essere parametrizzata da un tipo. Ricordarsi di derivarlo da <code class="docutils literal notranslate"><span class="pre">::testing::Test</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">shared_</span><span class="p">;</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Poi, si associa un elenco di tipi alla test suite, che verrà ripetuto per ogni tipo nell’elenco:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">MyTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Types</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">TYPED_TEST_SUITE</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">MyTypes</span><span class="p">);</span>
</pre></div>
</div>
<p>L’alias del tipo (<code class="docutils literal notranslate"><span class="pre">using</span></code> o <code class="docutils literal notranslate"><span class="pre">typedef</span></code>) è necessario affinché la macro <code class="docutils literal notranslate"><span class="pre">TYPED_TEST_SUITE</span></code> lo possa analizzare correttamente. Altrimenti il compilatore penserà che ogni virgola nell’elenco dei tipi introduca un nuovo argomento della macro.</p>
<p>Poi, si usa <code class="docutils literal notranslate"><span class="pre">TYPED_TEST()</span></code> invece di <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code> per definire un test tipizzato per questa test suite. Lo si può ripetere più volte:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TYPED_TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesBlah</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Inside a test, refer to the special name TypeParam to get the type</span>
<span class="w">  </span><span class="c1">// parameter.  Since we are inside a derived class template, C++ requires</span>
<span class="w">  </span><span class="c1">// us to visit the members of FooTest via &#39;this&#39;.</span>
<span class="w">  </span><span class="n">TypeParam</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">value_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// To visit static members of the fixture, add the &#39;TestFixture::&#39;</span>
<span class="w">  </span><span class="c1">// prefix.</span>
<span class="w">  </span><span class="n">n</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">TestFixture</span><span class="o">::</span><span class="n">shared_</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// To refer to typedefs in the fixture, add the &#39;typename TestFixture::&#39;</span>
<span class="w">  </span><span class="c1">// prefix.  The &#39;typename&#39; is required to satisfy the compiler.</span>
<span class="w">  </span><span class="k">typename</span><span class="w"> </span><span class="nc">TestFixture</span><span class="o">::</span><span class="n">List</span><span class="w"> </span><span class="n">values</span><span class="p">;</span>

<span class="w">  </span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">TYPED_TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">HasPropertyA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Si può vedere [sample6_unittest.cc] per un esempio completo.</p>
</section>
<section id="type-parameterized-tests">
<h3>Test con i Tipi Parametrizzati<a class="headerlink" href="#type-parameterized-tests" title="Link to this heading">¶</a></h3>
<p>I <em>Type-parameterized tests</em> sono come quelli tipizzati, tranne per il fatto che non richiedono che si conosca in anticipo l’elenco dei tipi. È invece possibile definire prima la logica del test e istanziarla successivamente con elenchi di tipi diversi. Si può anche crearne un’istanza più di una volta nello stesso programma.</p>
<p>Se si sta progettando un’interfaccia o un concetto, si può definire una suite di test con i tipi parametrizzati per verificare le proprietà che dovrebbe avere qualsiasi implementazione valida dell’interfaccia/concetto. Quindi, l’autore di ciascuna implementazione può semplicemente istanziare la test suite con il proprio tipo per verificare che sia conforme ai requisiti, senza dover scrivere ripetutamente test simili. Ecco un esempio:</p>
<p>Innanzitutto, definisce una classe fixture template, come abbiamo fatto con i test tipizzati:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">DoSomethingInteresting</span><span class="p">();</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Successivamente, si dichiara che si definirà una test suite con tipi parametrizzati:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TYPED_TEST_SUITE_P</span><span class="p">(</span><span class="n">FooTest</span><span class="p">);</span>
</pre></div>
</div>
<p>Poi, si usa <code class="docutils literal notranslate"><span class="pre">TYPED_TEST_P()</span></code> per definire un test con un tipo parametrizzato. Lo si può ripetere più volte:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TYPED_TEST_P</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesBlah</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Inside a test, refer to TypeParam to get the type parameter.</span>
<span class="w">  </span><span class="n">TypeParam</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// You will need to use `this` explicitly to refer to fixture members.</span>
<span class="w">  </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">DoSomethingInteresting</span><span class="p">()</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">TYPED_TEST_P</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">HasPropertyA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Ora la parte difficile: si devono registrare tutti i pattern dei test utilizzando la macro <code class="docutils literal notranslate"><span class="pre">REGISTER_TYPED_TEST_SUITE_P</span></code> prima di poterli istanziare. Il primo argomento della macro è il nome della test suite; il resto sono i nomi dei test in questa test suite:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">REGISTER_TYPED_TEST_SUITE_P</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span>
<span class="w">                            </span><span class="n">DoesBlah</span><span class="p">,</span><span class="w"> </span><span class="n">HasPropertyA</span><span class="p">);</span>
</pre></div>
</div>
<p>Infine, si può istanziare il pattern con i tipi desiderati. Se si inserisce il codice precedente in un file header, si può <code class="docutils literal notranslate"><span class="pre">#include</span></code>-rlo in più sorgenti C++e istanziarlo più volte.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">MyTypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Types</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">INSTANTIATE_TYPED_TEST_SUITE_P</span><span class="p">(</span><span class="n">My</span><span class="p">,</span><span class="w"> </span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">MyTypes</span><span class="p">);</span>
</pre></div>
</div>
<p>Per distinguere le diverse istanze del pattern, il primo argomento della macro <code class="docutils literal notranslate"><span class="pre">INSTANTIATE_TYPED_TEST_SUITE_P</span></code> è un prefisso che verrà anteposto al nome effettivo della test suite. Ricordarsi di scegliere prefissi univoci per istanze diverse.</p>
<p>Nel caso speciale in cui l’elenco dei tipi contiene solo un tipo, lo si può scrivere direttamente senza <code class="docutils literal notranslate"><span class="pre">::testing::Types&lt;...&gt;</span></code>, in questo modo:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">INSTANTIATE_TYPED_TEST_SUITE_P</span><span class="p">(</span><span class="n">My</span><span class="p">,</span><span class="w"> </span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<p>Si può vedere [sample6_unittest.cc] per un esempio completo.</p>
</section>
<section id="testing-private-code">
<h3>Test di Codice Privato<a class="headerlink" href="#testing-private-code" title="Link to this heading">¶</a></h3>
<p>Se si modifica l’implementazione interna del software, i test non dovrebbero smettere di funzionare fin quando la modifica non è osservabile dagli utenti. Pertanto, <strong>secondo il principio del test della black-box, la maggior parte delle volte si deve testare il codice tramite le sue interfacce pubbliche</strong>.</p>
<p><strong>Se ci si ritrova ancora a dover testare il codice dell’implementazione interna, considerare se esiste un design migliore</strong>. Il desiderio di testare l’implementazione interna è spesso un segno che la classe sta facendo troppo. Si prenda in considerazione l’estrazione di una classe di implementazione e la si testi. Poi si usa quella classe di implementazione nella classe originale.</p>
<p>Se si deve assolutamente testare il codice dell’interfaccia non pubblica, lo si può fare. Ci sono due casi da considerare:</p>
<ul class="simple">
<li><p>Le funzioni statiche (<em>non</em> è lo stesso delle funzioni membro statiche!) o i namespace anonimi, e</p></li>
<li><p>I membri di classe privati o protetti</p></li>
</ul>
<p>Per testarli, utilizziamo le seguenti tecniche speciali:</p>
<ul class="simple">
<li><p>Sia le funzioni statiche che le definizioni/dichiarazioni in un namespace anonimo sono visibili solo all’interno della stessa unità di traduzione. To test them, move the private code into the <code class="docutils literal notranslate"><span class="pre">foo::internal</span></code> namespace, where <code class="docutils literal notranslate"><span class="pre">foo</span></code> is the namespace your project normally uses, and put the private declarations in a <code class="docutils literal notranslate"><span class="pre">*-internal.h</span></code> file. I file <code class="docutils literal notranslate"><span class="pre">.cc</span></code> di produzione e i test possono includere questo header interno, ma i non i clienti. In questo modo, si può testare completamente l’implementazione interna senza divulgarla ai clienti.</p></li>
</ul>
<p>{: .callout .note}
NOTE: It is also technically <em>possible</em> to <code class="docutils literal notranslate"><span class="pre">#include</span></code> the entire <code class="docutils literal notranslate"><span class="pre">.cc</span></code> file
being tested in your <code class="docutils literal notranslate"><span class="pre">*_test.cc</span></code> file to test static functions and
definitions/declarations in an unnamed namespace. However, this technique is
<strong>not recommended</strong> by this documentation and it is only presented here for the
sake of completeness.</p>
<ul>
<li><p>I membri della classe privata sono accessibili solo dall’interno della classe o dai friend. Per accedere ai membri privati di una classe, si può dichiarare la fixture come friend della classe e definire come accedere nella fixture. I test che utilizzano la fixture possono poi accedere ai membri privati della classe di produzione tramite gli accessori nella fixture. Notare che anche se la fixture è friend della classe di produzione, i test non lo sono automaticamente, poiché sono tecnicamente definiti in sottoclassi della fixture.</p>
<p>Un altro modo per testare i membri privati è quello di rifattorizzarli in una classe di implementazione, che viene poi dichiarata in un file <code class="docutils literal notranslate"><span class="pre">*-internal.h</span></code> file. I clienti non sono autorizzati a includere questo header, ma i test sì.</p>
<p>Oppure si può dichiarare un test individuale come friend della classe aggiungendo questa riga nel corpo della classe:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">FRIEND_TEST</span><span class="p">(</span><span class="n">TestSuiteName</span><span class="p">,</span><span class="w"> </span><span class="n">TestName</span><span class="p">);</span>
</pre></div>
</div>
<p>Per esempio,</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">FRIEND_TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">BarReturnsZeroOnNull</span><span class="p">);</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="nf">Bar</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// foo_test.cc</span>
<span class="p">...</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">BarReturnsZeroOnNull</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">Bar</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// Uses Foo&#39;s private member Bar().</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Prestare particolare attenzione quando la classe è definita in un namespace. Se si vuole che le fixture e i test siano friend della classe, allora devono essere definiti esattamente nello stesso namespace (nessun namespace anonimo o inline).</p>
<p>Ad esempio, se il codice da testare è simile a:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">my_namespace</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="p">;</span>
<span class="w">  </span><span class="n">FRIEND_TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">);</span>
<span class="w">  </span><span class="n">FRIEND_TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Baz</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">definition</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">...</span>
<span class="p">};</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace my_namespace</span>
</pre></div>
</div>
<p>Il codice del test dovrebbe essere qualcosa del tipo:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">my_namespace</span><span class="w"> </span><span class="p">{</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Baz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="p">}</span><span class="w">  </span><span class="c1">// namespace my_namespace</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="catching-failures">
<h3>«Catching» degli Errori<a class="headerlink" href="#catching-failures" title="Link to this heading">¶</a></h3>
<p>Se si crea un’utilità di test al di sopra di GoogleTest, la si deve testare. Quale framework si userebbe per testarla? GoogleTest, ovviamente.</p>
<p>La sfida consiste nel verificare che l’utilità di test riporti correttamente gli errori. Nei framework che riportano un errore lanciando un’eccezione, si potrebbe catturare l’eccezione e metterci un assert. Ma GoogleTest non utilizza eccezioni, quindi come possiamo verificare che una parte di codice generi un errore previsto?</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;gtest/gtest-spi.h&quot;</span></code> contiene alcuni costrutti per farlo. Dopo lo #include di questo header, si può usare</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_FATAL_FAILURE</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span><span class="w"> </span><span class="n">substring</span><span class="p">);</span>
</pre></div>
</div>
<p>per asserire che <code class="docutils literal notranslate"><span class="pre">statement</span></code> genera un errore fatale (ad esempio <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code>) nel thread corrente il cui messaggio contiene la <code class="docutils literal notranslate"><span class="pre">substring</span></code>, oppure si usa</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_NONFATAL_FAILURE</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span><span class="w"> </span><span class="n">substring</span><span class="p">);</span>
</pre></div>
</div>
<p>se ci si aspetta un errore non fatale (per es. <code class="docutils literal notranslate"><span class="pre">EXPECT_*</span></code>).</p>
<p>Vengono controllati solo gli errori nel thread corrente per determinare il risultato di questo tipo di aspettative. Se <code class="docutils literal notranslate"><span class="pre">statement</span></code> crea nuovi thread, anche gli errori in questi thread vengono ignorati. Per rilevare errori anche in altri thread, si utilizza invece una delle seguenti macro:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_FATAL_FAILURE_ON_ALL_THREADS</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span><span class="w"> </span><span class="n">substring</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span><span class="w"> </span><span class="n">substring</span><span class="p">);</span>
</pre></div>
</div>
<p>{: .callout .note} NOTA: Le asserzioni provenienti da più thread non sono attualmente supportate su Windows.</p>
<p>Per ragioni tecniche, ci sono alcune avvertenze:</p>
<ol class="arabic simple">
<li><p>Non è possibile accodare a uno stream un messaggio di errore a nessuna delle macro.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">statement</span></code> in <code class="docutils literal notranslate"><span class="pre">EXPECT_FATAL_FAILURE{_ON_ALL_THREADS}()</span></code> non può fare riferimento a variabili locali non statiche o a membri non statici dell’oggetto <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">statement</span></code> in <code class="docutils literal notranslate"><span class="pre">EXPECT_FATAL_FAILURE{_ON_ALL_THREADS}()</span></code> non può restituire un valore.</p></li>
</ol>
</section>
<section id="registering-tests-programmatically">
<h3>Registrazione dei test programmaticamente<a class="headerlink" href="#registering-tests-programmatically" title="Link to this heading">¶</a></h3>
<p>Le macro <code class="docutils literal notranslate"><span class="pre">TEST</span></code> gestiscono la stragrande maggioranza di tutti i casi d’uso, ma ce ne sono alcuni in cui è richiesta la logica di registrazione a runtime. Per questi casi, il framework fornisce <code class="docutils literal notranslate"><span class="pre">::testing::RegisterTest</span></code> che consente ai chiamanti di registrare test arbitrari in modo dinamico.</p>
<p>Questa è un’API avanzata da utilizzare solo quando le macro <code class="docutils literal notranslate"><span class="pre">TEST</span></code> sono insufficienti. Le macro dovrebbero essere preferite quando possibile, poiché evitano gran parte della complessità di chiamare questa funzione.</p>
<p>Fornisce la seguente firma [signature]:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Factory</span><span class="o">&gt;</span>
<span class="n">TestInfo</span><span class="o">*</span><span class="w"> </span><span class="n">RegisterTest</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">test_suite_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">test_name</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">type_param</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">value_param</span><span class="p">,</span>
<span class="w">                       </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="n">Factory</span><span class="w"> </span><span class="n">factory</span><span class="p">);</span>
</pre></div>
</div>
<p>L’argomento <code class="docutils literal notranslate"><span class="pre">factory</span></code> è un oggetto richiamabile da factory (costruibile tramite spostamento) o un puntatore a funzione che crea una nuova istanza dell’oggetto Test. Gestisce la proprietà del chiamante. La firma del richiamabile è <code class="docutils literal notranslate"><span class="pre">Fixture*()</span></code>, dove <code class="docutils literal notranslate"><span class="pre">Fixture</span></code> è la classe fixture per il test. Tutti i test registrati con lo stesso <code class="docutils literal notranslate"><span class="pre">test_suite_name</span></code> devono restituire lo stesso tipo di fixture. Questo viene controllato in fase di esecuzione.</p>
<p>Il framework dedurrà la classe della fixture dalla factory e per questo chiamerà <code class="docutils literal notranslate"><span class="pre">SetUpTestSuite</span></code> e <code class="docutils literal notranslate"><span class="pre">TearDownTestSuite</span></code>.</p>
<p>Deve essere chiamato prima che venga invocato <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>, altrimenti il comportamento non è definito.</p>
<p>Esempio di caso d’uso:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyFixture</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// All of these optional, just like in regular macro usage.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">SetUpTestSuite</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">TearDownTestSuite</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SetUp</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">TearDown</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MyFixture</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">MyTest</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data_</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">TestBody</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">data_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">RegisterMyTests</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">testing</span><span class="o">::</span><span class="n">RegisterTest</span><span class="p">(</span>
<span class="w">        </span><span class="s">&quot;MyFixture&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">v</span><span class="p">)).</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">v</span><span class="p">).</span><span class="n">c_str</span><span class="p">(),</span>
<span class="w">        </span><span class="n">__FILE__</span><span class="p">,</span><span class="w"> </span><span class="n">__LINE__</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// Important to use the fixture type as the return type here.</span>
<span class="w">        </span><span class="p">[</span><span class="o">=</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MyFixture</span><span class="o">*</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyTest</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">testing</span><span class="o">::</span><span class="n">InitGoogleTest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">values_to_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadValuesFromConfig</span><span class="p">();</span>
<span class="w">  </span><span class="n">RegisterMyTests</span><span class="p">(</span><span class="n">values_to_test</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="getting-the-current-test-s-name">
<h3>Recuperare il Nome del Test Corrente<a class="headerlink" href="#getting-the-current-test-s-name" title="Link to this heading">¶</a></h3>
<p>A volte una funzione potrebbe aver bisogno di conoscere il nome del test attualmente in esecuzione. Ad esempio, si potrebbe utilizzare il metodo <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> della fixture per impostare il nome del «golden file» (ndt: Output campione) in base al test in esecuzione. La classe <a class="reference internal" href="#reference/testing.md#TestInfo"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">TestInfo</span></code></span></a> contiene queste informazioni.</p>
<p>Per ottenere un oggetto <code class="docutils literal notranslate"><span class="pre">TestInfo</span></code> per il test attualmente in esecuzione, si chiama <code class="docutils literal notranslate"><span class="pre">current_test_info()</span></code> sull’oggetto singleton <a class="reference internal" href="#reference/testing.md#UnitTest"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">UnitTest</span></code></span></a>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Gets information about the currently running test.</span>
<span class="w">  </span><span class="c1">// Do NOT delete the returned object - it&#39;s managed by the UnitTest class.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestInfo</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">test_info</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">testing</span><span class="o">::</span><span class="n">UnitTest</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">current_test_info</span><span class="p">();</span>

<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;We are in test %s of test suite %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">         </span><span class="n">test_info</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">(),</span>
<span class="w">         </span><span class="n">test_info</span><span class="o">-&gt;</span><span class="n">test_suite_name</span><span class="p">());</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">current_test_info()</span></code> restituisce un puntatore nullo se non è in esecuzione alcun test. In particolare, non è possibile trovare il nome della test suite in <code class="docutils literal notranslate"><span class="pre">SetUpTestSuite()</span></code>, <code class="docutils literal notranslate"><span class="pre">TearDownTestSuite()</span></code> (dove si conosce implicitamente il nome della test suite) né nelle funzioni chiamate da essi.</p>
</section>
<section id="extending-googletest-by-handling-test-events">
<h3>Estendere GoogleTest Gestendo gli Eventi dei Test<a class="headerlink" href="#extending-googletest-by-handling-test-events" title="Link to this heading">¶</a></h3>
<p>GoogleTest fornisce una <strong>event listener API</strong> per ricevere notifiche sull’avanzamento di un programma di test e sugli errori dei test. Gli eventi che si possono rilevare [listen] includono, tra gli altri, l’inizio e la fine del programma di test, di una test suite o di un metodo di test. Questa API è utilizzabile per aumentare o sostituire l’output della console standard, sostituire l’output XML o fornire una forma di output completamente diversa, come una GUI o un database. È inoltre possibile utilizzare gli eventi dei test come checkpoint per implementare, ad esempio, un controllo delle perdite [leak] di risorse.</p>
<section id="defining-event-listeners">
<h4>Definire i Listener degli Eventi<a class="headerlink" href="#defining-event-listeners" title="Link to this heading">¶</a></h4>
<p>Per definire un event listener, si crea una sottoclasse di <a class="reference internal" href="#reference/testing.md#TestEventListener"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">testing::TestEventListener</span></code></span></a> o di <a class="reference internal" href="#reference/testing.md#EmptyTestEventListener"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">testing::EmptyTestEventListener</span></code></span></a>. La prima è un’interfaccia (astratta), in cui <em>ciascun metodo virtuale puro può essere sovrascritto [overridden] per gestire un evento di test</em> (Per esempio, quando inizia un test, verrà chiamato il metodo <code class="docutils literal notranslate"><span class="pre">OnTestStart()</span></code>). L’ultimo fornisce un’implementazione vuota di tutti i metodi nell’interfaccia, in modo tale che una sottoclasse debba solo sovrascrivere i metodi che le interessano.</p>
<p>Quando viene generato un evento, il suo contesto viene passato alla funzione del gestore [handler] come argomento. Vengono utilizzati i seguenti tipi di argomento:</p>
<ul class="simple">
<li><p>UnitTest riflette lo stato dell’intero programma di test,</p></li>
<li><p>TestSuite contiene informazioni su una test suite, che può contenere uno o più test,</p></li>
<li><p>TestInfo contiene lo stato di un test e</p></li>
<li><p>TestPartResult rappresenta il risultato di un’asserzione di un test.</p></li>
</ul>
<p>Una funzione del gestore eventi può esaminare l’argomento che riceve per scoprire informazioni interessanti sull’evento e sullo stato del programma di test.</p>
<p>Ecco un esempio:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">MinimalistPrinter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">EmptyTestEventListener</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Called before a test starts.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnTestStart</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_info</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*** Test %s.%s starting.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="n">test_info</span><span class="p">.</span><span class="n">test_suite_name</span><span class="p">(),</span><span class="w"> </span><span class="n">test_info</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Called after a failed assertion or a SUCCESS().</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnTestPartResult</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestPartResult</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_part_result</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s in %s:%d</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="n">test_part_result</span><span class="p">.</span><span class="n">failed</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;*** Failure&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;Success&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="n">test_part_result</span><span class="p">.</span><span class="n">file_name</span><span class="p">(),</span>
<span class="w">             </span><span class="n">test_part_result</span><span class="p">.</span><span class="n">line_number</span><span class="p">(),</span>
<span class="w">             </span><span class="n">test_part_result</span><span class="p">.</span><span class="n">summary</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Called after a test ends.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">OnTestEnd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">TestInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">test_info</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*** Test %s.%s ending.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">             </span><span class="n">test_info</span><span class="p">.</span><span class="n">test_suite_name</span><span class="p">(),</span><span class="w"> </span><span class="n">test_info</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
</pre></div>
</div>
</section>
<section id="using-event-listeners">
<h4>Utilizzo dei Listener di Eventi<a class="headerlink" href="#using-event-listeners" title="Link to this heading">¶</a></h4>
<p>Per usare l’event listener definito, se ne aggiunge un’istanza alla lista degli event listener di GoogleTest (rappresentata dalla classe <a class="reference internal" href="#reference/testing.md#TestEventListeners"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">TestEventListeners</span></code></span></a> - notare la «s» alla fine del nome) nella funzione <code class="docutils literal notranslate"><span class="pre">main()</span></code>, prima di chiamare <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">testing</span><span class="o">::</span><span class="n">InitGoogleTest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Gets hold of the event listener list.</span>
<span class="w">  </span><span class="n">testing</span><span class="o">::</span><span class="n">TestEventListeners</span><span class="o">&amp;</span><span class="w"> </span><span class="n">listeners</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">testing</span><span class="o">::</span><span class="n">UnitTest</span><span class="o">::</span><span class="n">GetInstance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">listeners</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// Adds a listener to the end.  GoogleTest takes the ownership.</span>
<span class="w">  </span><span class="n">listeners</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">MinimalistPrinter</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C’è solo un problema: la stampante di default dei risultati del test è ancora attiva, quindi il suo output si confonderà con quello della propria stampante minimalista. Per sopprimere la stampante di default , basta rilasciarla dall’elenco del listener di eventi ed eseguirne il delete. Lo si può fare aggiungendo una riga:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="n">listeners</span><span class="p">.</span><span class="n">Release</span><span class="p">(</span><span class="n">listeners</span><span class="p">.</span><span class="n">default_result_printer</span><span class="p">());</span>
<span class="w">  </span><span class="n">listeners</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">MinimalistPrinter</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
</pre></div>
</div>
<p>Ora ci si può rilassare e godersi un risultato completamente diverso dai test. Per ulteriori dettagli, consultare [sample9_unittest.cc].</p>
<p>Si possono aggiungere più listener alla lista. Quando viene attivato un evento <code class="docutils literal notranslate"><span class="pre">On*Start()</span></code> o <code class="docutils literal notranslate"><span class="pre">OnTestPartResult()</span></code>, i listener lo riceveranno nell’ordine in cui appaiono nell’elenco (poiché i nuovi listener vengono aggiunti alla finedelle lista, la stampante del testo e il generatore XML di default riceveranno per primi l’evento). Un evento <code class="docutils literal notranslate"><span class="pre">On*End()</span></code> verrà ricevuto dai listener nell’ordine <em>inverso</em>. Ciò consente all’output dei listener aggiunti successivamente di essere inquadrati [framed] dall’output dei listener aggiunti in precedenza.</p>
</section>
<section id="generating-failures-in-listeners">
<h4>Generare Errori nei Listener<a class="headerlink" href="#generating-failures-in-listeners" title="Link to this heading">¶</a></h4>
<p>Si possono utilizzare macro che generano errori (<code class="docutils literal notranslate"><span class="pre">EXPECT_*()</span></code>, <code class="docutils literal notranslate"><span class="pre">ASSERT_*()</span></code>, <code class="docutils literal notranslate"><span class="pre">FAIL()</span></code>, ecc.) durante l’elaborazione di un evento. Ci sono alcune restrizioni:</p>
<ol class="arabic simple">
<li><p>Non è possibile generare alcun errore in <code class="docutils literal notranslate"><span class="pre">OnTestPartResult()</span></code> (altrimenti si chiamerà ricorsivamente <code class="docutils literal notranslate"><span class="pre">OnTestPartResult()</span></code>).</p></li>
<li><p>Un listener che gestisce <code class="docutils literal notranslate"><span class="pre">OnTestPartResult()</span></code> non può generare alcun errore.</p></li>
</ol>
<p>Quando si aggiungono listener alla lista, si devono inserire i listener che gestiscono <code class="docutils literal notranslate"><span class="pre">OnTestPartResult()</span></code> <em>prima</em> di quelli che generano errori. Ciò garantisce che i fallimenti generati da questi ultimi vengano attribuiti al test corretto da parte dei primi.</p>
<p>Vedere [sample10_unittest.cc] per un esempio di un listener che genera errori.</p>
</section>
</section>
<section id="running-test-programs-advanced-options">
<h3>Esecuzione dei Programmi di Test: Opzioni Avanzate<a class="headerlink" href="#running-test-programs-advanced-options" title="Link to this heading">¶</a></h3>
<p>I programmi di test di GoogleTest sono normali eseguibili. Una volta creati, si possono eseguire direttamente e influenzarne il comportamento tramite le seguenti variabili di ambiente e/o flag della riga di comando. Affinché i flag funzionino, i programmi devono chiamare <code class="docutils literal notranslate"><span class="pre">::testing::InitGoogleTest()</span></code> prima di chiamare <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>.</p>
<p>Per visualizzare un elenco dei flag supportati e il loro utilizzo, eseguire il programma di test con il flag <code class="docutils literal notranslate"><span class="pre">--help</span></code>.</p>
<p>Se un’opzione è specificata sia da una variabile d’ambiente che da un flag, quest’ultimo ha la precedenza.</p>
<section id="selecting-tests">
<h4>Selezione dei Test<a class="headerlink" href="#selecting-tests" title="Link to this heading">¶</a></h4>
<section id="listing-test-names">
<h5>Elenco dei Nomi dei Test<a class="headerlink" href="#listing-test-names" title="Link to this heading">¶</a></h5>
<p>A volte è necessario elencare i test disponibili in un programma prima di eseguirli in modo da poter applicare un filtro, se necessario. L’inclusione del flag <code class="docutils literal notranslate"><span class="pre">--gtest_list_tests</span></code> sovrascrive tutti gli altri flag ed elenca i test nel seguente formato:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>TestSuite1.
  TestName1
  TestName2
TestSuite2.
  TestName
</pre></div>
</div>
<p>Nessuno dei test elencati viene effettivamente eseguito se viene fornito il flag. Non esiste una variabile di ambiente corrispondente per questo flag.</p>
</section>
<section id="running-a-subset-of-the-tests">
<h5>Eseguire un Sottoinsieme dei Test<a class="headerlink" href="#running-a-subset-of-the-tests" title="Link to this heading">¶</a></h5>
<p>Per default, un programma GoogleTest esegue tutti i test definiti dall’utente. A volte, se ne vogliono eseguire solo un sottoinsieme (ad esempio per eseguire il debug o verificare rapidamente una modifica). Se si imposta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_FILTER</span></code> o il flag <code class="docutils literal notranslate"><span class="pre">--gtest_filter</span></code> su una stringa di filtro, GoogleTest eseguirà solo i test i cui nomi completi (nel formato <code class="docutils literal notranslate"><span class="pre">TestSuiteName.TestName</span></code>) corrisponderanno al filtro.</p>
<p>Il formato di un filtro è un elenco di pattern di carattery jolly, separati da “<code class="docutils literal notranslate"><span class="pre">:</span></code>” (detti <em>pattern positivi</em>) seguito facoltativamente da un “<code class="docutils literal notranslate"><span class="pre">-</span></code>” e un altro elenco di pattern separati da “<code class="docutils literal notranslate"><span class="pre">:</span></code>” (detti <em>pattern negativi</em>). Un test corrisponde al filtro se e solo se corrisponde a uno qualsiasi dei pattern positivi ma non corrisponde a nessuno dei pattern negativi.</p>
<p>Un pattern può contenere <code class="docutils literal notranslate"><span class="pre">'*'</span></code> (corrispondente a qualsiasi stringa) o <code class="docutils literal notranslate"><span class="pre">'?'</span></code> (corrispondente a qualsiasi carattere singolo). Per comodità, il filtro <code class="docutils literal notranslate"><span class="pre">'*-NegativePatterns'</span></code> può anche essere scritto come <code class="docutils literal notranslate"><span class="pre">'-NegativePatterns'</span></code>.</p>
<p>Per esempio:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">./foo_test</span></code> Non ha flag e quindi esegue tutti i suoi test.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./foo_test</span> <span class="pre">--gtest_filter=*</span></code> Esegue tutto, a causa del singolo valore <code class="docutils literal notranslate"><span class="pre">*</span></code> corrispondente a tutto.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./foo_test</span> <span class="pre">--gtest_filter=FooTest.*</span></code> Esegue tutto nella test suite <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./foo_test</span> <span class="pre">--gtest_filter=*Null*:*Constructor*</span></code> Esegue qualsiasi test il cui nome completo contenga <code class="docutils literal notranslate"><span class="pre">&quot;Null&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;Constructor&quot;</span></code> .</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./foo_test</span> <span class="pre">--gtest_filter=-*DeathTest.*</span></code> Esegue tutti i test non-death.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./foo_test</span> <span class="pre">--gtest_filter=FooTest.*-FooTest.Bar</span></code> Esegue tutto nella test suite <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> tranne <code class="docutils literal notranslate"><span class="pre">FooTest.Bar</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">./foo_test</span> <span class="pre">--gtest_filter=FooTest.*:BarTest.*-FooTest.Bar:BarTest.Foo</span></code> Esegue tutto nella test suite <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> tranne <code class="docutils literal notranslate"><span class="pre">FooTest.Bar</span></code> e tutto nella test suite <code class="docutils literal notranslate"><span class="pre">BarTest</span></code> tranne <code class="docutils literal notranslate"><span class="pre">BarTest.Foo</span></code>.</p></li>
</ul>
</section>
<section id="stop-test-execution-upon-first-failure">
<h5>Interrompere l’esecuzione del test al primo errore<a class="headerlink" href="#stop-test-execution-upon-first-failure" title="Link to this heading">¶</a></h5>
<p>Per default, un programma GoogleTest esegue tutti i test definiti dall’utente. In alcuni casi (ad esempio sviluppo ed esecuzione iterativi di test) potrebbe essere auspicabile interrompere l’esecuzione del test al primo fallimento (scambiando la maggiore latenza con la completezza). Se la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_FAIL_FAST</span></code> o il flag <code class="docutils literal notranslate"><span class="pre">--gtest_fail_fast</span></code> sono settati, l’esecutore dei test si interromperà non appena viene rilevato il primo errore.</p>
</section>
<section id="temporarily-disabling-tests">
<h5>Disattivazione Temporanea dei Test<a class="headerlink" href="#temporarily-disabling-tests" title="Link to this heading">¶</a></h5>
<p>Se si ha un test non funzionante che non si può correggere subito, si può aggiungere il prefisso <code class="docutils literal notranslate"><span class="pre">DISABLED_</span></code> al nome. Ciò lo escluderà dall’esecuzione. Questo è meglio che commentare il codice o usare <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">0</span></code>, poiché i test disabilitati vengono comunque compilati (e quindi non «marciranno»).</p>
<p>Per disabilitare tutti i test in una test suite, si può aggiungere <code class="docutils literal notranslate"><span class="pre">DISABLED_</span></code> all’inizio del nome di ciascun test o in alternativa aggiungerlo all’inizio del nome della test suite.</p>
<p>Ad esempio, i seguenti test non verranno eseguiti da GoogleTest, anche se verranno comunque compilati:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Tests that Foo does Abc.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">DISABLED_DoesAbc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DISABLED_BarTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Tests that Bar does Xyz.</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">DISABLED_BarTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesXyz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>{: .callout .note} NOTA: Questa funzione deve essere utilizzata solo come soluzione temporanea. Resta ancora correggere i test disabilitati in un secondo momento. Come promemoria, GoogleTest stamperà un banner che avvisa se un programma di test contiene test disabilitati.</p>
<p>{: .callout .tip} TIP: Si può facilmente contare il numero di test disabilitati con <code class="docutils literal notranslate"><span class="pre">grep</span></code>. Questo numero può essere utilizzato come parametro per migliorare la qualità del test.</p>
</section>
<section id="temporarily-enabling-disabled-tests">
<h5>Abilitazione Temporanea dei Test Disabilitati<a class="headerlink" href="#temporarily-enabling-disabled-tests" title="Link to this heading">¶</a></h5>
<p>Per includere test disabilitati nell’esecuzione del test, è sufficiente richiamare il programma di test con il flag <code class="docutils literal notranslate"><span class="pre">--gtest_also_run_disabled_tests</span></code> o impostare la variabile d’ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_ALSO_RUN_DISABLED_TESTS</span></code> su un valore diverso da <code class="docutils literal notranslate"><span class="pre">0</span></code>. Lo si può combinare col flag <code class="docutils literal notranslate"><span class="pre">--gtest_filter</span></code> per selezionare ulteriormente quali test disabilitati eseguire.</p>
</section>
</section>
<section id="enforcing-having-at-least-one-test-case">
<h4>Enforcing Having At Least One Test Case<a class="headerlink" href="#enforcing-having-at-least-one-test-case" title="Link to this heading">¶</a></h4>
<p>A not uncommon programmer mistake is to write a test program that has no test
case linked in. This can happen, for example, when you put test case definitions
in a library and the library is not marked as «always link».</p>
<p>To catch such mistakes, run the test program with the
<code class="docutils literal notranslate"><span class="pre">--gtest_fail_if_no_test_linked</span></code> flag or set the <code class="docutils literal notranslate"><span class="pre">GTEST_FAIL_IF_NO_TEST_LINKED</span></code>
environment variable to a value other than <code class="docutils literal notranslate"><span class="pre">0</span></code>. Now the program will fail if no
test case is linked in.</p>
<p>Note that <em>any</em> test case linked in makes the program valid for the purpose of
this check. In particular, even a disabled test case suffices.</p>
</section>
<section id="enforcing-running-at-least-one-test-case">
<h4>Enforcing Running At Least One Test Case<a class="headerlink" href="#enforcing-running-at-least-one-test-case" title="Link to this heading">¶</a></h4>
<p>In addition to enforcing that tests are defined in the binary with
<code class="docutils literal notranslate"><span class="pre">--gtest_fail_if_no_test_linked</span></code>, it is also possible to enforce that a test
case was actually executed to ensure that resources are not consumed by tests
that do nothing.</p>
<p>To catch such optimization opportunities, run the test program with the
<code class="docutils literal notranslate"><span class="pre">--gtest_fail_if_no_test_selected</span></code> flag or set the
<code class="docutils literal notranslate"><span class="pre">GTEST_FAIL_IF_NO_TEST_SELECTED</span></code> environment variable to a value other than <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>A test is considered selected if it begins to run, even if it is later skipped
via <code class="docutils literal notranslate"><span class="pre">GTEST_SKIP</span></code>. Thus, <code class="docutils literal notranslate"><span class="pre">DISABLED</span></code> tests do not count as selected and neither do
tests that are not matched by <code class="docutils literal notranslate"><span class="pre">--gtest_filter</span></code>.</p>
</section>
<section id="repeating-the-tests">
<h4>Ripetizione dei Test<a class="headerlink" href="#repeating-the-tests" title="Link to this heading">¶</a></h4>
<p>Di tanto in tanto ci si imbatterà in un test il cui risultato è incostante. Forse fallirà solo l’1% delle volte, rendendo piuttosto difficile riprodurre il bug in un debugger. Questa può essere uno dei principali motivi di frustrazione.</p>
<p>Il flag <code class="docutils literal notranslate"><span class="pre">--gtest_repeat</span></code> consente di ripetere più volte tutti i metodi di test (o quelli selezionati) in un programma. Si spera che un test instabile alla fine fallisca e dia la possibilità di eseguire il debug. Ecco come usarlo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ foo_test --gtest_repeat=1000
Repeat foo_test 1000 times and don&#39;t stop at failures.

$ foo_test --gtest_repeat=-1
A negative count means repeating forever.

$ foo_test --gtest_repeat=1000 --gtest_break_on_failure
Repeat foo_test 1000 times, stopping at the first failure.  This
is especially useful when running under a debugger: when the test
fails, it will drop into the debugger and you can then inspect
variables and stacks.

$ foo_test --gtest_repeat=1000 --gtest_filter=FooBar.*
Repeat the tests whose name matches the filter 1000 times.
</pre></div>
</div>
<p>Se il programma di test contiene codice <a class="reference internal" href="#global-set-up-and-tear-down">set-up/tear-down globale</a>, verrà ripetuto anche in ogni iterazione, poiché potrebbe esserci qualche instabilità. Per evitare di ripetere il set-up/tear-down globale, si specifica <code class="docutils literal notranslate"><span class="pre">--gtest_recreate_environments_when_repeating=false</span></code>{.nowrap}.</p>
<p>Si può anche specificare il numero di ripetizioni impostando la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_REPEAT</span></code>.</p>
</section>
<section id="shuffling-the-tests">
<h4>Mischiare i Test<a class="headerlink" href="#shuffling-the-tests" title="Link to this heading">¶</a></h4>
<p>Si può specificare il flag <code class="docutils literal notranslate"><span class="pre">--gtest_shuffle</span></code> (o impostare la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_SHUFFLE</span></code> a <code class="docutils literal notranslate"><span class="pre">1</span></code>) per eseguire i test in un programma in ordine casuale. Questo aiuta a rivelare delle cattive dipendenze tra i test.</p>
<p>Per default, GoogleTest utilizza un seme casuale calcolato dall’ora corrente. Pertanto si riceverà ogni volta un ordine diverso. L’output della console include il valore di inizializzazione casuale, in modo da poter riprodurre successivamente un errore relativo all’ordine. Per specificare esplicitamente il seed casuale, si usa il flag <code class="docutils literal notranslate"><span class="pre">--gtest_random_seed=SEED</span></code> (o si imposta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_RANDOM_SEED</span></code>), dove <code class="docutils literal notranslate"><span class="pre">SEED</span></code> è un numero intero nell’intervallo [0, 99999]. Il valore seed 0 è speciale: indica a GoogleTest di eseguire il comportamento di default di calcolare il seed dall’ora corrente.</p>
<p>Combinandolo con <code class="docutils literal notranslate"><span class="pre">--gtest_repeat=N</span></code>, GoogleTest selezionerà un seme casuale diverso e rimischierà i test in ogni iterazione.</p>
</section>
<section id="distributing-test-functions-to-multiple-machines">
<h4>Distribuire le Funzioni di Test su Più Macchine<a class="headerlink" href="#distributing-test-functions-to-multiple-machines" title="Link to this heading">¶</a></h4>
<p>Disponendo di più di macchine su cui eseguire un programma di test, si potrebbero eseguire le funzioni di test in parallelo e ottenere il risultato più velocemente. Chiamiamo questa tecnica <em>sharding</em>, dove ogni macchina è chiamata <em>shard</em>.</p>
<p>GoogleTest è compatibile con lo sharding dei test. Per sfruttare questa funzione, il test runner (non parte di GoogleTest) deve effettuare le seguenti operazioni:</p>
<ol class="arabic simple">
<li><p>Allocare un certo numero di macchine (shard) per eseguire i test.</p></li>
<li><p>Su ogni shard, si imposta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_TOTAL_SHARDS</span></code> sul numero totale di shard. Deve essere lo stesso per tutti gli shard.</p></li>
<li><p>Su ogni shard, si imposta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_SHARD_INDEX</span></code> sull’indice dello shard. A shard diversi devono essere assegnati indici diversi, che devono essere compresi nell’intervallo <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">GTEST_TOTAL_SHARDS</span> <span class="pre">-</span> <span class="pre">1]</span></code>.</p></li>
<li><p>Eseguire lo stesso programma di test su tutti gli shard. Quando GoogleTest vede le due variabili di ambiente precedenti, selezionerà un sottoinsieme delle funzioni di test da eseguire. In tutti gli shard, ciascuna funzione di test nel programma verrà eseguita esattamente una volta.</p></li>
<li><p>Attendi che tutti gli shard finiscano, quindi raccogliere e riportare i risultati.</p></li>
</ol>
<p>Il progetto potrebbe contenere test scritti senza GoogleTest e quindi non capire questo protocollo. Affinché il test runner possa capire quale test supporta lo sharding, può impostare la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_SHARD_STATUS_FILE</span></code> su un path di un file inesistente. Se un programma di test supporta lo sharding, creerà questo file per riconoscere questo fatto; altrimenti non lo creerà. Il contenuto effettivo del file non è importante al momento, anche se potremmo inserirvi alcune informazioni utili in futuro.</p>
<p>Ecco un esempio per chiarire. Supponiamo di avere un programma di test <code class="docutils literal notranslate"><span class="pre">foo_test</span></code> che contiene le seguenti 5 funzioni di test:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
</pre></div>
</div>
<p>Supponiamo di avere 3 macchine a nostra disposizione. Per eseguire le funzioni di test in parallelo, si imposta <code class="docutils literal notranslate"><span class="pre">GTEST_TOTAL_SHARDS</span></code> a 3 su tutte le macchine, e si setta <code class="docutils literal notranslate"><span class="pre">GTEST_SHARD_INDEX</span></code> a 0, 1, e 2 sulle macchine rispettivamente. Poi si esegue lo stesso <code class="docutils literal notranslate"><span class="pre">foo_test</span></code> su ciascuna macchina.</p>
<p>GoogleTest si riserva il diritto di modificare la modalità di distribuzione del lavoro tra gli shard, ma ecco uno scenario possibile:</p>
<ul class="simple">
<li><p>La macchina #0 esegue <code class="docutils literal notranslate"><span class="pre">A.V</span></code> e <code class="docutils literal notranslate"><span class="pre">B.X</span></code>.</p></li>
<li><p>La macchina #1 esegue <code class="docutils literal notranslate"><span class="pre">A.W</span></code> e <code class="docutils literal notranslate"><span class="pre">B.Y</span></code>.</p></li>
<li><p>La macchina #2 esegue <code class="docutils literal notranslate"><span class="pre">B.Z</span></code>.</p></li>
</ul>
</section>
<section id="controlling-test-output">
<h4>Controllo dell’Output del Test<a class="headerlink" href="#controlling-test-output" title="Link to this heading">¶</a></h4>
<section id="colored-terminal-output">
<h5>Output Colorato del Terminale<a class="headerlink" href="#colored-terminal-output" title="Link to this heading">¶</a></h5>
<p>GoogleTest può utilizzare i colori nell’output del terminale per facilitare l’individuazione delle informazioni importanti:</p>
<pre>...
<font color="green">[----------]</font> 1 test from FooTest
<font color="green">[ RUN      ]</font> FooTest.DoesAbc
<font color="green">[       OK ]</font> FooTest.DoesAbc
<font color="green">[----------]</font> 2 tests from BarTest
<font color="green">[ RUN      ]</font> BarTest.HasXyzProperty
<font color="green">[       OK ]</font> BarTest.HasXyzProperty
<font color="green">[ RUN      ]</font> BarTest.ReturnsTrueOnSuccess
... some error messages ...
<font color="red">[   FAILED ]</font> BarTest.ReturnsTrueOnSuccess
...
<font color="green">[==========]</font> 30 tests from 14 test suites ran.
<font color="green">[   PASSED ]</font> 28 tests.
<font color="red">[   FAILED ]</font> 2 tests, listed below:
<font color="red">[   FAILED ]</font> BarTest.ReturnsTrueOnSuccess
<font color="red">[   FAILED ]</font> AnotherTest.DoesXyz

 2 FAILED TESTS
</pre>
<p>Si può impostare la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_COLOR</span></code> o il flag della riga di comando <code class="docutils literal notranslate"><span class="pre">--gtest_color</span></code> a <code class="docutils literal notranslate"><span class="pre">yes</span></code>, <code class="docutils literal notranslate"><span class="pre">no</span></code> o <code class="docutils literal notranslate"><span class="pre">auto</span></code> (il default) per abilitare i colori, disabilitarli o lasciare che sia GoogleTest a decidere. Quando il valore è <code class="docutils literal notranslate"><span class="pre">auto</span></code>, GoogleTest utilizzerà i colori se e solo se l’output arriva a un terminale e (su piattaforme non Windows) la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">TERM</span></code> è settata a <code class="docutils literal notranslate"><span class="pre">xterm</span></code> o a <code class="docutils literal notranslate"><span class="pre">xterm-color</span></code>.</p>
</section>
<section id="suppressing-test-passes">
<h5>Sopprimere i test superati<a class="headerlink" href="#suppressing-test-passes" title="Link to this heading">¶</a></h5>
<p>Per default, GoogleTest stampa 1 riga di output per ogni test, indicando se è stato superato o meno. Per mostrare solo i test falliti, eseguire il programma di test con <code class="docutils literal notranslate"><span class="pre">--gtest_brief=1</span></code>, o impostare la variabile di ambiente GTEST_BRIEF a <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</section>
<section id="suppressing-the-elapsed-time">
<h5>Sopprimere il Tempo Trascorso<a class="headerlink" href="#suppressing-the-elapsed-time" title="Link to this heading">¶</a></h5>
<p>Per default, GoogleTest stampa il tempo necessario per eseguire ciascun test. Per disabilitarlo, si esegue il programma di test con il flag della riga di comando <code class="docutils literal notranslate"><span class="pre">--gtest_print_time=0</span></code> o si setta la variabile di ambiente GTEST_PRINT_TIME a <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</section>
<section id="suppressing-utf-8-text-output">
<h5>Sopprimere l’Output di Testo UTF-8<a class="headerlink" href="#suppressing-utf-8-text-output" title="Link to this heading">¶</a></h5>
<p>In caso di errori di asserzione, GoogleTest stampa i valori previsti ed effettivi di tipo <code class="docutils literal notranslate"><span class="pre">string</span></code> sia come stringhe con codifica esadecimale sia come testo UTF-8 leggibile se contengono caratteri UTF-8 non ASCII validi. Per sopprimere il testo UTF-8 perché, ad esempio, non si dispone di un supporto di output compatibile con UTF-8, si esegue il programma di test con <code class="docutils literal notranslate"><span class="pre">--gtest_print_utf8=0</span></code> o si setta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_PRINT_UTF8</span></code> con <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</section>
<section id="generating-an-xml-report">
<h5>Generare un Report XML<a class="headerlink" href="#generating-an-xml-report" title="Link to this heading">¶</a></h5>
<p>GoogleTest può emettere un report XML dettagliato in un file, oltre al normale output testuale. Il report contiene la durata di ciascun test e quindi può aiutare a identificare i test lenti.</p>
<p>Per generare il report XML, si imposta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_OUTPUT</span></code> o il flag <code class="docutils literal notranslate"><span class="pre">--gtest_output</span></code> con la stringa <code class="docutils literal notranslate"><span class="pre">&quot;xml:path_to_output_file&quot;</span></code>, che creerà il file nella posizione specificata. Si può anche utilizzare semplicemente la stringa <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code>, nel qual caso l’output si trova nel file <code class="docutils literal notranslate"><span class="pre">test_detail.xml</span></code> nella directory corrente.</p>
<p>Specificando una directory (per esempio, <code class="docutils literal notranslate"><span class="pre">&quot;xml:output/directory/&quot;</span></code> su Linux o <code class="docutils literal notranslate"><span class="pre">&quot;xml:output\directory\&quot;</span></code> su Windows), GoogleTest creerà il file XML in tale directory, che prende il nome dall’eseguibile del test (ad esempio <code class="docutils literal notranslate"><span class="pre">foo_test.xml</span></code> per il programma di test <code class="docutils literal notranslate"><span class="pre">foo_test</span></code> o <code class="docutils literal notranslate"><span class="pre">foo_test.exe</span></code>). Se il file esiste già (magari rimasto da un’esecuzione precedente), GoogleTest sceglierà un nome diverso (ad esempio <code class="docutils literal notranslate"><span class="pre">foo_test_1.xml</span></code>) per evitare di sovrascriverlo.</p>
<p>Il report si basa sul task Ant <code class="docutils literal notranslate"><span class="pre">junitreport</span></code>. Poiché tale formato era originariamente previsto per Java, è necessaria una piccola interpretazione per applicarlo ai test di GoogleTest, come mostrato qui:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;testsuites</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;AllTests&quot;</span><span class="w"> </span><span class="err">...</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;testsuite</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;test_case_name&quot;</span><span class="w"> </span><span class="err">...</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;testcase</span><span class="w">    </span><span class="na">name=</span><span class="s">&quot;test_name&quot;</span><span class="w"> </span><span class="err">...</span><span class="nt">&gt;</span>
<span class="w">      </span><span class="nt">&lt;failure</span><span class="w"> </span><span class="na">message=</span><span class="s">&quot;...&quot;</span><span class="nt">/&gt;</span>
<span class="w">      </span><span class="nt">&lt;failure</span><span class="w"> </span><span class="na">message=</span><span class="s">&quot;...&quot;</span><span class="nt">/&gt;</span>
<span class="w">      </span><span class="nt">&lt;failure</span><span class="w"> </span><span class="na">message=</span><span class="s">&quot;...&quot;</span><span class="nt">/&gt;</span>
<span class="w">    </span><span class="nt">&lt;/testcase&gt;</span>
<span class="w">  </span><span class="nt">&lt;/testsuite&gt;</span>
<span class="nt">&lt;/testsuites&gt;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>L’elemento root <code class="docutils literal notranslate"><span class="pre">&lt;testsuites&gt;</span></code> corrisponde all’intero programma di test.</p></li>
<li><p>Gli elementi <code class="docutils literal notranslate"><span class="pre">&lt;testsuite&gt;</span></code> corrispondono alle test suite di GoogleTest.</p></li>
<li><p>Gli elementi <code class="docutils literal notranslate"><span class="pre">&lt;testcase&gt;</span></code> corrispondono alle funzioni di test di GoogleTest.</p></li>
</ul>
<p>Ad esempio, il seguente programma</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">MathTest</span><span class="p">,</span><span class="w"> </span><span class="n">Addition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">MathTest</span><span class="p">,</span><span class="w"> </span><span class="n">Subtraction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">LogicTest</span><span class="p">,</span><span class="w"> </span><span class="n">NonContradiction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>potrebbe generare questo report:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;testsuites</span><span class="w"> </span><span class="na">tests=</span><span class="s">&quot;3&quot;</span><span class="w"> </span><span class="na">failures=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">errors=</span><span class="s">&quot;0&quot;</span><span class="w"> </span><span class="na">time=</span><span class="s">&quot;0.035&quot;</span><span class="w"> </span><span class="na">timestamp=</span><span class="s">&quot;2011-10-31T18:52:42&quot;</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;AllTests&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span><span class="nt">&lt;testsuite</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;MathTest&quot;</span><span class="w"> </span><span class="na">tests=</span><span class="s">&quot;2&quot;</span><span class="w"> </span><span class="na">failures=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">errors=</span><span class="s">&quot;0&quot;</span><span class="w"> </span><span class="na">time=</span><span class="s">&quot;0.015&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;testcase</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Addition&quot;</span><span class="w"> </span><span class="na">file=</span><span class="s">&quot;test.cpp&quot;</span><span class="w"> </span><span class="na">line=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">status=</span><span class="s">&quot;run&quot;</span><span class="w"> </span><span class="na">time=</span><span class="s">&quot;0.007&quot;</span><span class="w"> </span><span class="na">classname=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>
<span class="w">      </span><span class="nt">&lt;failure</span><span class="w"> </span><span class="na">message=</span><span class="s">&quot;Value of: add(1, 1)&amp;#x0A;  Actual: 3&amp;#x0A;Expected: 2&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>...<span class="nt">&lt;/failure&gt;</span>
<span class="w">      </span><span class="nt">&lt;failure</span><span class="w"> </span><span class="na">message=</span><span class="s">&quot;Value of: add(1, -1)&amp;#x0A;  Actual: 1&amp;#x0A;Expected: 0&quot;</span><span class="w"> </span><span class="na">type=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>...<span class="nt">&lt;/failure&gt;</span>
<span class="w">    </span><span class="nt">&lt;/testcase&gt;</span>
<span class="w">    </span><span class="nt">&lt;testcase</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;Subtraction&quot;</span><span class="w"> </span><span class="na">file=</span><span class="s">&quot;test.cpp&quot;</span><span class="w"> </span><span class="na">line=</span><span class="s">&quot;2&quot;</span><span class="w"> </span><span class="na">status=</span><span class="s">&quot;run&quot;</span><span class="w"> </span><span class="na">time=</span><span class="s">&quot;0.005&quot;</span><span class="w"> </span><span class="na">classname=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;/testcase&gt;</span>
<span class="w">  </span><span class="nt">&lt;/testsuite&gt;</span>
<span class="w">  </span><span class="nt">&lt;testsuite</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;LogicTest&quot;</span><span class="w"> </span><span class="na">tests=</span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="na">failures=</span><span class="s">&quot;0&quot;</span><span class="w"> </span><span class="na">errors=</span><span class="s">&quot;0&quot;</span><span class="w"> </span><span class="na">time=</span><span class="s">&quot;0.005&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;testcase</span><span class="w"> </span><span class="na">name=</span><span class="s">&quot;NonContradiction&quot;</span><span class="w"> </span><span class="na">file=</span><span class="s">&quot;test.cpp&quot;</span><span class="w"> </span><span class="na">line=</span><span class="s">&quot;3&quot;</span><span class="w"> </span><span class="na">status=</span><span class="s">&quot;run&quot;</span><span class="w"> </span><span class="na">time=</span><span class="s">&quot;0.005&quot;</span><span class="w"> </span><span class="na">classname=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>
<span class="w">    </span><span class="nt">&lt;/testcase&gt;</span>
<span class="w">  </span><span class="nt">&lt;/testsuite&gt;</span>
<span class="nt">&lt;/testsuites&gt;</span>
</pre></div>
</div>
<p>Cose da notare:</p>
<ul class="simple">
<li><p>L’attributo <code class="docutils literal notranslate"><span class="pre">tests</span></code> di un elemento <code class="docutils literal notranslate"><span class="pre">&lt;testsuites&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">&lt;testsuite&gt;</span></code> indica quante funzioni di test contiene il programma GoogleTest o la test suite, mentre l’attributo <code class="docutils literal notranslate"><span class="pre">failures</span></code> indica quanti di essi hanno fallito.</p></li>
<li><p>L’attributo <code class="docutils literal notranslate"><span class="pre">time</span></code> esprime la durata del test, della test suite o dell’intero programma di test in secondi.</p></li>
<li><p>L’attributo <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> registra la data e l’ora locale dell’esecuzione del test.</p></li>
<li><p>Gli attributi <code class="docutils literal notranslate"><span class="pre">file</span></code> e <code class="docutils literal notranslate"><span class="pre">line</span></code> registrano la posizione del file sorgente, dove è stato definito il test.</p></li>
<li><p>Ogni elemento <code class="docutils literal notranslate"><span class="pre">&lt;failure&gt;</span></code> corrisponde a una singola asserzione GoogleTest non riuscita.</p></li>
</ul>
</section>
<section id="generating-a-json-report">
<h5>Generare un Report JSON<a class="headerlink" href="#generating-a-json-report" title="Link to this heading">¶</a></h5>
<p>GoogleTest può anche emettere un report JSON come formato alternativo a XML. Per generare il report JSON, si imposta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_OUTPUT</span></code> o il flag <code class="docutils literal notranslate"><span class="pre">--gtest_output</span></code> con la stringa <code class="docutils literal notranslate"><span class="pre">&quot;json:path_to_output_file&quot;</span></code>, che creerà il file nella posizione specificata. Si può anche utilizzare semplicemente la stringa <code class="docutils literal notranslate"><span class="pre">&quot;json&quot;</span></code>, nel qual caso l’output si trova nel file <code class="docutils literal notranslate"><span class="pre">test_detail.json</span></code> nella directory corrente.</p>
<p>Il formato del report è conforme al seguente schema JSON:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;$schema&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;https://json-schema.org/schema#&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;definitions&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;TestCase&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;tests&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;failures&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;disabled&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;testsuite&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;array&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;items&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;$ref&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;#/definitions/TestInfo&quot;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;TestInfo&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;file&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;line&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;status&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;enum&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;RUN&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;NOTRUN&quot;</span><span class="p">]</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;classname&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;failures&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;array&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;items&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;$ref&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;#/definitions/Failure&quot;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;Failure&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;failures&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;properties&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;tests&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;failures&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;disabled&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;errors&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;timestamp&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;format&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;date-time&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;testsuites&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;array&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;items&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nt">&quot;$ref&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;#/definitions/TestCase&quot;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Il report utilizza il formato conforme al seguente Proto3 utilizzando la <a class="reference external" href="https://developers.google.com/protocol-buffers/docs/proto3#json">codifica JSON</a>:</p>
<div class="highlight-proto notranslate"><div class="highlight"><pre><span></span><span class="k">syntax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;proto3&quot;</span><span class="p">;</span>

<span class="kn">package</span><span class="w"> </span><span class="nn">googletest</span><span class="p">;</span>

<span class="k">import</span><span class="w"> </span><span class="s">&quot;google/protobuf/timestamp.proto&quot;</span><span class="p">;</span>
<span class="k">import</span><span class="w"> </span><span class="s">&quot;google/protobuf/duration.proto&quot;</span><span class="p">;</span>

<span class="kd">message</span><span class="w"> </span><span class="nc">UnitTest</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">tests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">failures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">disabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">errors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="n">google.protobuf.Timestamp</span><span class="w"> </span><span class="na">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="n">google.protobuf.Duration</span><span class="w"> </span><span class="na">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">  </span><span class="k">repeated</span><span class="w"> </span><span class="n">TestCase</span><span class="w"> </span><span class="na">testsuites</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span><span class="w"> </span><span class="nc">TestCase</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">tests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">failures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">disabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">errors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="n">google.protobuf.Duration</span><span class="w"> </span><span class="na">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">  </span><span class="k">repeated</span><span class="w"> </span><span class="n">TestInfo</span><span class="w"> </span><span class="na">testsuite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">message</span><span class="w"> </span><span class="nc">TestInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="na">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int32</span><span class="w"> </span><span class="na">line</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">  </span><span class="kd">enum</span><span class="w"> </span><span class="n">Status</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="na">RUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="na">NOTRUN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">Status</span><span class="w"> </span><span class="na">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">google.protobuf.Duration</span><span class="w"> </span><span class="na">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="na">classname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="kd">message</span><span class="w"> </span><span class="nc">Failure</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="na">failures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="na">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">repeated</span><span class="w"> </span><span class="n">Failure</span><span class="w"> </span><span class="na">failures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ad esempio, il seguente programma</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">MathTest</span><span class="p">,</span><span class="w"> </span><span class="n">Addition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">MathTest</span><span class="p">,</span><span class="w"> </span><span class="n">Subtraction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">LogicTest</span><span class="p">,</span><span class="w"> </span><span class="n">NonContradiction</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>potrebbe generare questo report:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;tests&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;failures&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;errors&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.035s&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;timestamp&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;2011-10-31T18:52:42Z&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;AllTests&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;testsuites&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;MathTest&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;tests&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;failures&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;errors&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.015s&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;testsuite&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Addition&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;file&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;test.cpp&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;line&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;status&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;RUN&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.007s&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;classname&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;failures&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">              </span><span class="nt">&quot;message&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Value of: add(1, 1)\n  Actual: 3\nExpected: 2&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="w">            </span><span class="p">},</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">              </span><span class="nt">&quot;message&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Value of: add(1, -1)\n  Actual: 1\nExpected: 0&quot;</span><span class="p">,</span>
<span class="w">              </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">          </span><span class="p">]</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Subtraction&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;file&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;test.cpp&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;line&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;status&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;RUN&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.005s&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;classname&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;LogicTest&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;tests&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;failures&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;errors&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.005s&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;testsuite&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">          </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;NonContradiction&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;file&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;test.cpp&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;line&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;status&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;RUN&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;time&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.005s&quot;</span><span class="p">,</span>
<span class="w">          </span><span class="nt">&quot;classname&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>{: .callout .important} IMPORTANTE: Il formato esatto del documento JSON è soggetto a modifiche.</p>
</section>
</section>
<section id="controlling-how-failures-are-reported">
<h4>Controllare Come Vengono Riportati gli Errori<a class="headerlink" href="#controlling-how-failures-are-reported" title="Link to this heading">¶</a></h4>
<section id="detecting-test-premature-exit">
<h5>Rilevare le Uscite Premature dei Test<a class="headerlink" href="#detecting-test-premature-exit" title="Link to this heading">¶</a></h5>
<p>Google Test implements the <em>premature-exit-file</em> protocol for test runners to catch any kind of unexpected exits of test programs. All’avvio, Google Test crea il file che verrà automaticamente eliminato al termine di tutto il lavoro. Poi, il test runner può verificare se questo file esiste. Nel caso in cui il file rimanga non eliminato, il test ispezionato è terminato prematuramente.</p>
<p>Questa funzione è abilitata solo se è stata impostata la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">TEST_PREMATURE_EXIT_FILE</span></code>.</p>
</section>
<section id="turning-assertion-failures-into-break-points">
<h5>Trasformare gli Errori delle Asserzioni in Break-Point<a class="headerlink" href="#turning-assertion-failures-into-break-points" title="Link to this heading">¶</a></h5>
<p>Quando si eseguono programmi di test in un debugger, è molto conveniente che il debugger possa rilevare un errore di asserzione e passare automaticamente alla modalità interattiva. La modalità <em>break-on-failure</em> di GoogleTest supporta questo comportamento.</p>
<p>Per abilitarlo, si imposta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_BREAK_ON_FAILURE</span></code> su un valore diverso da <code class="docutils literal notranslate"><span class="pre">0</span></code>. In alternativa, si può utilizzare il flag della riga di comando <code class="docutils literal notranslate"><span class="pre">--gtest_break_on_failure</span></code>.</p>
</section>
<section id="disabling-catching-test-thrown-exceptions">
<h5>Disabilitare la Cattura di Eccezioni Test-Thrown<a class="headerlink" href="#disabling-catching-test-thrown-exceptions" title="Link to this heading">¶</a></h5>
<p>GoogleTest può essere utilizzato con o senza eccezioni abilitate. Se un test genera un’eccezione C++ o (su Windows) un’eccezione strutturata (SEH), per default GoogleTest la rileva, la segnala come un errore del test e continua con il metodo di test successivo. Ciò massimizza la copertura di un’esecuzione di test. Inoltre, su Windows un’eccezione non rilevata genererà una finestra popup, quindi catturare le eccezioni consente di eseguire i test automaticamente.</p>
<p>Durante il debug degli errori di test, tuttavia, si potrebbe invece volere che le eccezioni vengano gestite dal debugger, in modo da poter esaminare lo stack delle chiamate quando viene generata un’eccezione. Per raggiungere questo obiettivo, si imposta la variabile di ambiente <code class="docutils literal notranslate"><span class="pre">GTEST_CATCH_EXCEPTIONS</span></code> su <code class="docutils literal notranslate"><span class="pre">0</span></code> o si usa il flag <code class="docutils literal notranslate"><span class="pre">--gtest_catch_exceptions=0</span></code> durante l’esecuzione dei test.</p>
</section>
</section>
<section id="sanitizer-integration">
<h4>Integrazione del Sanitizer<a class="headerlink" href="#sanitizer-integration" title="Link to this heading">¶</a></h4>
<p><a class="reference external" href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Undefined Behavior Sanitizer</a>, <a class="reference external" href="https://github.com/google/sanitizers/wiki/AddressSanitizer">Address Sanitizer</a> e <a class="reference external" href="https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual">Thread Sanitizer</a> forniscono tutti funzioni deboli che si possono sovrascrivere [override] per sollevare errori espliciti quando rilevano errori di sanitizer, come la creazione di un riferimento da <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. Per sovrascrivere queste funzioni, si inseriscono le relative definizioni in un file sorgente che si compila come parte del binario principale:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="p">{</span>
<span class="n">void</span> <span class="n">__ubsan_on_report</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">FAIL</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Encountered an undefined behavior sanitizer error&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">void</span> <span class="n">__asan_on_error</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">FAIL</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Encountered an address sanitizer error&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">void</span> <span class="n">__tsan_on_report</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">FAIL</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Encountered a thread sanitizer error&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">extern</span> <span class="s2">&quot;C&quot;</span>
</pre></div>
</div>
<p>Dopo aver compilato il progetto con uno dei sanitizer abilitati, se un particolare test attiva un errore del sanitizer, GoogleTest segnalerà che non è riuscito.</p>
</section>
</section>
</section>
<span id="document-docs/gmock_for_dummies"></span><section id="gmock-for-dummies">
<h2>gMock per Principianti<a class="headerlink" href="#gmock-for-dummies" title="Link to this heading">¶</a></h2>
<section id="what-is-gmock">
<h3>Cos’è gMock?<a class="headerlink" href="#what-is-gmock" title="Link to this heading">¶</a></h3>
<p>Quando si scrive un prototipo o un test, spesso non è fattibile o saggio affidarsi interamente a oggetti reali. Un <strong>oggetto mock</strong> implementa la stessa interfaccia di un oggetto reale (quindi può essere utilizzato in sua vece), ma consente di specificare in fase di esecuzione come verrà utilizzato e cosa dovrebbe fare (quali metodi saranno chiamati? In quale ordine? Quante volte? Con quali argomenti? Cosa restituiranno? ecc.).</p>
<p>È facile confondere il termine <em>oggetti fake</em> (falsi) con oggetto mock (simulati). I fake e i mock in realtà significano cose molto diverse nella comunità del Test-Driven Development (TDD):</p>
<ul class="simple">
<li><p>Gli oggetti <strong>fake</strong> hanno implementazioni funzionanti, ma solitamente prendono qualche scorciatoia (magari per rendere le operazioni meno costose), che li rende non adatti alla produzione. Un file system in memoria è un esempio di fake.</p></li>
<li><p>I <strong>mocks</strong> sono oggetti preprogrammati con delle <em>expectation</em>, che formano una specifica delle chiamate che si aspettano di ricevere.</p></li>
</ul>
<p>Se tutto questo appare troppo astratto, non c’è da preoccuparsi: la cosa più importante da ricordare è che un mock consente di verificare l”<em>interazione</em> tra se stesso e il codice che lo utilizza. La differenza tra i fake e i mock diventerà molto più chiara una volta che si inizia ad usare utilizzare i mock.</p>
<p><strong>gMock</strong> è una libreria (a volte la chiamiamo anche «framework» per farlo sembrare interessante) per creare classi mock e utilizzarle. Fa a C++ quello che jMock/EasyMock fa a Java (beh, più o meno).</p>
<p>Quando si usa gMock,</p>
<ol class="arabic simple">
<li><p>per prima cosa si usano alcune semplici macro per descrivere l’interfaccia che si vuol simulare [mock] e queste si espanderanno nell’implementazione della classe mock;</p></li>
<li><p>successivamente, si creano alcuni oggetti mock e se ne specificano le aspettative e il comportamento utilizzando una sintassi intuitiva;</p></li>
<li><p>quindi si usa il codice che utilizza gli oggetti mock. gMock rileverà qualsiasi violazione delle aspettative non appena si presentano.</p></li>
</ol>
</section>
<section id="why-gmock">
<h3>Perché gMock?<a class="headerlink" href="#why-gmock" title="Link to this heading">¶</a></h3>
<p>Sebbene gli oggetti mock aiutino a rimuovere le dipendenze non necessarie nei test e a renderli veloci e affidabili, usare i mock manualmente in C++ è <em>difficile</em>:</p>
<ul class="simple">
<li><p>Qualcuno deve implementare i mock. Il lavoro è solitamente noioso e soggetto a errori. Non c’è da stupirsi che si facciano lunghi giri per evitarlo.</p></li>
<li><p>La qualità di questi mock scritti manualmente è un po”, ehm, imprevedibile. Se ne potrebbero vedere alcuni davvero raffinati, ma ce ne sono anche alcuni che sono stati fatti in fretta e hanno tutti i tipi di restrizioni ad hoc.</p></li>
<li><p>La conoscenza acquisita utilizzando un mock non viene trasferita a quello successivo.</p></li>
</ul>
<p>Al contrario, i programmatori Java e Python dispongono di alcuni ottimi framework di simulazione (jMock, EasyMock, ecc.), che automatizzano la creazione di mock. Di conseguenza, il mocking è una tecnica comprovata ed efficace e una pratica ampiamente adottata in quelle comunità. Avere lo strumento giusto fa assolutamente la differenza.</p>
<p>gMock è stato creato per aiutare i programmatori C++. È stato ispirato da jMock e EasyMock, ma progettato pensando alle specifiche del C++. Risulta amichevole se uno qualsiasi dei seguenti problemi è un disturbo:</p>
<ul class="simple">
<li><p>Si è bloccati con un progetto non ottimale e si vorrebbe aver fatto più prototipi prima che fosse troppo tardi, ma la prototipazione in C++ non è affatto «rapida».</p></li>
<li><p>I test sono lenti poiché dipendono da troppe librerie o utilizzano risorse costose (ad esempio un database).</p></li>
<li><p>I test sono fragili poiché alcune risorse che utilizzano sono inaffidabili (ad esempio la rete).</p></li>
<li><p>Si vuol testare il modo in cui il codice gestisce un errore (ad esempio un errore di checksum del file), ma non è facile causarne uno.</p></li>
<li><p>Si vuol essere certi che un modulo interagisca con gli altri moduli nel modo giusto, ma è difficile osservare l’interazione; quindi si ricorre all’osservazione degli effetti collaterali alla fine dell’azione, ma nella migliore delle ipotesi è imbarazzante.</p></li>
<li><p>Si vogliono «simulare» [mock] le dipendenze, tranne per il fatto che non ci sono ancora implementazioni mock; e, francamente, non si è entusiasti di alcune di quelle scritte a mano.</p></li>
</ul>
<p>Invitiamo a utilizzare gMock come</p>
<ul class="simple">
<li><p>uno strumento di <em>design</em>, poiché consente di sperimentare subito e spesso il design dell’interfaccia. Più iterazioni portano a progetti migliori!</p></li>
<li><p>uno strumento di <em>test</em> per ridurre le dipendenze dagli output dei test e sondare l’interazione tra il modulo e i suoi collaboratori.</p></li>
</ul>
</section>
<section id="getting-started">
<h3>Iniziamo<a class="headerlink" href="#getting-started" title="Link to this heading">¶</a></h3>
<p>gMock è allegato a googletest.</p>
</section>
<section id="a-case-for-mock-turtles">
<h3>Un Caso per Tartarughe Mock<a class="headerlink" href="#a-case-for-mock-turtles" title="Link to this heading">¶</a></h3>
<p>Diamo un’occhiata a un esempio. Supponiamo che si stia sviluppando un programma di grafica che si basa su un’API simile a <a class="reference external" href="https://en.wikipedia.org/wiki/Logo_programming_language">LOGO</a> per il disegno. Come provare che faccia la cosa giusta? Bene, lo si può eseguire e confrontare lo schermo con una schermata campione, ma ammettiamolo: test come questo sono costosi da eseguire e fragili (e se si passasse a una nuova brillante scheda grafica con un anti-aliasing migliore? All’improvviso si devono aggiornare tutte le immagini campione). Sarebbe troppo laborioso se tutti i test fossero così. Fortunatamente, è nota la <a class="reference external" href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> e si conosce la cosa giusta da fare: anziché far dialogare l’applicazione direttamente con l’API di sistema, si avvolgono le API in un’interfaccia (ad esempio, <code class="docutils literal notranslate"><span class="pre">Turtle</span></code>) e il codice di tale interfaccia:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Turtle</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Turtle</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">PenUp</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">PenDown</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Forward</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">distance</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Turn</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">degrees</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">GoTo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GetX</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GetY</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>(Notare che il distruttore di <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> <strong>deve</strong> essere virtual, come nel caso di <strong>tutte</strong> le classi da cui si intende ereditare - altrimenti il distruttore della classe derivata non verrà chiamata quando si elimina un oggetto tramite un puntatore base e si otterranno stati del programma danneggiati come i memory leak).</p>
<p>Si può controllare se il movimento della tartaruga lascerà una traccia usando <code class="docutils literal notranslate"><span class="pre">PenUp()</span></code> e <code class="docutils literal notranslate"><span class="pre">PenDown()</span></code> e controllarne il movimento con <code class="docutils literal notranslate"><span class="pre">Forward()</span></code>, <code class="docutils literal notranslate"><span class="pre">Turn()</span></code> e <code class="docutils literal notranslate"><span class="pre">GoTo()</span></code>. Infine, <code class="docutils literal notranslate"><span class="pre">GetX()</span></code> e <code class="docutils literal notranslate"><span class="pre">GetY()</span></code> dicono la posizione attuale della tartaruga.</p>
<p>Il programma normalmente utilizzerà un’implementazione reale di questa interfaccia. Nei test è invece possibile utilizzare un’implementazione mock. Ciò consente di controllare facilmente quali primitive di disegno sta chiamando il programma, con quali argomenti e in quale ordine. I test scritti in questo modo sono molto più robusti (non si romperanno perché la nuova macchina esegue l’anti-aliasing in modo diverso), sono più facili da leggere e mantenere (l’intento di un test è espresso nel codice, non in alcune immagini binarie) e si gira <em>molto, molto più velocemente</em>.</p>
</section>
<section id="writing-the-mock-class">
<h3>Scrittura della Classe Mock<a class="headerlink" href="#writing-the-mock-class" title="Link to this heading">¶</a></h3>
<p>Se si è fortunati, i mock da utilizzare sono già stati implementati da alcune persone simpatiche. Se, tuttavia, ci si trova nella posizione di scrivere una classe mock, si può stare tranquilli: gMock trasforma questo compito in un gioco divertente! (Be” quasi).</p>
<section id="how-to-define-it">
<h4>Come la si Definisce<a class="headerlink" href="#how-to-define-it" title="Link to this heading">¶</a></h4>
<p>Utilizzando l’interfaccia di <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> come esempio, ecco i semplici passaggi da seguire:</p>
<ul class="simple">
<li><p>Derivare una classe <code class="docutils literal notranslate"><span class="pre">MockTurtle</span></code> da <code class="docutils literal notranslate"><span class="pre">Turtle</span></code>.</p></li>
<li><p>Prendere una funzione <em>virtual</em> di <code class="docutils literal notranslate"><span class="pre">Turtle</span></code> (sebbene sia possibile <span class="xref myst">«mock-are» metodi non-virtuali utilizzando i template</span>, è molto più complicato).</p></li>
<li><p>Nella sezione <code class="docutils literal notranslate"><span class="pre">public:</span></code> della classe figlia, si scrive <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD();</span></code></p></li>
<li><p>Ora arriva la parte divertente: si prende la firma [signature] della funzione, la si taglia e la si incolla nella macro e si aggiungono due virgole: una tra il tipo restituito e il nome, un’altra tra il nome e l’elenco degli argomenti.</p></li>
<li><p>Per mock-are un metodo const, si aggiunge un 4° parametro contenente <code class="docutils literal notranslate"><span class="pre">(const)</span></code> (le parentesi sono obbligatorie).</p></li>
<li><p>Poiché si sta sovrascrivendo [overriding] un metodo virtuale, suggeriamo di aggiungere la parola chiave <code class="docutils literal notranslate"><span class="pre">override</span></code>. Per i metodi const il 4° parametro diventa <code class="docutils literal notranslate"><span class="pre">(const,</span> <span class="pre">override)</span></code>, per i metodi non-const basta <code class="docutils literal notranslate"><span class="pre">(override)</span></code>. Questo non è obbligatorio.</p></li>
<li><p>Si ripete per tutte le funzioni virtuali da simulare (mock-are). (Inutile dire che <em>tutti</em> i metodi virtuali puri nella classe astratta devono essere mock-ati o sovrascritti).</p></li>
</ul>
<p>Alla fine del processo, si dovrebbe avere qualcosa del genere:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gmock/gmock.h&gt;</span><span class="c1">  // Brings in gMock.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockTurtle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Turtle</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">PenUp</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">PenDown</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Forward</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">distance</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Turn</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">degrees</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">GoTo</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">GetX</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">GetY</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Non è necessario definire questi metodi mock da qualche altra parte: la macro <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> genererà le definizioni automaticamente. È così semplice!</p>
</section>
<section id="where-to-put-it">
<h4>Dove Metterlo<a class="headerlink" href="#where-to-put-it" title="Link to this heading">¶</a></h4>
<p>Quando si definisce una classe mock, si deve decidere dove inserire la sua definizione. Qualcuno le mette in un <code class="docutils literal notranslate"><span class="pre">_test.cc</span></code>. Questo va bene quando l’interfaccia mock-ata (ad esempio, <code class="docutils literal notranslate"><span class="pre">Foo</span></code>) è di proprietà della stessa persona o team. Altrimenti, quando il proprietario di <code class="docutils literal notranslate"><span class="pre">Foo</span></code> la modifica, il test potrebbe non funzionare. (Non ci si può certo aspettare che il manutentore di <code class="docutils literal notranslate"><span class="pre">Foo</span></code> corregga ogni test che usa <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, vero?)</p>
<p>In generale, non si dovrebbero mock-are le classi altrui. Per mock-are una classe simile di altri, si definisce la classe mock nel pacchetto Bazel di <code class="docutils literal notranslate"><span class="pre">Foo</span></code> (di solito la stessa directory o una sottodirectory di <code class="docutils literal notranslate"><span class="pre">testing</span></code>) e la si inserisce in un <code class="docutils literal notranslate"><span class="pre">.h</span></code> e un <code class="docutils literal notranslate"><span class="pre">cc_library</span></code> con <code class="docutils literal notranslate"><span class="pre">testonly=True</span></code>. Dopodiché tutti possono farvi riferimento dai loro test. Se <code class="docutils literal notranslate"><span class="pre">Foo</span></code> cambia, c’è solo una copia di <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> da modificare e solo i test che dipendono dai metodi modificati devono essere corretti.</p>
<p>C’è un altro modo per farlo: si può introdurre un sottile layer <code class="docutils literal notranslate"><span class="pre">FooAdaptor</span></code> al di sopra di <code class="docutils literal notranslate"><span class="pre">Foo</span></code> e inserire il codice per questa nuova interfaccia. Poiché si è proprietari di <code class="docutils literal notranslate"><span class="pre">FooAdaptor</span></code>, si possono assorbire più facilmente le modifiche in <code class="docutils literal notranslate"><span class="pre">Foo</span></code>. Anche se inizialmente questo richiede più lavoro, scegliere attentamente l’interfaccia dell’adattatore [adaptor] può rendere il codice più facile da scrivere e più leggibile (un vantaggio netto a lungo termine), poiché si può scegliere <code class="docutils literal notranslate"><span class="pre">FooAdaptor</span></code> per adattarlo maggiormente al dominio specifico meglio di <code class="docutils literal notranslate"><span class="pre">Foo</span></code>.</p>
</section>
</section>
<section id="using-mocks-in-tests">
<h3>Uso dei Mock nei Test<a class="headerlink" href="#using-mocks-in-tests" title="Link to this heading">¶</a></h3>
<p>Una volta che si ha una classe mock, usarla è facile. Il flusso di lavoro tipico è:</p>
<ol class="arabic simple">
<li><p>Si importano i nomi gMock dal namespace <code class="docutils literal notranslate"><span class="pre">testing</span></code> in modo da poterli utilizzare senza qualificarli (lo si deve fare solo una volta per file). Ricordarsi che i namespace sono una buona idea.</p></li>
<li><p>Si creano degli oggetti mock.</p></li>
<li><p>Si specificano le [expectation] aspettative su di essi (quante volte verrà chiamato un metodo? Con quali argomenti? Cosa dovrebbe fare? ecc.).</p></li>
<li><p>Si esegue il codice che utilizza i mock; facoltativamente, si controlla il risultato utilizzando le asserzioni di googletest. Se un metodo mock viene chiamato più volte del previsto o con argomenti sbagliati, si riceverà immediatamente un errore.</p></li>
<li><p>Quando un mock viene distrutto, gMock controllerà automaticamente se tutte le expectation su di esso sono state soddisfatte.</p></li>
</ol>
<p>Ecco un esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;path/to/mock-turtle.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gmock/gmock.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gtest/gtest.h&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AtLeast</span><span class="p">;</span><span class="w">                         </span><span class="c1">// #1</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">PainterTest</span><span class="p">,</span><span class="w"> </span><span class="n">CanDrawSomething</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MockTurtle</span><span class="w"> </span><span class="n">turtle</span><span class="p">;</span><span class="w">                              </span><span class="c1">// #2</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">PenDown</span><span class="p">())</span><span class="w">                  </span><span class="c1">// #3</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AtLeast</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="w">  </span><span class="n">Painter</span><span class="w"> </span><span class="nf">painter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turtle</span><span class="p">);</span><span class="w">                       </span><span class="c1">// #4</span>

<span class="w">  </span><span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">painter</span><span class="p">.</span><span class="n">DrawCircle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">));</span><span class="w">      </span><span class="c1">// #5</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Come intuito, questo test verifica che <code class="docutils literal notranslate"><span class="pre">PenDown()</span></code> venga chiamato almeno una volta. Se l’oggetto <code class="docutils literal notranslate"><span class="pre">painter</span></code> non ha chiamato questo metodo, il test fallirà con un messaggio come questo:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>path/to/my_test.cc:119: Failure
Actual function call count doesn&#39;t match this expectation:
Actually: never called;
Expected: called at least once.
Stack trace:
...
</pre></div>
</div>
<p><strong>Tip 1:</strong> Se si esegue il test da un buffer Emacs, si può premere <code class="docutils literal notranslate"><span class="pre">&lt;Invio&gt;</span></code> sul numero di riga per passare direttamente alla expectation non riuscita.</p>
<p><strong>Tip 2:</strong> Se gli oggetti mock non vengono mai eliminati, la verifica finale non avrà luogo. Pertanto è una buona idea attivare il controllo dell’heap nei test quando si allocano i mock sull’heap. Lo si ottiene automaticamente se si usa già la libreria <code class="docutils literal notranslate"><span class="pre">gtest_main</span></code>.</p>
<section id="expectation-ordering">
<h4>Expectation Ordering<a class="headerlink" href="#expectation-ordering" title="Link to this heading">¶</a></h4>
<p><strong>Nota importante:</strong> gMock richiede che le expectation siano impostate <strong>prima</strong> di chiamare le funzioni mock, altrimenti il comportamento è <strong>indefinito</strong>. Non alternare le chiamate a <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> e le chiamate alle funzioni mock e non impostare alcuna expectation su un mock dopo averlo passato a un’API.</p>
<p>Ciò significa che <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> dovrebbe essere letto come se si aspettasse che una chiamata avverrà <em>in futuro</em>, non che una chiamata sia avvenuta. Perché gMock funziona così? Ebbene, specificare in anticipo la expectation consente a gMock di riportare una violazione non appena si verifica, quando il contesto (stack trace, ecc.) è ancora disponibile. Ciò semplifica molto il debug.</p>
<p>Certo, questo test è artificioso e non fa molto. Si può facilmente ottenere lo stesso effetto senza utilizzare gMock. Tuttavia, come vedremo presto, gMock permette di fare <em>molto di più</em> con i mock.</p>
</section>
</section>
<section id="setting-expectations">
<h3>Impostare le Expectation<a class="headerlink" href="#setting-expectations" title="Link to this heading">¶</a></h3>
<p>La chiave per utilizzare con successo un oggetto mock è quella di impostarvi le <em>expectation giuste</em>. Con delle expectation troppo rigide, il test fallirà per modifiche non correlate. Se sono troppo blande, qualche bug potrebbe sfuggire. Lo si vuole fare nel modo giusto in modo che il test possa rilevare esattamente il tipo di bug che si intende rilevare. gMock fornisce i mezzi necessari per farlo «nel modo giusto».</p>
<section id="general-syntax">
<h4>Sintassi Generale<a class="headerlink" href="#general-syntax" title="Link to this heading">¶</a></h4>
<p>In gMock usiamo la macro <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> per impostare una expectation su un metodo mock. La sintassi generale è:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_object</span><span class="p">,</span><span class="w"> </span><span class="n">method</span><span class="p">(</span><span class="n">matchers</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">cardinality</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">action</span><span class="p">);</span>
</pre></div>
</div>
<p>La macro ha due argomenti: prima l’oggetto mock, poi il metodo e i suoi argomenti. Si noti che i due sono separati da una virgola (<code class="docutils literal notranslate"><span class="pre">,</span></code>), non da un punto (<code class="docutils literal notranslate"><span class="pre">.</span></code>). (Perché si usa una virgola? La risposta è che era necessario per motivi tecnici). Se il metodo non è overloaded, la macro può essere richiamata anche senza i matcher:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_object</span><span class="p">,</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">overloaded</span><span class="o">-</span><span class="n">method</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">cardinality</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">action</span><span class="p">);</span>
</pre></div>
</div>
<p>Questa sintassi consente a chi scrive il test di specificare che è «chiamato con qualsiasi argomento» senza specificare esplicitamente il numero o il tipo di argomenti. Per evitare ambiguità indesiderate, questa sintassi può essere utilizzata solo per metodi che non sono sovraccaricati [overloaded].</p>
<p>Entrambe le forme della macro possono essere seguite da alcune <em>clausole</em> [clause] facoltative che forniscono ulteriori informazioni sulla expectation. Illustreremo come funziona ciascuna clausola nelle prossime sezioni.</p>
<p>Questa sintassi è progettata per far sì che una expectation venga letta come l’inglese. Ad esempio, probabilmente si intuirà che</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GetX</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">150</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">200</span><span class="p">));</span>
</pre></div>
</div>
<p>dice che il metodo <code class="docutils literal notranslate"><span class="pre">turtle</span></code> dell’oggetto <code class="docutils literal notranslate"><span class="pre">GetX()</span></code> verrà chiamato cinque volte, restituirà 100 la prima volta, 150 la seconda volta e poi 200 ogni volta. A qualcuno piace chiamare questo stile di sintassi un Domain-Specific Language (DSL).</p>
<p>{: .callout .note} <strong>Nota:</strong> Perché utilizziamo una macro per fare questo? Beh, ha due scopi: in primo luogo rende le expectation facilmente identificabili (sia da <code class="docutils literal notranslate"><span class="pre">grep</span></code> che da un lettore umano), e in secondo luogo consente a gMock di includere la posizione del file sorgente di una expectation non riuscita nei messaggi, facilitando il debugging.</p>
</section>
<section id="matchers-what-arguments-do-we-expect">
<h4>I Matcher: Quali Argomenti Ci Aspettiamo?<a class="headerlink" href="#matchers-what-arguments-do-we-expect" title="Link to this heading">¶</a></h4>
<p>Quando una funzione mock accetta argomenti, possiamo specificare quali ci aspettiamo, ad esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Expects the turtle to move forward by 100 units.</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">Forward</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</pre></div>
</div>
<p>Spesso non si vuol essere troppo specifici. Ricordate quando si parlava di test troppo rigidi? Una specifica eccessiva porta a test fragili e oscura l’intento dei test. Pertanto invitiamo a specificare solo ciò che è necessario, né più né meno. Se non interessa il valore di un argomento, si scrive <code class="docutils literal notranslate"><span class="pre">_</span></code> come argomento, che significa «va bene qualsiasi cosa»:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// Expects that the turtle jumps to somewhere on the x=50 line.</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GoTo</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">));</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">_</span></code> è un’istanza di quelle che chiamiamo <strong>matcher</strong>. Un matcher è come un predicato e può verificare se un argomento è quello che ci aspetteremmo. Si può utilizzare un matcher all’interno di <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> ovunque sia previsto un argomento di funzione. <code class="docutils literal notranslate"><span class="pre">_</span></code> è un modo conveniente per dire «qualsiasi valore».</p>
<p>Negli esempi precedenti, anche <code class="docutils literal notranslate"><span class="pre">100</span></code> e <code class="docutils literal notranslate"><span class="pre">50</span></code> sono matcher; implicitamente, sono lo stesso di <code class="docutils literal notranslate"><span class="pre">Eq(100)</span></code> e <code class="docutils literal notranslate"><span class="pre">Eq(50)</span></code>, che specificano che l’argomento deve essere uguale (usando <code class="docutils literal notranslate"><span class="pre">operator==</span></code>) all’argomento matcher. Esistono molti <a class="reference internal" href="#reference/matchers.md"><span class="xref myst">matcher nativi [built-in]</span></a> per i tipi comuni (così come <span class="xref myst">matcher personalizzati</span>); per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// Expects the turtle moves forward by at least 100.</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">Forward</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">100</span><span class="p">)));</span>
</pre></div>
</div>
<p>Se non interessa <em>qualsiasi</em> argomento, anziché specificare <code class="docutils literal notranslate"><span class="pre">_</span></code> per ciascuno di essi si può omettere l’elenco dei parametri:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Expects the turtle to move forward.</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">Forward</span><span class="p">);</span>
<span class="c1">// Expects the turtle to jump somewhere.</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GoTo</span><span class="p">);</span>
</pre></div>
</div>
<p>Funziona con tutti i metodi non-overloaded; se un metodo lo è, è necessario aiutare gMock a risolvere quale overload ci si aspetta specificando il numero di argomenti ed eventualmente anche i <span class="xref myst">tipi degli argomenti</span>.</p>
</section>
<section id="cardinalities-how-many-times-will-it-be-called">
<h4>Le Cardinalità: Quante Volte Verrà Chiamata?<a class="headerlink" href="#cardinalities-how-many-times-will-it-be-called" title="Link to this heading">¶</a></h4>
<p>La prima clausola che possiamo specificare dopo una <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> è <code class="docutils literal notranslate"><span class="pre">Times()</span></code>. Chiamiamo il suo argomento una <strong>cardinalità</strong> per dire <em>quante volte</em> dovrebbe verificarsi la chiamata. Consente di ripetere una expectation molte volte senza in realtà scriverla tante volte. Ancora più importante, una cardinalità può essere «fuzzy» (vago), proprio come può esserlo un matcher. Ciò consente all’utente di esprimere esattamente l’intento di un test.</p>
<p>Un caso speciale interessante è quando diciamo <code class="docutils literal notranslate"><span class="pre">Times(0)</span></code>. Come si intuisce - significa che la funzione non dovrebbe essere chiamata con gli argomenti forniti e gMock segnalerà un errore di googletest ogni volta che la funzione viene chiamata (erroneamente).</p>
<p>Abbiamo visto <code class="docutils literal notranslate"><span class="pre">AtLeast(n)</span></code> come esempio di cardinalità fuzzy in precedenza. Per l’elenco delle cardinalità native utilizzabili, vedere <span class="xref myst">qui</span>.</p>
<p>La clausola <code class="docutils literal notranslate"><span class="pre">Times()</span></code> può essere omessa. <strong>Se si omette <code class="docutils literal notranslate"><span class="pre">Times()</span></code>, gMock dedurrà autonomamente la cardinalità</strong>. Le regole sono facili da ricordare:</p>
<ul class="simple">
<li><p>Se non c’è <strong>né</strong> <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> <strong>né</strong> <code class="docutils literal notranslate"><span class="pre">WillRepeatedly()</span></code> nella <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>, la cardinalità dedotta è <code class="docutils literal notranslate"><span class="pre">Times(1)</span></code>.</p></li>
<li><p>Se ci sono <em>n</em> <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> ma <strong>nessun</strong> <code class="docutils literal notranslate"><span class="pre">WillRepeatedly()</span></code>, dove <em>n</em> &gt;= 1, la cardinalità è <code class="docutils literal notranslate"><span class="pre">Times(n)</span></code>.</p></li>
<li><p>Se ci sono <em>n</em> <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> e <strong>un</strong> <code class="docutils literal notranslate"><span class="pre">WillRepeatedly()</span></code>, dove <em>n</em> &gt;= 0, la cardinalità è <code class="docutils literal notranslate"><span class="pre">Times(AtLeast(n))</span></code>.</p></li>
</ul>
<p><strong>Quiz veloce:</strong> cosa accadrà se si prevede che una funzione venga chiamata due volte ma in realtà viene chiamata quattro volte?</p>
</section>
<section id="actions-what-should-it-do">
<h4>Azioni: Cosa Dovrebbe Fare?<a class="headerlink" href="#actions-what-should-it-do" title="Link to this heading">¶</a></h4>
<p>Ci si ricorda che un oggetto mock non ha in realtà un’implementazione funzionante? Noi come utenti dobbiamo dirgli cosa fare quando viene invocato un metodo. Questo è facile in gMock.</p>
<p>Innanzitutto, se il tipo restituito di una funzione mock è un tipo nativo o un puntatore, la funzione ha un”<strong>azione di default</strong> (una funzione <code class="docutils literal notranslate"><span class="pre">void</span></code> tornerà e basta, una funzione <code class="docutils literal notranslate"><span class="pre">bool</span></code> restituirà <code class="docutils literal notranslate"><span class="pre">false</span></code> e le altre funzioni restituiranno 0). Inoltre, in C++ 11 e nelle versioni successive, una funzione mock il cui tipo restituito è default-constructible (ovvero ha un costruttore di default) ha un’azione di default che restituisce un valore costruito dal default. Se non si dice nulla, verrà utilizzato questo comportamento.</p>
<p>In secondo luogo, se una funzione mock non ha un’azione di default, o questa non è adatta alle proprie esigenze, si può specificare l’azione da intraprendere ogni volta che la expectation corrisponde utilizzando una serie di clausole <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> seguite da un facoltativo <code class="docutils literal notranslate"><span class="pre">WillRepeatedly()</span></code>. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GetX</span><span class="p">())</span>
<span class="w">     </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
<span class="w">     </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">200</span><span class="p">))</span>
<span class="w">     </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">300</span><span class="p">));</span>
</pre></div>
</div>
<p>dice che <code class="docutils literal notranslate"><span class="pre">turtle.GetX()</span></code> verrà chiamata <em>esattamente tre volte</em> (gMock lo ha dedotto da quante clausole <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> abbiamo scritto, poiché non abbiamo scritto esplicitamente <code class="docutils literal notranslate"><span class="pre">Times()</span></code>), e restituirà rispettivamente 100, 200 e 300.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GetY</span><span class="p">())</span>
<span class="w">     </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span>
<span class="w">     </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">200</span><span class="p">))</span>
<span class="w">     </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">300</span><span class="p">));</span>
</pre></div>
</div>
<p>dice che <code class="docutils literal notranslate"><span class="pre">turtle.GetY()</span></code> sarà chiamata <em>almeno due volte</em> (gMock lo sa perché abbiamo scritto due clausole <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> e una <code class="docutils literal notranslate"><span class="pre">WillRepeatedly()</span></code> pur non avendo esplicitato <code class="docutils literal notranslate"><span class="pre">Times()</span></code>), restituirà 100 e 200 rispettivamente le prime due volte e 300 dalla terza volta in poi.</p>
<p>Naturalmente, se si scrive esplicitamente un <code class="docutils literal notranslate"><span class="pre">Times()</span></code>, gMock non tenterà di dedurre la cardinalità. Cosa succede se il numero specificato è maggiore delle clausole <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code>? Bene, dopo che tutti i <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> sono esauriti, gMock eseguirà ogni volta l’azione di <em>default</em> per la funzione (a meno che, ovviamente, non si abbia un <code class="docutils literal notranslate"><span class="pre">WillRepeatedly()</span></code>).</p>
<p>Cosa possiamo fare all’interno di <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> oltre a <code class="docutils literal notranslate"><span class="pre">Return()</span></code>? Si può restituire un riferimento utilizzando <code class="docutils literal notranslate"><span class="pre">ReturnRef(</span></code><em><code class="docutils literal notranslate"><span class="pre">variable</span></code></em><code class="docutils literal notranslate"><span class="pre">)</span></code>, o richiamare una funzione pre-definita, tra <span class="xref myst">[others] (altre)</span>.</p>
<p><strong>Nota importante</strong> L’istruzione <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> valuta la clausola dell’azione una sola volta, anche se l’azione può essere eseguita più volte. Pertanto è necessario fare attenzione agli effetti collaterali. Quanto segue potrebbe non fare quello che si desidera:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GetX</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">n</span><span class="o">++</span><span class="p">));</span>
</pre></div>
</div>
<p>Invece di restituire 100, 101, 102, …, consecutivamente, questa funzione mock restituirà sempre 100 in quanto <code class="docutils literal notranslate"><span class="pre">n++</span></code> viene valutato solo una volta. Allo stesso modo, <code class="docutils literal notranslate"><span class="pre">Return(new</span> <span class="pre">Foo)</span></code> creerà un nuovo oggetto <code class="docutils literal notranslate"><span class="pre">Foo</span></code> quando viene eseguito <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> e restituirà ogni volta lo stesso puntatore. Se si vuole che l’effetto collaterale si verifichi ogni volta, si deve definire un’azione personalizzata, che illustreremo nel <span class="xref myst">cook book</span>.</p>
<p>È ora di un altro quiz! Cosa significa quanto segue?</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GetY</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</pre></div>
</div>
<p>Ovviamente <code class="docutils literal notranslate"><span class="pre">turtle.GetY()</span></code> ci si aspetta che venga chiamato quattro volte. Ma se si crede che restituirà 100 ogni volta, è meglio pensarci due volte! Ricordarsi che una clausola <code class="docutils literal notranslate"><span class="pre">WillOnce()</span></code> verrà utilizzata ogni volta che la funzione viene invocata e successivamente verrà eseguita l’azione di default. Quindi la risposta giusta è che <code class="docutils literal notranslate"><span class="pre">turtle.GetY()</span></code> restituirà 100 la prima volta, ma <strong>restituirà 0 dalla seconda volta in poi</strong>, poiché restituire 0 è l’azione di default per le funzioni <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
</section>
<section id="using-multiple-expectations-multiexpectations">
<h4>Uso di Expectation Multiple {#MultiExpectations}<a class="headerlink" href="#using-multiple-expectations-multiexpectations" title="Link to this heading">¶</a></h4>
<p>Finora abbiamo mostrato solo esempi con una sola expectation. Più realisticamente, si specificheranno le expectation su più metodi mock che potrebbero provenire da più oggetti mock.</p>
<p>Per default, quando viene richiamato un metodo mock, gMock cercherà le expectation nell”<strong>ordine inverso</strong> in cui sono definite e si fermerà quando viene trovata una expectation attiva che corrisponde agli argomenti (si possono considerare come «le regole più recenti scavalcano quelle più vecchie»). Se la corrispondente expectation non può accettare più chiamate, si verificherà un errore con violazione del limite superiore [upper-bound-violated]. Ecco un esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">Forward</span><span class="p">(</span><span class="n">_</span><span class="p">));</span><span class="w">  </span><span class="c1">// #1</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">Forward</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="w">  </span><span class="c1">// #2</span>
<span class="w">    </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Se <code class="docutils literal notranslate"><span class="pre">Forward(10)</span></code> viene chiamato tre volte di seguito, la terza volta si verificherà un errore, poiché l’ultima expectation corrispondente (#2) è stata saturata. Se, tuttavia, la terza chiamata <code class="docutils literal notranslate"><span class="pre">Forward(10)</span></code> viene sostituita da <code class="docutils literal notranslate"><span class="pre">Forward(20)</span></code>, allora andrebbe bene, poiché ora #1 sarà la expectation corrispondente.</p>
<p>{: .callout .note} <strong>Nota:</strong> Perché gMock cerca una corrispondenza nell’ordine <em>inverso</em> delle expectation? Il motivo è che ciò consente all’utente di impostare le expectation di default nel costruttore di un oggetto mock o nella fase di impostazione del [test fixture] e quindi personalizzare il mock expectation più specifiche nel corpo del test. Quindi, se si hanno due expectation sullo stesso metodo, si vuol mettere quella con matcher più specifici <strong>dopo</strong> l’altra, altrimenti la regola più specifica verrebbe oscurata da quella più generale che viene dopo.</p>
<p>{: .callout .tip} <strong>Tip:</strong> È molto comune iniziare con una expectation generale per un metodo e con <code class="docutils literal notranslate"><span class="pre">Times(AnyNumber())</span></code> (omettendo gli argomenti, o con <code class="docutils literal notranslate"><span class="pre">_</span></code> per tutti gli argomenti, se [overloaded] sovraccaricati). Ciò rende expected tutte le chiamate al metodo. Ciò non è necessario per i metodi non menzionati (questi sono «poco interessanti [uninteresting]»), ma è utile per i metodi che hanno alcune expectation, ma per i quali vanno bene altre chiamate. Consultare <span class="xref myst">Le Chiamate Poco Interessanti e Quelle Unexpected</span>.</p>
</section>
<section id="ordered-vs-unordered-calls-orderedcalls">
<h4>Chiamate ordinate e Non {#OrderedCalls}<a class="headerlink" href="#ordered-vs-unordered-calls-orderedcalls" title="Link to this heading">¶</a></h4>
<p>Per default, una expectation può corrispondere a una chiamata anche se una expectation precedente non è stata soddisfatta. In altre parole, le chiamate non devono avvenire nell’ordine in cui sono specificate le expectation.</p>
<p>A volte, si vuole che tutte le chiamate previste avvengano in un ordine rigoroso. Dirlo in gMock è semplice:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InSequence</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">DrawsLineSegment</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">InSequence</span><span class="w"> </span><span class="n">seq</span><span class="p">;</span>

<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">PenDown</span><span class="p">());</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">Forward</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">PenUp</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Creando un oggetto di tipo <code class="docutils literal notranslate"><span class="pre">InSequence</span></code>, tutte le expectation nel suo scope vengono inserite in una <em>sequenza</em> e devono verificarsi <em>sequenzialmente</em>. Dato che facciamo affidamento solo sul costruttore e sul distruttore di questo oggetto per svolgere il lavoro vero e proprio, il suo nome è davvero irrilevante.</p>
<p>In questo esempio, testiamo che <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> chiami le tre funzioni expected nell’ordine in cui sono scritte. Se una chiamata viene effettuata fuori ordine, sarà un errore.</p>
<p>(E se interessa l’ordine relativo di alcune chiamate, ma non di tutte? È possibile specificare un arbitrario ordine parziale? La risposta è … sì! I dettagli si trovano <span class="xref myst">qui</span>.)</p>
</section>
<section id="all-expectations-are-sticky-unless-said-otherwise-stickyexpectations">
<h4>Tutte le expectation sono fisse (a meno che non venga detto diversamente) {#StickyExpectations}<a class="headerlink" href="#all-expectations-are-sticky-unless-said-otherwise-stickyexpectations" title="Link to this heading">¶</a></h4>
<p>Ora facciamo un breve quiz per vedere quanto bene si possano già usare queste cose di mock. Come verificare che alla tartaruga venga chiesto di andare all’origine <em>esattamente due volte</em> (ignorare qualsiasi altra istruzione ricevuta)?</p>
<p>Dopo aver trovato la risposta, date un’occhiata alla nostra e confrontate le note (da risolvere in autonomia - non imbrogliare!):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AnyNumber</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GoTo</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span><span class="w">  </span><span class="c1">// #1</span>
<span class="w">     </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GoTo</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">  </span><span class="c1">// #2</span>
<span class="w">     </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Supponiamo che <code class="docutils literal notranslate"><span class="pre">turtle.GoTo(0,</span> <span class="pre">0)</span></code> sia chiamata tre volte. Nella terza volta, gMock vedrà che gli argomenti corrispondono alla expectation #2 (ricordate che scegliamo sempre l’ultima expectation corrispondente). Ora, poiché abbiamo detto che dovrebbero esserci solo due chiamate di questo tipo, gMock segnalerà immediatamente un errore. Questo è fondamentalmente ciò che abbiamo detto nella sezione <a class="reference internal" href="#MultiExpectations"><span class="xref myst">Uso di Expectation Multiple</span></a> sopra.</p>
<p>Questo esempio mostra che <strong>le expectation in gMock sono per default «appiccicose»</strong>, nel senso che rimangono attive anche dopo aver raggiunto i limiti superiori della loro invocazione. Questa è una regola importante da ricordare, poiché influenza il significato delle specifiche ed è <strong>diversa</strong> da come viene eseguita in molti altri framework di simulazione (Perché dovremmo farlo? Perché pensiamo che la nostra regola renda i casi comuni più facili da esprimere e comprendere).</p>
<p>Semplice? Vediamo se è stato ben compreso: cosa dice il seguente codice?</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GetX</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Se si pensa che dica che <code class="docutils literal notranslate"><span class="pre">turtle.GetX()</span></code> verrà chiamato <code class="docutils literal notranslate"><span class="pre">n</span></code> volte e restituirà 10, 20, 30, …, consecutivamente, ripensateci! Il problema è che, come abbiamo detto, le expectation sono appiccicose. Pertanto, la seconda volta che viene chiamato <code class="docutils literal notranslate"><span class="pre">turtle.GetX()</span></code>, l’ultima (più recente) istruzione <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> corrisponderà e porterà immediatamente a un errore di «upper bound violated»: questo pezzo di codice non è molto utile!</p>
<p>Un modo corretto per dire che <code class="docutils literal notranslate"><span class="pre">turtle.GetX()</span></code> restituirà 10, 20, 30, …, è dire esplicitamente che le expectation <em>non</em> sono appiccicose. In altre parole, dovrebbero <em>ritirarsi</em> appena saturate:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GetX</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>E c’è un modo migliore per farlo: in questo caso, ci aspettiamo che le chiamate avvengano in un ordine specifico e allineiamo le azioni in modo che corrispondano all’ordine. Poiché in questo caso l’ordine è importante, dovremmo renderlo esplicito utilizzando una sequenza:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InSequence</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">InSequence</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">turtle</span><span class="p">,</span><span class="w"> </span><span class="n">GetX</span><span class="p">())</span>
<span class="w">        </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">i</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A proposito, l’altra situazione in cui una expectation può <em>non</em> essere appiccicosa è quando è in una sequenza: non appena viene utilizzata un’altra expectation che viene dopo di essa nella sequenza, viene automaticamente “ritirata” (e non verrà mai più usata per abbinare alcuna chiamata).</p>
</section>
<section id="uninteresting-calls">
<h4>Chiamate Non Interessanti<a class="headerlink" href="#uninteresting-calls" title="Link to this heading">¶</a></h4>
<p>Un oggetto mock può avere molti metodi e non tutti sono così interessanti. Ad esempio, in alcuni test potremmo non interessarci a quante volte <code class="docutils literal notranslate"><span class="pre">GetX()</span></code> e <code class="docutils literal notranslate"><span class="pre">GetY()</span></code> vengono chiamate.</p>
<p>In gMock, se non si è interessati a un metodo, non si dice nulla a riguardo. Se c’è una chiamata a questo metodo, verrà visualizzato un warning nell’output del test, ma non si tratterà di un errore. Questo comportamento è detto «naggy» (fastidioso); per modificarlo, vedere <span class="xref myst">Nice, Strict e Naggy</span>.</p>
</section>
</section>
</section>
<span id="document-docs/gmock_cook_book"></span><section id="gmock-cookbook">
<h2>Ricettario di gMock<a class="headerlink" href="#gmock-cookbook" title="Link to this heading">¶</a></h2>
<p>Qui si trovano delle ricette per utilizzare gMock. Se non è stato ancora fatto, leggere prima la guida <span class="xref myst">gMock per Principianti</span> per capire le basi.</p>
<p>{: .callout .note} <strong>Nota:</strong> gMock risiede nel namespace <code class="docutils literal notranslate"><span class="pre">testing</span></code>. Per maggiore leggibilità, si consiglia di scrivere <code class="docutils literal notranslate"><span class="pre">using</span> <span class="pre">::testing::Foo;</span></code> una volta nel file prima di utilizzare il nome <code class="docutils literal notranslate"><span class="pre">Foo</span></code> definito da gMock. In questa sezione, per brevità, omettiamo le istruzioni <code class="docutils literal notranslate"><span class="pre">using</span></code>, ma nel codice lo si dovrebbe fare.</p>
<section id="creating-mock-classes">
<h3>Creare Classi Mock<a class="headerlink" href="#creating-mock-classes" title="Link to this heading">¶</a></h3>
<p>Le classi mock vengono definite come le normali classi, utilizzando la macro <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> per generare metodi mock-ati. La macro prende 3 o 4 parametri:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyMock</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">ReturnType</span><span class="p">,</span><span class="w"> </span><span class="n">MethodName</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Args</span><span class="p">...));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">ReturnType</span><span class="p">,</span><span class="w"> </span><span class="n">MethodName</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Args</span><span class="p">...),</span><span class="w"> </span><span class="p">(</span><span class="n">Specs</span><span class="p">...));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>I primi 3 parametri sono semplicemente la dichiarazione del metodo, divisa in 3 parti. Il 4° parametro accetta un elenco chiuso di qualificatori, che riguardano il metodo generato:</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">const</span></code></strong> - Rende il metodo mock-ato un metodo <code class="docutils literal notranslate"><span class="pre">const</span></code>. Obbligatorio se si «override» un metodo <code class="docutils literal notranslate"><span class="pre">const</span></code>.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">override</span></code></strong> - Contrassegna il metodo con <code class="docutils literal notranslate"><span class="pre">override</span></code>. Consigliato se si sovrascrive un metodo <code class="docutils literal notranslate"><span class="pre">virtual</span></code>.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">noexcept</span></code></strong> - Contrassegna il metodo con <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>. Obbligatorio se si sovrascrive un metodo <code class="docutils literal notranslate"><span class="pre">noexcept</span></code>.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">Calltype(...)</span></code></strong> - Imposta il tipo di chiamata per il metodo (ad esempio su <code class="docutils literal notranslate"><span class="pre">STDMETHODCALLTYPE</span></code>), utile in Windows.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">ref(...)</span></code></strong> - Contrassegna il metodo con la qualifica del riferimento specificata. Obbligatorio se si esegue l’override di un metodo che dispone di qualifiche dei riferimenti. Ad esempio <code class="docutils literal notranslate"><span class="pre">ref(&amp;)</span></code> o <code class="docutils literal notranslate"><span class="pre">ref(&amp;&amp;)</span></code>.</p></li>
</ul>
<section id="dealing-with-unprotected-commas">
<h4>Trattare le virgole non protette<a class="headerlink" href="#dealing-with-unprotected-commas" title="Link to this heading">¶</a></h4>
<p>Le virgole non-protette, ovvero le virgole non racchiuse tra parentesi, impediscono a <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> di analizzare correttamente i suoi argomenti:</p>
<p>{: .bad}</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">GetPair</span><span class="p">,</span><span class="w"> </span><span class="p">());</span><span class="w">  </span><span class="c1">// Won&#39;t compile!</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">CheckMap</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">));</span><span class="w">  </span><span class="c1">// Won&#39;t compile!</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Soluzione 1 - racchiudere tra le parentesi:</p>
<p>{: .good}</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">),</span><span class="w"> </span><span class="n">GetPair</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">CheckMap</span><span class="p">,</span><span class="w"> </span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">),</span><span class="w"> </span><span class="kt">bool</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Si noti che racchiudere un tipo di ritorno o un tipo di un argomento tra le parentesi non è, in generale, sbagliato in C++. <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> rimuove le parentesi.</p>
<p>Soluzione 2 - definire un alias:</p>
<p>{: .good}</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">BoolAndInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">BoolAndInt</span><span class="p">,</span><span class="w"> </span><span class="n">GetPair</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">MapIntDouble</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">CheckMap</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">MapIntDouble</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="mocking-private-or-protected-methods">
<h4>Il Mock di Metodi Privati or Protetti<a class="headerlink" href="#mocking-private-or-protected-methods" title="Link to this heading">¶</a></h4>
<p>Si deve sempre inserire una definizione del metodo mock (<code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code>) in una sezione <code class="docutils literal notranslate"><span class="pre">public:</span></code> della classe mock, indipendentemente dal fatto che il metodo mocked sia <code class="docutils literal notranslate"><span class="pre">public</span></code>, <code class="docutils literal notranslate"><span class="pre">protected</span></code>, o <code class="docutils literal notranslate"><span class="pre">private</span></code> nella classe base. Ciò consente a <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> e a <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> di fare riferimento alla funzione mock dall’esterno della classe mock. (Sì, il C++ consente a una sottoclasse di modificare il livello di accesso di una funzione virtuale nella classe base). Esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">Transform</span><span class="p">(</span><span class="n">Gadget</span><span class="o">*</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Resume</span><span class="p">();</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">GetTimeOut</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Transform</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Gadget</span><span class="o">*</span><span class="w"> </span><span class="n">g</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// The following must be in the public section, even though the</span>
<span class="w">  </span><span class="c1">// methods are protected or private in the base class.</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Resume</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">GetTimeOut</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="mocking-overloaded-methods">
<h4>Mock di Metodi Overloaded<a class="headerlink" href="#mocking-overloaded-methods" title="Link to this heading">¶</a></h4>
<p>Si possono avere funzioni overloaded mock-ate come al solito. Non è richiesta alcuna attenzione particolare:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// Must be virtual as we&#39;ll inherit from Foo.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Foo</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Overloaded on the types and/or numbers of arguments.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Add</span><span class="p">(</span><span class="n">Element</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">times</span><span class="p">,</span><span class="w"> </span><span class="n">Element</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Overloaded on the const-ness of this object.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">Bar</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">GetBar</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bar</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">GetBar</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Add</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Element</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Add</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">times</span><span class="p">,</span><span class="w"> </span><span class="n">Element</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>

<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">GetBar</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">GetBar</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>{: .callout .note} <strong>Nota:</strong> se non si mock-ano tutte le versioni del metodo sovraccaricato, il compilatore darà un warning sul fatto che che alcuni metodi nella classe base sono nascosti. Per risolvere questo problema, usare <code class="docutils literal notranslate"><span class="pre">using</span></code> per inserirli nello scope:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Foo</span><span class="o">::</span><span class="n">Add</span><span class="p">;</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Add</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Element</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// We don&#39;t want to mock int Add(int times, Element x);</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="mocking-class-templates">
<h4>Mock di Classi Template<a class="headerlink" href="#mocking-class-templates" title="Link to this heading">¶</a></h4>
<p>Si può avere la versione mock di classi template come con qualsiasi classe.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Elem</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StackInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// Must be virtual as we&#39;ll inherit from StackInterface.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">StackInterface</span><span class="p">();</span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GetSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Push</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Elem</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Elem</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MockStack</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">StackInterface</span><span class="o">&lt;</span><span class="n">Elem</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">GetSize</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Push</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Elem</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="mocking-non-virtual-methods-mockingnonvirtualmethods">
<h4>Mock di Metodi Non-virtual {#MockingNonVirtualMethods}<a class="headerlink" href="#mocking-non-virtual-methods-mockingnonvirtualmethods" title="Link to this heading">¶</a></h4>
<p>gMock può produrre versioni mock di funzioni non-virtual da utilizzare nell’inserimento [injection] delle dipendenze Hi-perf.</p>
<p>In questo caso, invece di condividere una classe base comune con la classe reale, la classe mock sarà <em>non correlata</em> alla classe reale, ma conterrà metodi con le stesse firme. La sintassi per il mock dei metodi non-virtual è la <em>stessa</em> dei mock dei metodi virtual (basta non aggiungere <code class="docutils literal notranslate"><span class="pre">override</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// A simple packet stream class.  None of its members is virtual.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ConcretePacketStream</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">AppendPacket</span><span class="p">(</span><span class="n">Packet</span><span class="o">*</span><span class="w"> </span><span class="n">new_packet</span><span class="p">);</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">*</span><span class="w"> </span><span class="nf">GetPacket</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">packet_number</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">NumberOfPackets</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// A mock packet stream class.  It inherits from no other, but defines</span>
<span class="c1">// GetPacket() and NumberOfPackets().</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MockPacketStream</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Packet</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">GetPacket</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">packet_number</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">NumberOfPackets</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Notare che la classe mock non definisce <code class="docutils literal notranslate"><span class="pre">AppendPacket()</span></code>, come la classe reale. Va bene fin quando non è necessario che il test lo chiami.</p>
<p>Successivamente, c’è bisogno di un modo per dire che si vuole utilizzare <code class="docutils literal notranslate"><span class="pre">ConcretePacketStream</span></code> nel codice di produzione mentre <code class="docutils literal notranslate"><span class="pre">MockPacketStream</span></code> nei test. Dato che le funzioni non sono virtuali e le due classi non sono correlate, si deve specificare la scelta in <em>fase di compilazione</em> (invece che in fase di esecuzione [run time]).</p>
<p>Un modo per farlo è creare un template del codice che deve utilizzare lo stream di packet. Più specificamente, si fornirà al codice un argomento di tipo template per il tipo di stream di packet. In produzione, si creerà un’istanza del template con <code class="docutils literal notranslate"><span class="pre">ConcretePacketStream</span></code> come argomento del tipo. Nei test, si istanzierà lo stesso template con <code class="docutils literal notranslate"><span class="pre">MockPacketStream</span></code>. Per esempio, si può scrivere:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">PacketStream</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">CreateConnection</span><span class="p">(</span><span class="n">PacketStream</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">PacketStream</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PacketReader</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">ReadPackets</span><span class="p">(</span><span class="n">PacketStream</span><span class="o">*</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">packet_num</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Poi si possono usare <code class="docutils literal notranslate"><span class="pre">CreateConnection&lt;ConcretePacketStream&gt;()</span></code> e <code class="docutils literal notranslate"><span class="pre">PacketReader&lt;ConcretePacketStream&gt;</span></code> nel codice di produzione, e nei test <code class="docutils literal notranslate"><span class="pre">CreateConnection&lt;MockPacketStream&gt;()</span></code> e <code class="docutils literal notranslate"><span class="pre">PacketReader&lt;MockPacketStream&gt;</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">MockPacketStream</span><span class="w"> </span><span class="n">mock_stream</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_stream</span><span class="p">,</span><span class="w"> </span><span class="p">...)...;</span>
<span class="w">  </span><span class="p">..</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">expectations</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">mock_stream</span><span class="w"> </span><span class="p">...</span>
<span class="w">  </span><span class="n">PacketReader</span><span class="o">&lt;</span><span class="n">MockPacketStream</span><span class="o">&gt;</span><span class="w"> </span><span class="n">reader</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_stream</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">exercise</span><span class="w"> </span><span class="n">reader</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
</section>
<section id="mocking-free-functions">
<h4>Mock di Funzioni Libere [Free]<a class="headerlink" href="#mocking-free-functions" title="Link to this heading">¶</a></h4>
<p>Non è possibile avere direttamente mock di una funzione libera (ad esempio una funzione in stile C o un metodo statico). Se necessario, si può riscrivere il codice per utilizzare un’interfaccia (classe astratta).</p>
<p>Invece di chiamare direttamente una funzione libera (ad esempio, <code class="docutils literal notranslate"><span class="pre">OpenFile</span></code>), se ne introduce un’interfaccia e si dispone una sottoclasse concreta che chiama la funzione libera:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FileInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">Open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">File</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">FileInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">Open</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="n">OpenFile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Il codice dovrebbe comunicare con <code class="docutils literal notranslate"><span class="pre">FileInterface</span></code> per aprire un file. Ora è facile mock-are la funzione.</p>
<p>Potrebbe sembrare una seccatura, ma in pratica spesso ci sono più funzioni correlate inseribili nella stessa interfaccia, quindi la complicazione sintattica per ogni funzione sarà molto inferiore.</p>
<p>Se si è preoccupati per la resa prestazionale sostenuta dalle funzioni virtuali e la profilazione conferma tale preoccupazione, lo si può combinare con la ricetta per i <a class="reference internal" href="#MockingNonVirtualMethods"><span class="xref myst">mock di metodi non-virtual</span></a>.</p>
<p>In alternativa, invece di introdurre una nuova interfaccia, si può riscrivere il codice per accettare una std::function invece della funzione libera per poi utilizzare <a class="reference internal" href="#MockFunction"><span class="xref myst">MockFunction</span></a> per mock-are la std::function.</p>
</section>
<section id="old-style-mock-methodn-macros">
<h4>Le Macro <code class="docutils literal notranslate"><span class="pre">MOCK_METHODn</span></code> Old-Style<a class="headerlink" href="#old-style-mock-methodn-macros" title="Link to this heading">¶</a></h4>
<p>Prima che la macro generica <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> <a class="reference external" href="https://github.com/google/googletest/commit/c5f08bf91944ce1b19bcf414fa1760e69d20afc2">venisse introdotta nel 2018</a>, i mock venivano creati utilizzando una famiglia di macro chiamate <code class="docutils literal notranslate"><span class="pre">MOCK_METHODn</span></code>. Queste macro sono ancora supportate, sebbene sia consigliata la migrazione al nuovo <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code>.</p>
<p>Le macro nella famiglia <code class="docutils literal notranslate"><span class="pre">MOCK_METHODn</span></code> differiscono da <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code>:</p>
<ul class="simple">
<li><p>La struttura generale è <code class="docutils literal notranslate"><span class="pre">MOCK_METHODn(MethodName,</span> <span class="pre">ReturnType(Args))</span></code>, anziché <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD(ReturnType,</span> <span class="pre">MethodName,</span> <span class="pre">(Args))</span></code>.</p></li>
<li><p>Il numero <code class="docutils literal notranslate"><span class="pre">n</span></code> deve essere uguale al numero di argomenti.</p></li>
<li><p>Quando si crea il mock di un metodo const, è necessario utilizzare <code class="docutils literal notranslate"><span class="pre">MOCK_CONST_METHODn</span></code>.</p></li>
<li><p>Quando si crea il mock di una classe template, il nome della macro deve avere il suffisso <code class="docutils literal notranslate"><span class="pre">_T</span></code>.</p></li>
<li><p>Per specificare il tipo di chiamata, il nome della macro deve avere il suffisso <code class="docutils literal notranslate"><span class="pre">_WITH_CALLTYPE</span></code> e il tipo di chiamata è il primo argomento della macro.</p></li>
</ul>
<p>Le vecchie macro e i loro nuovi equivalenti:</p>
<table>
  <tr><th colspan=2>Simple</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_METHOD1(Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int))</code></td>
  </tr>
  <tr><th colspan=2>Const Method</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_CONST_METHOD1(Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (const))</code></td>
  </tr>
  <tr><th colspan=2>Method in a Class Template</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_METHOD1_T(Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int))</code></td>
  </tr>
  <tr><th colspan=2>Const Method in a Class Template</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_CONST_METHOD1_T(Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (const))</code></td>
  </tr>
  <tr><th colspan=2>Method with Call Type</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))</code></td>
  </tr>
  <tr><th colspan=2>Const Method with Call Type</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_CONST_METHOD1_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))</code></td>
  </tr>
  <tr><th colspan=2>Method with Call Type in a Class Template</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (Calltype(STDMETHODCALLTYPE)))</code></td>
  </tr>
  <tr><th colspan=2>Const Method with Call Type in a Class Template</th></tr>
  <tr>
    <td>Old</td>
    <td><code>MOCK_CONST_METHOD1_T_WITH_CALLTYPE(STDMETHODCALLTYPE, Foo, bool(int))</code></td>
  </tr>
  <tr>
    <td>New</td>
    <td><code>MOCK_METHOD(bool, Foo, (int), (const, Calltype(STDMETHODCALLTYPE)))</code></td>
  </tr>
</table>
</section>
<section id="the-nice-the-strict-and-the-naggy-nicestrictnaggy">
<h4>Nice, Strict e Naggy {#NiceStrictNaggy}<a class="headerlink" href="#the-nice-the-strict-and-the-naggy-nicestrictnaggy" title="Link to this heading">¶</a></h4>
<p>Se un metodo mock non ha specifiche <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> ma viene chiamato, si dice che è una «non interessante» e verrà eseguita l’azione di default (specificabile con <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code>). Attualmente, una chiamata non interessante farà sì che gMock stampi un warning per default.</p>
<p>Tuttavia, a volte si vorrebbero ignorare queste chiamate poco interessanti, altre volte le si vorrebbe trattare come errori. gMock consente di decidere per ciascun oggetto mock.</p>
<p>Supponiamo che il test utilizzi una classe mock <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">mock_foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">());</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">mock_foo</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Se viene chiamato un metodo di <code class="docutils literal notranslate"><span class="pre">mock_foo</span></code> diverso da <code class="docutils literal notranslate"><span class="pre">DoThis()</span></code>, si otterrà un warning. Tuttavia, se si riscrive il test per utilizzare invece <code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code>, si può sopprimere il warning:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NiceMock</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NiceMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mock_foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">());</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">mock_foo</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> è una sottoclasse di <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>, quindi può essere utilizzata ovunque sia accettata <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>.</p>
<p>Funziona anche se il costruttore di <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> accetta alcuni argomenti, poiché <code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> «eredita» i costruttori di <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NiceMock</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NiceMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mock_foo</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;hi&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// Calls MockFoo(5, &quot;hi&quot;).</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">());</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">mock_foo</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>L’utilizzo di <code class="docutils literal notranslate"><span class="pre">StrictMock</span></code> è simile, tranne per il fatto che trasforma tutte le chiamate «non interessanti» in errori:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">StrictMock</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">StrictMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mock_foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">());</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">mock_foo</span><span class="w"> </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// The test will fail if a method of mock_foo other than DoThis()</span>
<span class="w">  </span><span class="c1">// is called.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>{: .callout .note} NOTA: <code class="docutils literal notranslate"><span class="pre">NiceMock</span></code> e <code class="docutils literal notranslate"><span class="pre">StrictMock</span></code> influenzano solo le chiamate <em>non interessanti</em> (chiamate di <em>metodi</em> senza [expectation]); non influenzano le chiamate <em>unexpected</em> (chiamate di metodi con expectation, ma che non corrispondono). Consultare <a class="reference internal" href="#uninteresting-vs-unexpected"><span class="xref myst">Le Chiamate Poco Interessanti e Quelle Unexpected</span></a>.</p>
<p>Ci sono però alcuni avvertimenti (purtroppo sono effetti collaterali delle limitazioni del C++):</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">StrictMock&lt;MockFoo&gt;</span></code> funzionano solo per i metodi mock definiti utilizzando la macro <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> <strong>direttamente</strong> nella classe <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>. Se un metodo mock è definito in una <strong>classe base</strong> di <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>, il modificatore «nice» o «strict» potrebbe non influenzarlo, a seconda del compilatore. In particolare, la nidificazione di <code class="docutils literal notranslate"><span class="pre">NiceMock</span></code> e <code class="docutils literal notranslate"><span class="pre">StrictMock</span></code> (ad esempio <code class="docutils literal notranslate"><span class="pre">NiceMock&lt;StrictMock&lt;MockFoo&gt;</span> <span class="pre">&gt;</span></code>) <strong>non</strong> è supportata.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NiceMock&lt;MockFoo&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">StrictMock&lt;MockFoo&gt;</span></code> potrebbero non funzionare correttamente se il distruttore di <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> non è virtuale. Vorremmo risolvere questo problema, ma è necessario ripulire i test esistenti.</p></li>
</ol>
<p>Infine, si deve porre <strong>molta attenzione</strong> su quando utilizzare mock «naggy» o «strict», poiché tendono a rendere i test più fragili e più difficili da mantenere. Quando si esegue il refactoring del codice senza modificarne il comportamento visibile dall’esterno, idealmente si dovrebbe aver bisogno di aggiornare alcun test. Se il codice interagisce con un mock «naggy», però, si potrebbe iniziare a ricevere notevoli warning come risultato della modifica. Peggio ancora, se il codice interagisce con un mock «strict», i test potrebbero iniziare a fallire e si sarà costretti a correggerli. La nostra raccomandazione generale è quella di utilizzare mock «nice» (non ancora il default) per la maggior parte del tempo, usare mock «naggy» (l’attuale default) durante lo sviluppo o il debug dei test e usare mock «strict» solo come ultima risorsa.</p>
</section>
<section id="simplifying-the-interface-without-breaking-existing-code-simplerinterfaces">
<h4>Semplificare l’Interfaccia senza Compromettere il Codice Esistente {#SimplerInterfaces}<a class="headerlink" href="#simplifying-the-interface-without-breaking-existing-code-simplerinterfaces" title="Link to this heading">¶</a></h4>
<p>A volte un metodo ha un lungo elenco di argomenti che nella maggior parte dei casi non sono interessanti. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">LogSink</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">LogSeverity</span><span class="w"> </span><span class="n">severity</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">full_filename</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">base_filename</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">tm</span><span class="o">*</span><span class="w"> </span><span class="n">tm_time</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">message_len</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>L’elenco degli argomenti di questo metodo è lungo e difficile da gestire (l’argomento <code class="docutils literal notranslate"><span class="pre">message</span></code> non è nemmeno «0-terminated»). Se si crea il mock così com’è, il suo uso risulterà problematico. Se, tuttavia, proviamo a semplificare questa interfaccia, dovremo sistemare tutti i client che dipendono da essa, il che spesso è irrealizzabile.</p>
<p>Il trucco sta nel redistribuire il metodo nella classe mock:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ScopedMockLog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">LogSink</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">LogSeverity</span><span class="w"> </span><span class="n">severity</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">full_filename</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">base_filename</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">tm</span><span class="o">*</span><span class="w"> </span><span class="n">tm_time</span><span class="p">,</span>
<span class="w">                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">message_len</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// We are only interested in the log severity, full file name, and</span>
<span class="w">    </span><span class="c1">// log message.</span>
<span class="w">    </span><span class="n">Log</span><span class="p">(</span><span class="n">severity</span><span class="p">,</span><span class="w"> </span><span class="n">full_filename</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">message_len</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Implements the mock method:</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">//   void Log(LogSeverity severity,</span>
<span class="w">  </span><span class="c1">//            const string&amp; file_path,</span>
<span class="w">  </span><span class="c1">//            const string&amp; message);</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">,</span>
<span class="w">              </span><span class="p">(</span><span class="n">LogSeverity</span><span class="w"> </span><span class="n">severity</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">file_path</span><span class="p">,</span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">message</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Definendo un nuovo metodo mock con un elenco di argomenti ridotto, rendiamo la classe mock più user-friendly.</p>
<p>Questa tecnica può essere applicata anche per facilitare la creazione di mock dei metodi [overloaded]. Ad esempio, quando sono stati utilizzati gli overload per implementare argomenti di default:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockTurtleFactory</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TurtleFactory</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">Turtle</span><span class="o">*</span><span class="w"> </span><span class="n">MakeTurtle</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="n">Turtle</span><span class="o">*</span><span class="w"> </span><span class="n">MakeTurtle</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">weight</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">speed</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// the above methods delegate to this one:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Turtle</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">DoMakeTurtle</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Ciò consente di avere test a cui non interessa quale overload sia stato invocato per evitare di specificare i matcher degli argomenti:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">factory</span><span class="p">,</span><span class="w"> </span><span class="n">DoMakeTurtle</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">MakeMockTurtle</span><span class="p">()));</span>
</pre></div>
</div>
</section>
<section id="alternative-to-mocking-concrete-classes">
<h4>Alternativa ai Mock delle Classi Concrete<a class="headerlink" href="#alternative-to-mocking-concrete-classes" title="Link to this heading">¶</a></h4>
<p>Spesso ci si ritrova a utilizzare classi che non implementano interfacce. Per testare il codice che utilizza una classe di questo tipo (chiamiamola <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>), si potrebbe essere tentati di rendere virtuali i metodi di <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> e crearne il mock.</p>
<p>Cercare di non farlo.</p>
<p>Rendere virtuale una funzione non virtuale è una decisione importante. Si crea un punto di estensione in cui le sottoclassi possono modificare il comportamento della classe. Ciò indebolisce il controllo sulla classe perché ora è più difficile mantenere le invarianti della classe. Si deve rendere virtuale una funzione solo quando esiste un motivo valido per cui una sottoclasse la debba sovrascrivere [override].</p>
<p>Creare direttamente mock di classi concrete è problematico in quanto crea uno stretto accoppiamento tra la classe e i test: qualsiasi piccolo cambiamento nella classe può invalidare i test e rendere difficile la manutenzione dei test.</p>
<p>Per evitare tali problemi, molti programmatori praticano la «codificazione delle interfacce»: invece di parlare con la classe <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>, il codice dovrebbe definire un’interfaccia e comunicare tramite essa. Quindi si implementa l’interfaccia come un adattatore al di sopra di <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>. Nei test, si puoi facilmente creare il mock dell’interfaccia per osservare come sta andando il codice.</p>
<p>Questa tecnica comporta un po” di lavoro:</p>
<ul class="simple">
<li><p>Si paga il costo delle chiamate di funzioni virtuali (di solito non è un problema).</p></li>
<li><p>C’è più astrazione da imparare per i programmatori.</p></li>
</ul>
<p>Tuttavia, si possono anche apportare benefici significativi oltre a una migliore testabilità:</p>
<ul class="simple">
<li><p>L’API di <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> potrebbe non adattarsi molto bene al dominio del problema, poiché si potrebbe non essere l’unico cliente che si tenta di servire. Ne progettare l’interfaccia, si ha la possibilità di adattarla alle proprie esigenze: si possono aggiungere funzionalità di livello superiore, rinominare elementi, ecc. invece di limitarsi a ritagliare la classe. Ciò consente di scrivere il codice (l’utilizzatore dell’interfaccia) in un modo più naturale, il che significa che sarà più leggibile, più gestibile e si sarà più produttivi.</p></li>
<li><p>Se l’implementazione di <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> dovesse cambiare, non sarà necessario riscriverla ovunque venga utilizzata. Al contrario, si possono assorbire le modifiche nell’implementazione dell’interfaccia e l’altro codice e gli altri test saranno isolati da queste modifiche.</p></li>
</ul>
<p>Qualcuno teme che se tutti praticassero questa tecnica, si finirebbe per scrivere molto codice ridondante. Questa preoccupazione è del tutto comprensibile. Tuttavia, ci sono due ragioni per cui potrebbe non essere così:</p>
<ul class="simple">
<li><p>Progetti diversi potrebbero dover utilizzare <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> in modi diversi, quindi le interfacce migliori per loro saranno diverse. Pertanto, ognuno di essi avrà la propria interfaccia specifica del dominio al di sopra di <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>, e non avranno lo stesso codice.</p></li>
<li><p>Se un numero sufficiente di progetti vuole utilizzare la stessa interfaccia, può sempre condividerla, proprio come hanno condiviso <code class="docutils literal notranslate"><span class="pre">Concrete</span></code>. Si può archiviare l’interfaccia e l’adattatore [adaptor] da qualche parte vicino a <code class="docutils literal notranslate"><span class="pre">Concrete</span></code> (probabilmente in una sotto-directory <code class="docutils literal notranslate"><span class="pre">contrib</span></code>) e lasciare che molti progetti la utilizzino.</p></li>
</ul>
<p>Si devono valutare attentamente i pro e i contro per il problema particolare, ma certamente la comunità Java lo pratica da molto tempo ed è una tecnica comprovata ed efficace applicabile in un’ampia varietà di situazioni. :-)</p>
</section>
<section id="delegating-calls-to-a-fake-delegatingtofake">
<h4>Delegare le Chiamate ad una Fake {#DelegatingToFake}<a class="headerlink" href="#delegating-calls-to-a-fake-delegatingtofake" title="Link to this heading">¶</a></h4>
<p>Talvolta si hanno implementazioni [fake] non banali di un’interfaccia. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Foo</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">DoThat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FakeFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="o">:</span>
<span class="w">           </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Ora si vuole creare la mock di questa interfaccia in modo da potervi impostare delle expectation. Tuttavia, si vuole usare anche <code class="docutils literal notranslate"><span class="pre">FakeFoo</span></code> per il comportamento di default, poiché duplicarlo nell’oggetto mock richiede molto lavoro.</p>
<p>Quando si definisce la classe mock utilizzando gMock, si può far sì che deleghi la sua azione di default a una classe fake che già si possiede, utilizzando questo pattern:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Normal mock method definitions using gMock.</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Delegates the default actions of the methods to a FakeFoo object.</span>
<span class="w">  </span><span class="c1">// This must be called *before* the custom ON_CALL() statements.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">DelegateToFake</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ON_CALL</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">fake_</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">ON_CALL</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">fake_</span><span class="p">.</span><span class="n">DoThat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>

<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">FakeFoo</span><span class="w"> </span><span class="n">fake_</span><span class="p">;</span><span class="w">  </span><span class="c1">// Keeps an instance of the fake in the mock.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Con questo si può usare <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> nei test come al solito. Ricordarsi solo che se non si imposta esplicitamente un’azione in una <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code> o in una <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>, la fake verrà chiamato a farlo.:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">AbcTest</span><span class="p">,</span><span class="w"> </span><span class="n">Xyz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>

<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DelegateToFake</span><span class="p">();</span><span class="w">  </span><span class="c1">// Enables the fake for delegation.</span>

<span class="w">  </span><span class="c1">// Put your ON_CALL(foo, ...)s here, if any.</span>

<span class="w">  </span><span class="c1">// No action specified, meaning to use the default action.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">));</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="p">);</span><span class="w">  </span><span class="c1">// FakeFoo::DoThis() is invoked.</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThat</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span><span class="w">  </span><span class="c1">// FakeFoo::DoThat() is invoked.</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Alcuni suggerimenti:</strong></p>
<ul class="simple">
<li><p>Volendo, si può comunque sovrascrivere l’azione di default fornendo la propria <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code> o utilizzando <code class="docutils literal notranslate"><span class="pre">.WillOnce()</span></code> / <code class="docutils literal notranslate"><span class="pre">.WillRepeatedly()</span></code> in <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>.</p></li>
<li><p>In <code class="docutils literal notranslate"><span class="pre">DelegateToFake()</span></code>, si devono solo delegare i metodi di cui si intende utilizzare l’implementazione fake.</p></li>
<li><p>La tecnica generale discussa qui funziona per i metodi [overloaded], ma si dovrà dire al compilatore quale versione si intende. Per chiarire le ambiguità di una funzione mock (quella specificata tra parentesi di <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code>), utilizzare <a class="reference internal" href="#SelectOverload"><span class="xref myst">questa tecnica</span></a>; per disambiguare una funzione fake (quella che si inserisce all’interno di <code class="docutils literal notranslate"><span class="pre">Invoke()</span></code>), usare uno <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> per specificare il tipo della funzione. Ad esempio, se la classe <code class="docutils literal notranslate"><span class="pre">Foo</span></code> ha i metodi <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">DoThis(int</span> <span class="pre">n)</span></code> e <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">DoThis(double</span> <span class="pre">x)</span> <span class="pre">const</span></code>, per invocare quest’ultimo, si deve scrivere <code class="docutils literal notranslate"><span class="pre">Invoke(&amp;fake_,</span> <span class="pre">static_cast&lt;bool</span> <span class="pre">(FakeFoo::*)(double)</span> <span class="pre">const&gt;(&amp;FakeFoo::DoThis))</span></code> invece di <code class="docutils literal notranslate"><span class="pre">Invoke(&amp;fake_,</span> <span class="pre">&amp;FakeFoo::DoThis)</span></code> (La cosa strana all’interno delle parentesi angolari di <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> è il tipo di puntatore a funzione al secondo metodo <code class="docutils literal notranslate"><span class="pre">DoThis()</span></code>).</p></li>
<li><p>Dover mischiare una mock con una fake è spesso un segno che qualcosa è andato storto. Forse non si è ancora abituati al metodo di test basato sull’interazione [interaction-based]. Oppure probabilmente l’interfaccia sta assumendo troppi ruoli e dovrebbe essere suddivisa. Pertanto, <strong>non abusarne</strong>. Consigliamo di farlo solo come passaggio intermedio nell’effettuare il refactoring del codice.</p></li>
</ul>
<p>Per quanto riguarda il suggerimento su come mescolare un mock e un fake, ecco un esempio del perché potrebbe essere un brutto segno: supponiamo di avere una classe <code class="docutils literal notranslate"><span class="pre">System</span></code> per operazioni di sistema di basso livello. In particolare, vengono eseguite operazioni su file e I/O. E supponiamo che si voglia testare come il codice utilizza <code class="docutils literal notranslate"><span class="pre">System</span></code> per eseguire I/O e si voglia semplicemente che le operazioni sui file funzionino normalmente. Se si crea la mock di tutta la classe <code class="docutils literal notranslate"><span class="pre">System</span></code>, si dovrà fornire un’implementazione fake per la parte relativa alle operazioni sui file, il che suggerisce che <code class="docutils literal notranslate"><span class="pre">System</span></code> sta assumendo troppi ruoli.</p>
<p>Si può invece definire un’interfaccia <code class="docutils literal notranslate"><span class="pre">FileOps</span> <span class="pre">e</span> <span class="pre">un'interfaccia</span> </code>IOOps<code class="docutils literal notranslate"><span class="pre">dividendo</span> <span class="pre">le</span> <span class="pre">funzionalità</span> <span class="pre">di</span></code>System<code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">due.</span> <span class="pre">Poi</span> <span class="pre">si</span> <span class="pre">può</span> <span class="pre">creare</span> <span class="pre">la</span> <span class="pre">mock</span> <span class="pre">di</span></code>IOOps<code class="docutils literal notranslate"><span class="pre">senza</span> <span class="pre">avere</span> <span class="pre">un</span> <span class="pre">mock</span> <span class="pre">di</span></code>FileOps`.</p>
</section>
<section id="delegating-calls-to-a-real-object">
<h4>Delegare le Chiamate all’Oggetto Reale<a class="headerlink" href="#delegating-calls-to-a-real-object" title="Link to this heading">¶</a></h4>
<p>Quando si utilizzano copie di test (mock, fake, stub e così via), a volte i loro comportamenti differiranno da quelli degli oggetti reali. Questa differenza potrebbe essere intenzionale (come nella simulazione di un errore in modo da poter testare il codice di gestione degli errori) o involontaria. Se per errore i mock hanno comportamenti diversi rispetto agli oggetti reali, ci si potrebbe ritrovare con un codice che supera i test ma fallisce in produzione.</p>
<p>Si può utilizzare la tecnica <em>delegating-to-real</em> per fare in modo che il mock abbia lo stesso comportamento dell’oggetto reale pur mantenendo la capacità di convalidare le chiamate. Questa tecnica è molto simile alla <a class="reference internal" href="#DelegatingToFake"><span class="xref myst">delegating-to-fake</span></a>, con la differenza che utilizziamo un oggetto reale invece di un fake. Ecco un esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AtLeast</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// By default, all calls are delegated to the real object.</span>
<span class="w">    </span><span class="n">ON_CALL</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">real_</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">ON_CALL</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">real_</span><span class="p">.</span><span class="n">DoThat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="w">  </span><span class="p">...</span>
<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">Foo</span><span class="w"> </span><span class="n">real_</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">mock</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AtLeast</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">mock</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>Con questo, gMock verificherà che il codice abbia effettuato le chiamate giuste (con gli argomenti giusti, nell’ordine giusto, chiamato il numero giusto di volte, ecc.) e un oggetto reale risponderà alle chiamate (quindi il comportamento sarà lo stesso come in produzione). Questo fornisce il meglio di entrambi i mondi.</p>
</section>
<section id="delegating-calls-to-a-parent-class">
<h4>Delegare le Chiamate a una Classe Genitore<a class="headerlink" href="#delegating-calls-to-a-parent-class" title="Link to this heading">¶</a></h4>
<p>Idealmente, si dovrebbero codificare le interfacce, i cui metodi sono tutti puramente virtuali. In realtà, a volte è necessario creare la mock di un metodo virtuale che non è puro (ovvero ha già un’implementazione). Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Foo</span><span class="p">();</span>

<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Pure</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Concrete</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Mocking a pure method.</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Pure</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// Mocking a concrete method.  Foo::Concrete() is shadowed.</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Concrete</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A volte si vorrebbe chiamare <code class="docutils literal notranslate"><span class="pre">Foo::Concrete()</span></code> invece di <code class="docutils literal notranslate"><span class="pre">MockFoo::Concrete()</span></code>. Probabilmente come parte di un’azione stub, o forse il test non ha bisogno del mock di <code class="docutils literal notranslate"><span class="pre">Concrete()</span></code> (ma sarebbe davvero tedioso dover definire una nuova classe mock ogni volta che non è necessario il mock di uno dei suoi metodi).</p>
<p>Si può chiamare <code class="docutils literal notranslate"><span class="pre">Foo::Concrete()</span></code> all’interno di un’azione:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Concrete</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">([</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">Foo</span><span class="o">::</span><span class="n">Concrete</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>
</pre></div>
</div>
<p>oppure dire al mock dell’oggetto che non si vuole il mock di <code class="docutils literal notranslate"><span class="pre">Concrete()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="w">  </span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Concrete</span><span class="p">).</span><span class="n">WillByDefault</span><span class="p">([</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">Foo</span><span class="o">::</span><span class="n">Concrete</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="w">  </span><span class="p">});</span>
</pre></div>
</div>
<p>(Perché non scrivere semplicemente <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">return</span> <span class="pre">foo.Concrete(str);</span> <span class="pre">}</span></code>? Se lo si fa, verrà chiamato <code class="docutils literal notranslate"><span class="pre">MockFoo::Concrete()</span></code> (provocando una ricorsione infinita) in quanto <code class="docutils literal notranslate"><span class="pre">Foo::Concrete()</span></code> è virtuale. È così che funziona il C++).</p>
</section>
</section>
<section id="using-matchers">
<h3>Uso dei Matcher<a class="headerlink" href="#using-matchers" title="Link to this heading">¶</a></h3>
<section id="matching-argument-values-exactly">
<h4>Matching Esatto dei Valori degli Argomenti<a class="headerlink" href="#matching-argument-values-exactly" title="Link to this heading">¶</a></h4>
<p>Si può specificare esattamente quali argomenti si aspetta un metodo mock:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">bar</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="using-simple-matchers">
<h4>Uso di Semplici Matcher<a class="headerlink" href="#using-simple-matchers" title="Link to this heading">¶</a></h4>
<p>I matcher si possono usare per abbinare [match] argomenti che hanno una certa proprietà:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NotNull</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span><span class="w">  </span><span class="c1">// The argument must be &gt;= 5.</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">NotNull</span><span class="p">()));</span>
<span class="w">      </span><span class="c1">// The second argument must not be NULL.</span>
</pre></div>
</div>
<p>Un matcher usato spesso è <code class="docutils literal notranslate"><span class="pre">_</span></code>, che corrisponde a qualsiasi cosa:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">NotNull</span><span class="p">()));</span>
</pre></div>
</div>
</section>
<section id="combining-matchers-combiningmatchers">
<h4>Combinazione di Matcher {#CombiningMatchers}<a class="headerlink" href="#combining-matchers-combiningmatchers" title="Link to this heading">¶</a></h4>
<p>Si possono creare abbinamenti complessi da quelli esistenti utilizzando <code class="docutils literal notranslate"><span class="pre">AllOf()</span></code>, <code class="docutils literal notranslate"><span class="pre">AllOfArray()</span></code>, <code class="docutils literal notranslate"><span class="pre">AnyOf()</span></code>, <code class="docutils literal notranslate"><span class="pre">AnyOfArray()</span></code> e <code class="docutils literal notranslate"><span class="pre">Not()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">HasSubstr</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ne</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Not</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// The argument must be &gt; 5 and != 10.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="n">AllOf</span><span class="p">(</span><span class="n">Gt</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="w">                                </span><span class="n">Ne</span><span class="p">(</span><span class="mi">10</span><span class="p">))));</span>

<span class="w">  </span><span class="c1">// The first argument must not contain sub-string &quot;blah&quot;.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">HasSubstr</span><span class="p">(</span><span class="s">&quot;blah&quot;</span><span class="p">)),</span>
<span class="w">                          </span><span class="nb">NULL</span><span class="p">));</span>
</pre></div>
</div>
<p>I matcher sono oggetti funzione e quelli parametrizzati possono essere composti proprio come qualsiasi altra funzione. However because their types can be long and rarely provide meaningful information, it can be easier to express them with template parameters and <code class="docutils literal notranslate"><span class="pre">auto</span></code>. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Contains</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Property</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">SubMatcher</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">HasFoo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SubMatcher</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sub_matcher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Property</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Contains</span><span class="p">(</span><span class="n">sub_matcher</span><span class="p">));</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">HasFoo</span><span class="p">(</span><span class="s">&quot;blah&quot;</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="casting-matchers-safematchercast">
<h4>Casting dei Matcher {#SafeMatcherCast}<a class="headerlink" href="#casting-matchers-safematchercast" title="Link to this heading">¶</a></h4>
<p>I matcher di gMock sono tipizzati staticamente, il che significa che il compilatore può individuare l’errore se si usa un matcher del tipo sbagliato (ad esempio, se si usa <code class="docutils literal notranslate"><span class="pre">Eq(5)</span></code> per trovare una corrispondenza con un argomento <code class="docutils literal notranslate"><span class="pre">string</span></code>). Una cosa buona!</p>
<p>A volte, però, sapendo cosa si fa, si vuole che il compilatore dia un po” di tregua. Un esempio è che si abbia un matcher per <code class="docutils literal notranslate"><span class="pre">long</span></code> e l’argomento che si vuol trovare è <code class="docutils literal notranslate"><span class="pre">int</span></code>. Sebbene i due tipi non siano esattamente gli stessi, non c’è niente di veramente sbagliato nell’usare un <code class="docutils literal notranslate"><span class="pre">Matcher&lt;long&gt;</span></code> per abbinare un <code class="docutils literal notranslate"><span class="pre">int</span></code> - dopo tutto, possiamo convertire prima l’argomento <code class="docutils literal notranslate"><span class="pre">int</span></code> in un <code class="docutils literal notranslate"><span class="pre">long</span></code> senza perdere informazioni prima di passarlo al matcher.</p>
<p>Per supportare questa esigenza, gMock offre la funzione <code class="docutils literal notranslate"><span class="pre">SafeMatcherCast&lt;T&gt;(m)</span></code>. Si effettua il cast di un matcher <code class="docutils literal notranslate"><span class="pre">m</span></code> nel tipo <code class="docutils literal notranslate"><span class="pre">Matcher&lt;T&gt;</span></code>. Per garantire la sicurezza, gMock verifica che sia <code class="docutils literal notranslate"><span class="pre">U</span></code> il tipo accettato da <code class="docutils literal notranslate"><span class="pre">m</span></code>:</p>
<ol class="arabic simple">
<li><p>Il tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> può essere convertito [cast] <em>implicitamente</em> nel tipo <code class="docutils literal notranslate"><span class="pre">U</span></code>;</p></li>
<li><p>Quando sia <code class="docutils literal notranslate"><span class="pre">T</span></code> che <code class="docutils literal notranslate"><span class="pre">U</span></code> sono tipi aritmetici nativi (<code class="docutils literal notranslate"><span class="pre">bool</span></code>, integer e numeri in virgola mobile), la conversione da <code class="docutils literal notranslate"><span class="pre">T</span></code> a <code class="docutils literal notranslate"><span class="pre">U</span></code> è senza perdita di informazioni (in altre parole, qualsiasi valore rappresentabile da <code class="docutils literal notranslate"><span class="pre">T</span></code> può essere rappresentato da <code class="docutils literal notranslate"><span class="pre">U</span></code>); e</p></li>
<li><p>When <code class="docutils literal notranslate"><span class="pre">U</span></code> is a non-const reference, <code class="docutils literal notranslate"><span class="pre">T</span></code> must also be a reference (as the
underlying matcher may be interested in the address of the <code class="docutils literal notranslate"><span class="pre">U</span></code> value).</p></li>
</ol>
<p>Il codice non verrà compilato se una di queste condizioni non viene soddisfatta.</p>
<p>Ecco un esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SafeMatcherCast</span><span class="p">;</span>

<span class="c1">// A base class and a child class.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Derived</span><span class="o">*</span><span class="w"> </span><span class="n">derived</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// m is a Matcher&lt;Base*&gt; we got from somewhere.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="n">SafeMatcherCast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">)));</span>
</pre></div>
</div>
<p>Se si ritiene la <code class="docutils literal notranslate"><span class="pre">SafeMatcherCast&lt;T&gt;(m)</span></code> troppo limitante, si può usare una funzione simile <code class="docutils literal notranslate"><span class="pre">MatcherCast&lt;T&gt;(m)</span></code>. La differenza è che <code class="docutils literal notranslate"><span class="pre">MatcherCast</span></code> funziona fin quando si può eseguire lo <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> del tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> nel tipo <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">MatcherCast</span></code> consente essenzialmente di aggirare il sistema di tipi di C++ (<code class="docutils literal notranslate"><span class="pre">static_cast</span></code> non è sempre sicuro in quanto potrebbe eliminare informazioni, ad esempio), si faccia quindi attenzione a non abusarne.</p>
</section>
<section id="selecting-between-overloaded-functions-selectoverload">
<h4>Scegliere le Funzioni Overloaded {#SelectOverload}<a class="headerlink" href="#selecting-between-overloaded-functions-selectoverload" title="Link to this heading">¶</a></h4>
<p>Se ci si aspetta che venga chiamata una funzione overloaded, il compilatore potrebbe aver bisogno di aiuto sulla scelta della versione.</p>
<p>Per chiarire le ambiguità delle funzioni overloaded tramite l’essere const di questo oggetto, si usa l’argomento wrapper di <code class="docutils literal notranslate"><span class="pre">Const()</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ReturnRef</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">GetBar</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">GetBar</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">Bar</span><span class="w"> </span><span class="n">bar1</span><span class="p">,</span><span class="w"> </span><span class="n">bar2</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">GetBar</span><span class="p">())</span><span class="w">         </span><span class="c1">// The non-const GetBar().</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">bar1</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">Const</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="n">GetBar</span><span class="p">())</span><span class="w">  </span><span class="c1">// The const GetBar().</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">bar2</span><span class="p">));</span>
</pre></div>
</div>
<p>(<code class="docutils literal notranslate"><span class="pre">Const()</span></code> è definito da gMock e restituisce un riferimento <code class="docutils literal notranslate"><span class="pre">const</span></code> al suo argomento).</p>
<p>Per chiarire le ambiguità delle funzioni overloaded con lo stesso numero di argomenti ma tipi di argomento diversi, potrebbe essere necessario specificare il tipo esatto di un matcher, racchiudendolo in <code class="docutils literal notranslate"><span class="pre">Matcher&lt;type&gt;()</span></code> o utilizzando un matcher il cui tipo è fisso (<code class="docutils literal notranslate"><span class="pre">TypedEq&lt;type&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">An&lt;type&gt;()</span></code>, ecc.):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">An</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">TypedEq</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockPrinter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Printer</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Print</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Print</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">PrinterTest</span><span class="p">,</span><span class="w"> </span><span class="n">Print</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MockPrinter</span><span class="w"> </span><span class="n">printer</span><span class="p">;</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="n">Print</span><span class="p">(</span><span class="n">An</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()));</span><span class="w">            </span><span class="c1">// void Print(int);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="n">Print</span><span class="p">(</span><span class="n">Matcher</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Lt</span><span class="p">(</span><span class="mi">5</span><span class="p">))));</span><span class="w">  </span><span class="c1">// void Print(int);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="n">Print</span><span class="p">(</span><span class="n">TypedEq</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)));</span><span class="w">   </span><span class="c1">// void Print(char);</span>

<span class="w">  </span><span class="n">printer</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="n">printer</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="w">  </span><span class="n">printer</span><span class="p">.</span><span class="n">Print</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="performing-different-actions-based-on-the-arguments">
<h4>Eseguire Azioni Diverse in Base agli Argomenti<a class="headerlink" href="#performing-different-actions-based-on-the-arguments" title="Link to this heading">¶</a></h4>
<p>Quando viene chiamato un metodo mock, verrà selezionato l”<em>ultimo</em> matching expectation ancora attiva (si pensi che «il più recente sovrascrive il più vecchio»). Quindi, si può fare in modo che un metodo faccia cose diverse a seconda dei valori dei suoi argomenti in questo modo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Lt</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// The default case.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="sc">&#39;b&#39;</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// The more specific case.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="n">Lt</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">));</span>
</pre></div>
</div>
<p>Ora, se <code class="docutils literal notranslate"><span class="pre">foo.DoThis()</span></code> viene chiamato con un valore inferiore a 5, verrà restituito <code class="docutils literal notranslate"><span class="pre">'a'</span></code>; altrimenti verrà restituito <code class="docutils literal notranslate"><span class="pre">'b'</span></code>.</p>
</section>
<section id="matching-multiple-arguments-as-a-whole">
<h4>Corrispondenza di Più Argomenti come un Tutt’uno<a class="headerlink" href="#matching-multiple-arguments-as-a-whole" title="Link to this heading">¶</a></h4>
<p>A volte non è sufficiente abbinare [match] gli argomenti individualmente. Ad esempio, potremmo voler dire che il primo argomento deve essere minore del secondo argomento. La clausola <code class="docutils literal notranslate"><span class="pre">With()</span></code> ci consente di abbinare tutti gli argomenti di una funzione mock nel suo insieme. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ne</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Lt</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">InRange</span><span class="p">(</span><span class="n">Ne</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">With</span><span class="p">(</span><span class="n">Lt</span><span class="p">());</span>
</pre></div>
</div>
<p>dice che il primo argomento di <code class="docutils literal notranslate"><span class="pre">InRange()</span></code> non deve essere 0 e deve essere minore del secondo argomento.</p>
<p>L’espressione in <code class="docutils literal notranslate"><span class="pre">With()</span></code> dev’essere un matcher del tipo <code class="docutils literal notranslate"><span class="pre">Matcher&lt;std::tuple&lt;A1,</span> <span class="pre">...,</span> <span class="pre">An&gt;&gt;</span></code>, dove <code class="docutils literal notranslate"><span class="pre">A1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">An</span></code> sono i tipi degli argomenti della funzione.</p>
<p>Si può anche scrivere <code class="docutils literal notranslate"><span class="pre">AllArgs(m)</span></code> invece di <code class="docutils literal notranslate"><span class="pre">m</span></code> in <code class="docutils literal notranslate"><span class="pre">.With()</span></code>. Le due forme sono equivalenti, ma <code class="docutils literal notranslate"><span class="pre">.With(AllArgs(Lt()))</span></code> è più leggibile di <code class="docutils literal notranslate"><span class="pre">.With(Lt())</span></code>.</p>
<p>Si può usare <code class="docutils literal notranslate"><span class="pre">Args&lt;k1,</span> <span class="pre">...,</span> <span class="pre">kn&gt;(m)</span></code> per far corrispondere gli <code class="docutils literal notranslate"><span class="pre">n</span></code> argomenti selezionati (come una tupla) con <code class="docutils literal notranslate"><span class="pre">m</span></code>. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Args</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Lt</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Blah</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">With</span><span class="p">(</span><span class="n">AllOf</span><span class="p">(</span><span class="n">Args</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Lt</span><span class="p">()),</span><span class="w"> </span><span class="n">Args</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Lt</span><span class="p">())));</span>
</pre></div>
</div>
<p>dice che <code class="docutils literal notranslate"><span class="pre">Blah</span></code> verrà chiamato con gli argomenti <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, e <code class="docutils literal notranslate"><span class="pre">z</span></code> dove <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">z</span></code>. Si noti che in questo esempio, non è stato necessario specificare i matcher posizionali.</p>
<p>Per comodità ed esempio, gMock fornisce alcuni matcher per 2-tuple, incluso il matcher <code class="docutils literal notranslate"><span class="pre">Lt()</span></code> precedente. Consultare <a class="reference internal" href="#reference/matchers.md#MultiArgMatchers"><span class="xref myst">Multi-argument Matchers</span></a> per la lista completa.</p>
<p>Si noti che per passare gli argomenti a un proprio predicato (p.es. <code class="docutils literal notranslate"><span class="pre">.With(Args&lt;0,</span> <span class="pre">1&gt;(Truly(&amp;MyPredicate)))</span></code>), quel predicato DEVE essere scritto per accettare un <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> come argomento; gMock passerà gli <code class="docutils literal notranslate"><span class="pre">n</span></code> argomenti selezionati come <em>una</em> singola tupla al predicato.</p>
</section>
<section id="using-matchers-as-predicates">
<h4>Usare i Matcher come Predicati<a class="headerlink" href="#using-matchers-as-predicates" title="Link to this heading">¶</a></h4>
<p>Si è notato che un matcher è solo un fantasioso predicato che sa anche come descrivere se stesso? Molti algoritmi esistenti accettano predicati come argomenti (ad esempio quelli definiti nell’header <code class="docutils literal notranslate"><span class="pre">&lt;algorithm&gt;</span></code> di STL) e sarebbe un peccato se ai matcher gMock non fosse consentito partecipare.</p>
<p>Fortunatamente, si può utilizzare un matcher in cui è previsto un funtore del predicato unario racchiudendolo nella funzione <code class="docutils literal notranslate"><span class="pre">Matches()</span></code>. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matches</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// How many elements in v are &gt;= 10?</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">Matches</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">10</span><span class="p">)));</span>
</pre></div>
</div>
<p>Dal momento che si possono creare facilmente matcher complessi da quelli più semplici utilizzando gMock, questo fornisce un modo per costruire comodamente predicati compositi (fare lo stesso usando l’header <code class="docutils literal notranslate"><span class="pre">&lt;functional&gt;</span></code> di STL è semplicemente complicato). Per esempio, ecco un predicato soddisfatto da qualsiasi numero &gt;= 0, &lt;= 100 e != 50:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Le</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matches</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ne</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Matches</span><span class="p">(</span><span class="n">AllOf</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">Le</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span><span class="w"> </span><span class="n">Ne</span><span class="p">(</span><span class="mi">50</span><span class="p">)))</span>
</pre></div>
</div>
</section>
<section id="using-matchers-in-googletest-assertions">
<h4>Uso dei Matcher nelle Asserzioni di googletest<a class="headerlink" href="#using-matchers-in-googletest-assertions" title="Link to this heading">¶</a></h4>
<p>Vedere <a class="reference internal" href="#reference/assertions.md#EXPECT_THAT"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_THAT</span></code></span></a> nelle «Asserzioni di Eccezioni».</p>
</section>
<section id="using-predicates-as-matchers">
<h4>Uso dei Predicati come Matcher<a class="headerlink" href="#using-predicates-as-matchers" title="Link to this heading">¶</a></h4>
<p>gMock fornisce un insieme di matcher nativi per far corrispondere gli argomenti con i valori attesi: per ulteriori informazioni consultare i <a class="reference internal" href="#reference/matchers.md"><span class="xref myst">Riferimenti ai Matcher</span></a>. Nel caso in cui si trovi carente il set nativo, si può utilizzare una funzione di predicato unario arbitrario o un funtore come matcher, purché il predicato accetti un valore del tipo desiderato. Lo si può fare racchiudendo il predicato all’interno della funzione <code class="docutils literal notranslate"><span class="pre">Truly()</span></code>, per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Truly</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">IsEven</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// Bar() must be called with an even number.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">Truly</span><span class="p">(</span><span class="n">IsEven</span><span class="p">)));</span>
</pre></div>
</div>
<p>Notare che la funzione/funtore del predicato non deve restituire <code class="docutils literal notranslate"><span class="pre">bool</span></code>. Funziona fin quando il valore restituito può essere utilizzato come condizione nell’istruzione <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(condition)</span> <span class="pre">...</span></code>.</p>
</section>
<section id="matching-arguments-that-are-not-copyable">
<h4>Match di Argomenti che Non Sono Copiabili<a class="headerlink" href="#matching-arguments-that-are-not-copyable" title="Link to this heading">¶</a></h4>
<p>Quando si esegue un <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(mock_obj,</span> <span class="pre">Foo(bar))</span></code>, gMock salva una copia di <code class="docutils literal notranslate"><span class="pre">bar</span></code>. Quando <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> viene chiamato in seguito, gMock confronta l’argomento di <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> con la copia salvata di <code class="docutils literal notranslate"><span class="pre">bar</span></code>. In questo modo, non ci si deve preoccupare che la <code class="docutils literal notranslate"><span class="pre">bar</span></code> venga modificata o distrutta dopo l’esecuzione di <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>. Lo stesso vale quando si usano matcher come <code class="docutils literal notranslate"><span class="pre">Eq(bar)</span></code>, <code class="docutils literal notranslate"><span class="pre">Le(bar)</span></code> e così via.</p>
<p>Ma cosa succede se <code class="docutils literal notranslate"><span class="pre">bar</span></code> non può essere copiato (cioè non ha un costruttore di copia)? Si potrebbe definire la propria funzione matcher o callback e usarla con <code class="docutils literal notranslate"><span class="pre">Truly()</span></code>, come mostrato nelle due ricette precedenti. Oppure si potrebbe riuscire a evitarlo se se si garantisce che la <code class="docutils literal notranslate"><span class="pre">bar</span></code> non verrà modificata dopo l’esecuzione di <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>. Basta dire a gMock che dovrebbe salvare un riferimento a <code class="docutils literal notranslate"><span class="pre">bar</span></code>, invece di una sua copia. Ecco come:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Eq</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Lt</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// Expects that Foo()&#39;s argument == bar.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_obj</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">bar</span><span class="p">))));</span>

<span class="w">  </span><span class="c1">// Expects that Foo()&#39;s argument &lt; bar.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_obj</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">Lt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">bar</span><span class="p">))));</span>
</pre></div>
</div>
<p>Da ricordare: se lo si fa, non modificare <code class="docutils literal notranslate"><span class="pre">bar</span></code> dopo la <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>, altrimenti il risultato non sarà definito.</p>
</section>
<section id="validating-a-member-of-an-object">
<h4>Validare un Membro di un Oggetto<a class="headerlink" href="#validating-a-member-of-an-object" title="Link to this heading">¶</a></h4>
<p>Spesso una funzione mock accetta un riferimento all’oggetto come argomento. Quando si esegue il matching di argomenti, si potrebbe non voler confrontare l’intero oggetto con un oggetto fisso, poiché ciò potrebbe essere eccessivo. Potrebbe invece essere necessario validare una determinata variabile membro o il risultato di un determinato metodo getter dell’oggetto. Lo si può fare con <code class="docutils literal notranslate"><span class="pre">Field()</span></code> e con <code class="docutils literal notranslate"><span class="pre">Property()</span></code>. Più specificamente,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Field</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>è un matcher che corrisponde a un oggetto <code class="docutils literal notranslate"><span class="pre">Foo</span></code> la cui variabile membro <code class="docutils literal notranslate"><span class="pre">bar</span></code> soddisfa il matcher <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Property</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">baz</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>è un matcher che corrisponde a un oggetto <code class="docutils literal notranslate"><span class="pre">Foo</span></code> il cui metodo <code class="docutils literal notranslate"><span class="pre">baz()</span></code> restituisce un valore che soddisfa il matcher <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p>Per esempio:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-left"><p>Espressione</p></th>
<th class="head text-left"><p>Descrizione</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">Field(&amp;Foo::number,</span> <span class="pre">Ge(3))</span></code></p></td>
<td class="text-left"><p>Corrisponde a <code class="docutils literal notranslate"><span class="pre">x</span></code> dove <code class="docutils literal notranslate"><span class="pre">x.number</span> <span class="pre">&gt;=</span> <span class="pre">3</span></code>.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">Property(&amp;Foo::name,</span>&#160; <span class="pre">StartsWith(&quot;John</span> <span class="pre">&quot;))</span></code></p></td>
<td class="text-left"><p>Corrisponde a <code class="docutils literal notranslate"><span class="pre">x</span></code> dove <code class="docutils literal notranslate"><span class="pre">x.name()</span></code> inizia con <code class="docutils literal notranslate"><span class="pre">&quot;John</span> <span class="pre">&quot;</span></code>.</p></td>
</tr>
</tbody>
</table>
<p>Notare che in <code class="docutils literal notranslate"><span class="pre">Property(&amp;Foo::baz,</span> <span class="pre">...)</span></code>, il metodo <code class="docutils literal notranslate"><span class="pre">baz()</span></code> non deve accettare argomenti ed essere dichiarato come <code class="docutils literal notranslate"><span class="pre">const</span></code>. Non usare <code class="docutils literal notranslate"><span class="pre">Property()</span></code> contro funzioni membro che non si possiedono, perché prendere gli indirizzi delle funzioni è «fragile» e generalmente non fa parte del contratto della funzione.</p>
<p><code class="docutils literal notranslate"><span class="pre">Field()</span></code> e <code class="docutils literal notranslate"><span class="pre">Property()</span></code> possono anche eseguire il match di semplici puntatori a oggetti. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Field</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Field</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">number</span><span class="p">,</span><span class="w"> </span><span class="n">Ge</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>corrisponde a un semplice puntatore <code class="docutils literal notranslate"><span class="pre">p</span></code> dove <code class="docutils literal notranslate"><span class="pre">p-&gt;number</span> <span class="pre">&gt;=</span> <span class="pre">3</span></code>. Se <code class="docutils literal notranslate"><span class="pre">p</span></code> è <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, il match fallirà sempre indipendentemente dal matcher interno.</p>
<p>Cosa succede se si validano più di un membro contemporaneamente? Si ricorda che ci sono <a class="reference internal" href="#CombiningMatchers"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">AllOf()</span></code> e <code class="docutils literal notranslate"><span class="pre">AllOfArray()</span></code></span></a>.</p>
<p>Infine <code class="docutils literal notranslate"><span class="pre">Field()</span></code> e <code class="docutils literal notranslate"><span class="pre">Property()</span></code> forniscono gli overload che accettano i nomi del campo o della proprietà come primo argomento per includerlo nel messaggio di errore. Questo può essere utile quando si creano matcher combinati.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Field</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SafeMatcherCast</span><span class="p">;</span>

<span class="n">Matcher</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IsFoo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">AllOf</span><span class="p">(</span><span class="n">Field</span><span class="p">(</span><span class="s">&quot;some_field&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">some_field</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">some_field</span><span class="p">),</span>
<span class="w">               </span><span class="n">Field</span><span class="p">(</span><span class="s">&quot;other_field&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">other_field</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">other_field</span><span class="p">),</span>
<span class="w">               </span><span class="n">Field</span><span class="p">(</span><span class="s">&quot;last_field&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">last_field</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">last_field</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="validating-the-value-pointed-to-by-a-pointer-argument">
<h4>Validare il Valore Puntato da un Argomento Puntatore<a class="headerlink" href="#validating-the-value-pointed-to-by-a-pointer-argument" title="Link to this heading">¶</a></h4>
<p>Le funzioni C++ spesso accettano puntatori come argomenti. Si possono usare matcher come <code class="docutils literal notranslate"><span class="pre">IsNull()</span></code>, <code class="docutils literal notranslate"><span class="pre">NotNull()</span></code> e altri per avere una corrispondenza con un puntatore, ma cosa succede se ci si vuol accertare che il valore <em>puntato</em> dal puntatore, anziché il puntatore stesso, ha una certa proprietà? Ebbene, si può usare il matcher <code class="docutils literal notranslate"><span class="pre">Pointee(m)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Pointee(m)</span></code> esegue il matching di un puntatore se e solo se <code class="docutils literal notranslate"><span class="pre">m</span></code> corrisponde al valore a cui punta il puntatore. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Ge</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Pointee</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">Pointee</span><span class="p">(</span><span class="n">Ge</span><span class="p">(</span><span class="mi">3</span><span class="p">))));</span>
</pre></div>
</div>
<p>si aspetta che <code class="docutils literal notranslate"><span class="pre">foo.Bar()</span></code> venga chiamato con un puntatore che punta a un valore maggiore o uguale a 3.</p>
<p>Una cosa bella di <code class="docutils literal notranslate"><span class="pre">Pointee()</span></code> è che tratta un puntatore <code class="docutils literal notranslate"><span class="pre">NULL</span></code> come una corrispondenza fallita, quindi si può scrivere <code class="docutils literal notranslate"><span class="pre">Pointee(m)</span></code> anziché</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NotNull</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Pointee</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">AllOf</span><span class="p">(</span><span class="n">NotNull</span><span class="p">(),</span><span class="w"> </span><span class="n">Pointee</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
</pre></div>
</div>
<p>senza preoccuparsi che un puntatore <code class="docutils literal notranslate"><span class="pre">NULL</span></code> mandi in crash il test.</p>
<p>Inoltre, abbiamo detto che <code class="docutils literal notranslate"><span class="pre">Pointee()</span></code> funziona sia con puntatori [raw] <strong>sia con</strong> puntatori smart (<code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code>, ecc.)?</p>
<p>Cosa succede se si ha un puntatore a puntatore? Indovinato - si può usare <code class="docutils literal notranslate"><span class="pre">Pointee()</span></code> nidificato “scavare” più a fondo il valore. Per esempio, <code class="docutils literal notranslate"><span class="pre">Pointee(Pointee(Lt(3)))</span></code> corrisponde a un puntatore che punta a un puntatore che punta a un numero inferiore a 3 (che salti…).</p>
</section>
<section id="defining-a-custom-matcher-class-custommatcherclass">
<h4>Definizione di una Classe Matcher Custom {#CustomMatcherClass}<a class="headerlink" href="#defining-a-custom-matcher-class-custommatcherclass" title="Link to this heading">¶</a></h4>
<p>La maggior parte dei matcher può essere definita semplicemente utilizzando <a class="reference internal" href="#NewMatchers"><span class="xref myst">le macro MATCHER*</span></a>, che sono concise e flessibili e producono buoni messaggi di errore. Tuttavia, queste macro non sono molto esplicite riguardo alle interfacce che creano e non sono sempre adatte, soprattutto per i matcher che verranno ampiamente riutilizzati.</p>
<p>Per i casi più avanzati, potrebbe essere necessario definire la propria classe matcher. Un matcher custom consente di testare una proprietà invariante specifica di quell’oggetto. Vediamo come farlo.</p>
<p>Immaginiamo di avere una funzione mock che accetta un oggetto di tipo <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, che ha un metodo <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">bar()</span></code> e un metodo <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">baz()</span></code>. Si vuol vincolare il fatto che il valore dell’argomento di <code class="docutils literal notranslate"><span class="pre">bar()</span></code> più il valore del suo <code class="docutils literal notranslate"><span class="pre">baz()</span></code> sia un certo numero. (Questo è un invariante). Ecco come possiamo scrivere e utilizzare una classe matcher per farlo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">BarPlusBazEqMatcher</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">is_gtest_matcher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="p">;</span>

<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">BarPlusBazEqMatcher</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">expected_sum</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">expected_sum_</span><span class="p">(</span><span class="n">expected_sum</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">MatchAndExplain</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span>
<span class="w">                       </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="cm">/* listener */</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">foo</span><span class="p">.</span><span class="n">baz</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">expected_sum_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;bar() + baz() equals &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">expected_sum_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;bar() + baz() does not equal &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">expected_sum_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">expected_sum_</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Foo</span><span class="o">&amp;&gt;</span><span class="w"> </span><span class="n">BarPlusBazEq</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">expected_sum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">BarPlusBazEqMatcher</span><span class="p">(</span><span class="n">expected_sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">Foo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">BarPlusBazEq</span><span class="p">(</span><span class="mi">5</span><span class="p">))...;</span>
</pre></div>
</div>
</section>
<section id="matching-containers">
<h4>Il Matching dei Contenitori<a class="headerlink" href="#matching-containers" title="Link to this heading">¶</a></h4>
<p>A volte un container STL (ad esempio lista, vettore, mappa, …) viene passato a una funzione mock e lo si vorrebbe convalidare. Poiché la maggior parte dei container STL supportano l’operatore <code class="docutils literal notranslate"><span class="pre">==</span></code>, si può scrivere <code class="docutils literal notranslate"><span class="pre">Eq(expected_container)</span></code> o semplicemente <code class="docutils literal notranslate"><span class="pre">expected_container</span></code> per verificare esattamente un container.</p>
<p>A volte, però, si necessita di una maggiore flessibilità (ad esempio, il primo elemento deve corrispondere esattamente, ma il secondo elemento può essere qualsiasi numero positivo e così via). Inoltre, i container utilizzati nei test hanno spesso un numero limitato di elementi e doverli definire [out-of-line] è un po” complicato.</p>
<p>In questi casi si può utilizzare il matcher <code class="docutils literal notranslate"><span class="pre">ElementsAre()</span></code> o <code class="docutils literal notranslate"><span class="pre">UnorderedElementsAre()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ElementsAre</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">numbers</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">ElementsAre</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Gt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span>
</pre></div>
</div>
<p>Il matcher sopra dice che il container deve avere 4 elementi, che devono essere rispettivamente 1, maggiore di 0, qualsiasi cosa e 5.</p>
<p>Se invece si scrive:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">UnorderedElementsAre</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">numbers</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">UnorderedElementsAre</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Gt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span>
</pre></div>
</div>
<p>Significa che il container deve avere 4 elementi, che (con qualche permutazione) devono essere rispettivamente 1, maggiore di 0, qualsiasi cosa e 5.</p>
<p>In alternativa si possono inserire gli argomenti in un array in stile C e utilizzare invece <code class="docutils literal notranslate"><span class="pre">ElementsAreArray()</span></code> o <code class="docutils literal notranslate"><span class="pre">UnorderedElementsAreArray()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ElementsAreArray</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// ElementsAreArray accepts an array of element values.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">expected_vector1</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="p">...};</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">ElementsAreArray</span><span class="p">(</span><span class="n">expected_vector1</span><span class="p">)));</span>

<span class="w">  </span><span class="c1">// Or, an array of element matchers.</span>
<span class="w">  </span><span class="n">Matcher</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">expected_vector2</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Gt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">...};</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">ElementsAreArray</span><span class="p">(</span><span class="n">expected_vector2</span><span class="p">)));</span>
</pre></div>
</div>
<p>Nel caso in cui l’array debba essere creato dinamicamente (e quindi la dimensione dell’array non possa essere dedotta dal compilatore), si può fornire a <code class="docutils literal notranslate"><span class="pre">ElementsAreArray()</span></code> un argomento aggiuntivo per specificare la dimensione dell’array:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ElementsAreArray</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">expected_vector3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">fill</span><span class="w"> </span><span class="n">expected_vector3</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="n">ElementsAreArray</span><span class="p">(</span><span class="n">expected_vector3</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">)));</span>
</pre></div>
</div>
<p>Si usa <code class="docutils literal notranslate"><span class="pre">Pair</span></code> quando si confrontano mappe o altri container associativi.</p>
<p>{% raw %}</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">UnorderedElementsAre</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Pair</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">absl</span><span class="o">::</span><span class="n">flat_hash_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{{</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}};</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">UnorderedElementsAre</span><span class="p">(</span>
<span class="w">      </span><span class="n">Pair</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">Pair</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">Pair</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)));</span>
</pre></div>
</div>
<p>{% endraw %}</p>
<p><strong>Suggerimenti:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ElementsAre*()</span></code> è utilizzabile per [to match] <em>qualsiasi</em> container che implementi il pattern dell’iteratore STL (ovvero ha un tipo <code class="docutils literal notranslate"><span class="pre">const_iterator</span></code> e supporta <code class="docutils literal notranslate"><span class="pre">begin()/end()</span></code>), non solo quelli definiti in STL. Funzionerà anche con i tipi di container ancora da scrivere, purché seguano lo schema sopra riportato.</p></li>
<li><p>Si possono usare <code class="docutils literal notranslate"><span class="pre">ElementsAre*()</span></code> nidificati per [to match] container nidificati (multi-dimensionali).</p></li>
<li><p>Se il container viene passato tramite puntatore anziché per riferimento, si scrive semplicemente <code class="docutils literal notranslate"><span class="pre">Pointee(ElementsAre*(...))</span></code>.</p></li>
<li><p>L’ordine degli elementi <em>è importante</em> per <code class="docutils literal notranslate"><span class="pre">ElementsAre*()</span></code>. Se lo si sta utilizzando con contenitori il cui ordine degli elementi non è definito (come <code class="docutils literal notranslate"><span class="pre">std::unordered_map</span></code>) si deve utilizzare <code class="docutils literal notranslate"><span class="pre">UnorderedElementsAre</span></code>.</p></li>
</ul>
</section>
<section id="sharing-matchers">
<h4>Matcher Condivisi<a class="headerlink" href="#sharing-matchers" title="Link to this heading">¶</a></h4>
<p>Internamente, un oggetto matcher gMock è costituito da un puntatore a un oggetto di implementazione con conteggio dei riferimenti. La copia dei matcher è consentita ed è molto efficiente, poiché viene copiato solo il puntatore. Quando l’ultimo matcher che fa riferimento all’oggetto di implementazione muore, l’oggetto di implementazione verrà eliminato.</p>
<p>Pertanto, se si ha un matcher complesso che si vuole utilizzare più e più volte, non è necessario crearlo ogni volta. Basta assegnarlo a una variabile matcher e utilizzare quella variabile ripetutamente! Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AllOf</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Le</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">Matcher</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AllOf</span><span class="p">(</span><span class="n">Gt</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span><span class="w"> </span><span class="n">Le</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">in_range</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">matcher</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">multiple</span><span class="w"> </span><span class="n">EXPECT_CALLs</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
</section>
<section id="matchers-must-have-no-side-effects-purematchers">
<h4>I matcher non devono avere effetti collaterali {#PureMatchers}<a class="headerlink" href="#matchers-must-have-no-side-effects-purematchers" title="Link to this heading">¶</a></h4>
<p>{: .callout .warning} ATTENZIONE: gMock non garantisce quando o quante volte un matcher verrà invocato. Pertanto, tutti i matcher devono essere <em>puramente funzionali</em>: non possono avere effetti collaterali e il risultato della corrispondenza non deve dipendere da nient’altro che dai parametri del matcher e dal valore da abbinare.</p>
<p>Questo requisito deve essere soddisfatto indipendentemente da come viene definito un matcher (ad esempio, se è uno dei matcher standard o un matcher personalizzato). In particolare, un matcher non può mai chiamare una funzione mock, poiché ciò influenzerà lo stato dell’oggetto mock e di gMock.</p>
</section>
</section>
<section id="setting-expectations">
<h3>Impostare le Expectation<a class="headerlink" href="#setting-expectations" title="Link to this heading">¶</a></h3>
<section id="knowing-when-to-expect-useoncall">
<h4>Quando usare Expect {#UseOnCall}<a class="headerlink" href="#knowing-when-to-expect-useoncall" title="Link to this heading">¶</a></h4>
<p><strong><code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code></strong> è probabilmente il <em>costrutto singolo più sotto-utilizzato</em> in gMock.</p>
<p>Esistono fondamentalmente due costrutti per definire il comportamento di un oggetto mock: <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> and <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>. La differenza? <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> definisce cosa succede quando viene chiamato un metodo mock, ma <em>non implica alcuna aspettativa [expectation] sul metodo che viene chiamato</em>. <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> non solo definisce il comportamento, ma imposta anche l’aspettativa [expectation] che <em>il metodo venga chiamato con gli argomenti dati, per il numero dato di volte</em> (e <em>nell’ordine indicato</em> quando si specifica anche l’ordine).</p>
<p>Dato che <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> fa di più, non è meglio di <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code>? Non proprio. Ogni <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> aggiunge un vincolo sul comportamento del codice sotto test. Avere più vincoli del necessario è <em>una pessima idea</em> - anche peggio che non avere abbastanza vincoli.</p>
<p>Questo potrebbe essere controintuitivo. Come potrebbero i test che verificano di più essere peggiori dei test che verificano di meno? La verifica non è il punto centrale dei test?</p>
<p>La risposta sta in <em>cosa</em> dovrebbe verificare un test. <strong>Un buon test verifica il contratto del codice</strong>. Se un test specifica eccessivamente, non lascia abbastanza libertà all’implementazione. Di conseguenza, modificare l’implementazione senza infrangere il contratto (ad esempio refactoring e ottimizzazione), cosa che dovrebbe essere perfettamente consentita, può «rompere» tali test. Quindi si deve dedicare del tempo a risolverli, solo per vederli rotti nuovamente la prossima volta che l’implementazione viene modificata.</p>
<p>Si tenga presente che non è necessario verificare più di una proprietà in un test. In effetti, <strong>è buona norma stilistica verificare solo una cosa in un test</strong>. Se lo si fa, un bug probabilmente romperà solo uno o due test invece di dozzine (nel qual caso si vorrebbe eseguire il debug?). Se si ha anche l’abitudine di dare ai test nomi descrittivi che indichino ciò che verificano, spesso si può facilmente indovinare cosa c’è che non va solo dal log.</p>
<p>Quindi usare <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> per default e usare <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> solo quando si intende effettivamente verificare che la chiamata sia stata effettuata. Ad esempio, si potrebbero avere un sacco di <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> nella fixture di test per impostare il comportamento comune del mock condiviso da tutti i test nello stesso gruppo e scrivere (appena) diversi <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> in diversi <code class="docutils literal notranslate"><span class="pre">TEST_F</span></code> per verificare diversi aspetti del comportamento del codice. Rispetto allo stile in cui ogni <code class="docutils literal notranslate"><span class="pre">TEST</span></code> ha molte <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>, questo porta a test più resilienti alle modifiche implementative (e quindi con meno probabilità di richiedere manutenzione) e rende l’intento dei test più ovvi (quindi sono più facili da manutenere).</p>
<p>Se infastidisce dal messaggio «Uninteresting mock function call» stampato quando viene chiamato un metodo mock senza una <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>, si può usare invece un <code class="docutils literal notranslate"><span class="pre">NiceMock</span></code> per sopprimere tutti questi messaggi per l’oggetto mock, o per sopprimere il messaggio per metodi specifici aggiungendo <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(...).Times(AnyNumber())</span></code>. NON sopprimerlo aggiungendo ciecamente un <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(...)</span></code>, altrimenti il test sarà difficile da manutenere.</p>
</section>
<section id="ignoring-uninteresting-calls">
<h4>Ignorare le Chiamate [Uninteresting]<a class="headerlink" href="#ignoring-uninteresting-calls" title="Link to this heading">¶</a></h4>
<p>Se non si è interessati a come viene chiamato un metodo mock, basta non dire nulla al riguardo. In questo caso, se il metodo viene chiamato, gMock eseguirà la sua azione di default per consentire al programma di test di continuare. Se non si è soddisfatti dell’azione di default intrapresa da gMock, la si può sovrascrivere utilizzando <code class="docutils literal notranslate"><span class="pre">DefaultValue&lt;T&gt;::Set()</span></code> (descritto <a class="reference internal" href="#DefaultValue"><span class="xref myst">qui</span></a>) o <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code>.</p>
<p>Si tenga presente che una volta espresso interesse per un particolare metodo mock (tramite <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>), tutte le invocazioni ad esso devono corrispondere a qualche expectation. Se questa funzione viene chiamata ma gli argomenti non corrispondono ad alcuna istruzione <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>, sarà un errore.</p>
</section>
<section id="disallowing-unexpected-calls">
<h4>Evitare Chiamate [Unexpected]<a class="headerlink" href="#disallowing-unexpected-calls" title="Link to this heading">¶</a></h4>
<p>Se un metodo mock non deve essere affatto chiamato, lo si dica esplicitamente:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Se alcune chiamate al metodo sono consentite, ma le altre no, elencare semplicemente tutte le chiamate previste:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AnyNumber</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">Gt</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span>
</pre></div>
</div>
<p>Una chiamata a <code class="docutils literal notranslate"><span class="pre">foo.Bar()</span></code> che non corrisponde a nessuna delle istruzioni <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> sarà un errore.</p>
</section>
<section id="understanding-uninteresting-vs-unexpected-calls-uninteresting-vs-unexpected">
<h4>Le Chiamate Poco Interessanti e Quelle Unexpected {#uninteresting-vs-unexpected}<a class="headerlink" href="#understanding-uninteresting-vs-unexpected-calls-uninteresting-vs-unexpected" title="Link to this heading">¶</a></h4>
<p>Le chiamate <em>Uninteresting</em> e quelle <em>unexpected</em> sono concetti diversi in gMock. <em>Molto</em> diversi.</p>
<p>Una chiamata <code class="docutils literal notranslate"><span class="pre">x.Y(...)</span></code> è <strong>uninteresting</strong> se non è impostata <em>nemmeno una singola</em> <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(x,</span> <span class="pre">Y(...))</span></code>. In altre parole, il test non è affatto interessato al metodo <code class="docutils literal notranslate"><span class="pre">x.Y()</span></code>, come è evidente dal fatto che al test non interessa dire nulla al riguardo.</p>
<p>Una chiamata <code class="docutils literal notranslate"><span class="pre">x.Y(...)</span></code> è <strong>unexpected</strong> se è impostata <em>qualche</em> <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(x,</span> <span class="pre">Y(...))</span></code>, ma nessuna di esse corrisponde [match] alla chiamata. In altre parole, il test è interessato al metodo <code class="docutils literal notranslate"><span class="pre">x.Y()</span></code> (quindi imposta esplicitamente alcune <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> per verificare come viene chiamato); tuttavia, la verifica fallisce poiché il test non prevede [expect] che si verifichi questa particolare chiamata.</p>
<p><strong>Una chiamata unexpected è sempre un errore</strong>, poiché il codice sottoposto a test non si comporta come il test si aspetta che si comporti.</p>
<p><strong>Per default, una chiamata uninteresting non è un errore</strong>, poiché non viola alcun vincolo specificato dal test. (La filosofia di gMock è che non dire nulla significa che non ci sono vincoli). Tuttavia, porta a un warning, poiché <em>potrebbe</em> indicare un problema (ad esempio l’autore del test potrebbe aver dimenticato di specificare un vincolo).</p>
<p>In gMock, <code class="docutils literal notranslate"><span class="pre">NiceMock</span></code> e <code class="docutils literal notranslate"><span class="pre">StrictMock</span></code> possono essere utilizzati per rendere una classe mock «acondiscendente» [nice] o «rigorosa» [strict]. In che modo ciò influisce sulle chiamate uninteresting e le unexpected?</p>
<p>Un <strong>nice mock</strong> sopprime i <em>warnings</em> sulle chiamate uninteresting. È meno loquace del mock di default, ma per il resto è lo stesso. Se un test fallisce con un mock di default, fallirà anche utilizzando un mock «nice». E viceversa. Non ci si aspetti che rendere un mock «nice» possa cambiare il risultato del test.</p>
<p>Un <strong>strict mock</strong> trasforma i warning sulle chiamate uninteresting in errori. Quindi rendere un mock strict può cambiare il risultato del test.</p>
<p>Diamo un’occhiata ad un esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NiceMock</span><span class="o">&lt;</span><span class="n">MockDomainRegistry</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mock_registry</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_registry</span><span class="p">,</span><span class="w"> </span><span class="n">GetDomainOwner</span><span class="p">(</span><span class="s">&quot;google.com&quot;</span><span class="p">))</span>
<span class="w">          </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="s">&quot;Larry Page&quot;</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Use mock_registry in code under test.</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mock_registry</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>L’unico <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> qui dice che tutte le chiamate a <code class="docutils literal notranslate"><span class="pre">GetDomainOwner()</span></code> devono avere <code class="docutils literal notranslate"><span class="pre">&quot;google.com&quot;</span></code> come argomento. Se viene chiamata <code class="docutils literal notranslate"><span class="pre">GetDomainOwner(&quot;yahoo.com&quot;)</span></code>, si tratterà di una chiamata inaspettata [unexpected] e quindi di un errore. <em>Avere un mock nice non cambia la gravità di una chiamata unexpected</em>.</p>
<p>Allora come diciamo a gMock che <code class="docutils literal notranslate"><span class="pre">GetDomainOwner()</span></code> può essere chiamato anche con altri argomenti? La tecnica standard consiste nell’aggiungere un «acchiappa-tutto» <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_registry</span><span class="p">,</span><span class="w"> </span><span class="n">GetDomainOwner</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span><span class="w">  </span><span class="c1">// catches all other calls to this method.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_registry</span><span class="p">,</span><span class="w"> </span><span class="n">GetDomainOwner</span><span class="p">(</span><span class="s">&quot;google.com&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="s">&quot;Larry Page&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Da tener presente che <code class="docutils literal notranslate"><span class="pre">_</span></code> è il carattere jolly che corrisponde a «qualsiasi cosa». Con questo, se viene chiamato <code class="docutils literal notranslate"><span class="pre">GetDomainOwner(&quot;google.com&quot;)</span></code>, farà ciò che dice il secondo <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>; se viene chiamato con un argomento diverso, farà quello che dice il primo <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>.</p>
<p>Notare che l’ordine dei due <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> è importante, poiché un <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> più recente ha la precedenza su quello precedente.</p>
<p>Per ulteriori informazioni su chiamate uninteresting, mock nice e mock strict, leggere <a class="reference internal" href="#NiceStrictNaggy"><span class="xref myst">«Nice, Strict e Naggy»</span></a>.</p>
</section>
<section id="ignoring-uninteresting-arguments-parameterlessexpectations">
<h4>Ignorare gli Argomenti Non Interessanti {#ParameterlessExpectations}<a class="headerlink" href="#ignoring-uninteresting-arguments-parameterlessexpectations" title="Link to this heading">¶</a></h4>
<p>Se il test non si preoccupa dei parametri (si preoccupa solo del numero o dell’ordine delle chiamate), spesso si può semplicemente omettere l’elenco dei parametri:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Expect foo.Bar( ... ) twice with any arguments.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">).</span><span class="n">Times</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Delegate to the given method whenever the factory is invoked.</span>
<span class="w">  </span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo_factory</span><span class="p">,</span><span class="w"> </span><span class="n">MakeFoo</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BuildFooForTest</span><span class="p">);</span>
</pre></div>
</div>
<p>Questa funzionalità è disponibile solo quando un metodo non è overloaded; per evitare comportamenti imprevisti, tentare di impostare un’aspettativa [expectation] su un metodo in cui l’overload specifico è ambiguo costituisce un errore di compilazione. Il problema si può aggirare fornendo una <a class="reference internal" href="#SimplerInterfaces"><span class="xref myst">interfaccia più semplice del mock</span></a> rispetto a quella fornita dalla classe mock-ata.</p>
<p>Questo pattern è utile anche quando gli argomenti sono interessanti, ma la logica della corrispondenza [match] è sostanzialmente complessa. Si può lasciare l’elenco degli argomenti non specificato e utilizzare le azioni SaveArg per <a class="reference internal" href="#SaveArgVerify"><span class="xref myst">salvare i valori per una successiva verifica</span></a>. Facendolo, si può facilmente distinguere la chiamata al metodo per il numero sbagliato di volte dalla chiamata con gli argomenti sbagliati.</p>
</section>
<section id="expecting-ordered-calls-orderedcalls">
<h4>Expect di Chiamate Ordinate {#OrderedCalls}<a class="headerlink" href="#expecting-ordered-calls-orderedcalls" title="Link to this heading">¶</a></h4>
<p>Sebbene un’istruzione <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> definita successivamente abbia la precedenza quando gMock tenta di far corrispondere [to match] una chiamata di funzione con una expectation, per default le chiamate non devono avvenire nell’ordine con cui sono scritte le istruzioni <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>. Ad esempio, se gli argomenti corrispondono ai matcher nella seconda <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>, ma non a quelli nella prima o nella terza, allora verrà utilizzata la seconda expectation.</p>
<p>Se si preferisce che tutte le chiamate avvengano nell’ordine previsto, inserire le istruzioni <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> in un blocco in cui si definisce una variabile di tipo <code class="docutils literal notranslate"><span class="pre">InSequence</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InSequence</span><span class="p">;</span>

<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">InSequence</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>

<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>In questo esempio, ci aspettiamo una chiamata a <code class="docutils literal notranslate"><span class="pre">foo.DoThis(5)</span></code>, seguita da due chiamate a <code class="docutils literal notranslate"><span class="pre">bar.DoThat()</span></code> dove l’argomento può essere qualsiasi cosa, che sono a turno seguite da una chiamata a <code class="docutils literal notranslate"><span class="pre">foo.DoThis(6)</span></code>. Se una chiamata è avvenuta fuori ordine, gMock segnalerà un errore.</p>
</section>
<section id="expecting-partially-ordered-calls-partialorder">
<h4>Expecting Chiamate Parzialmente Ordinate {#PartialOrder}<a class="headerlink" href="#expecting-partially-ordered-calls-partialorder" title="Link to this heading">¶</a></h4>
<p>A volte richiedere che tutto avvenga in un ordine predeterminato può portare a test fragili. Ad esempio, potremmo preoccuparci che <code class="docutils literal notranslate"><span class="pre">A</span></code> si presenti prima sia di <code class="docutils literal notranslate"><span class="pre">B</span></code> e <code class="docutils literal notranslate"><span class="pre">C</span></code>, ma non siamo interessati all’ordine relativo di <code class="docutils literal notranslate"><span class="pre">B</span></code> e <code class="docutils literal notranslate"><span class="pre">C</span></code>. In questo caso, il test dovrebbe riflettere il nostro reale intento, invece di essere eccessivamente vincolante.</p>
<p>gMock consente di imporre un DAG (directed acyclic graph) arbitrario sulle chiamate. Un modo per esprimere il DAG è utilizzare la <a class="reference internal" href="#reference/mocking.md#EXPECT_CALL.After"><span class="xref myst">clausola <code class="docutils literal notranslate"><span class="pre">After</span></code></span></a> di <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>.</p>
<p>Un altro modo è tramite la clausola <code class="docutils literal notranslate"><span class="pre">InSequence()</span></code> (diversa dalla classe <code class="docutils literal notranslate"><span class="pre">InSequence</span></code>), presa in prestito da jMock 2. È meno flessibile di <code class="docutils literal notranslate"><span class="pre">After()</span></code>, ma più conveniente quando si hanno lunghe catene di chiamate sequenziali, poiché non richiede di trovare nomi diversi per le expectation nelle catene. Ecco come funziona:</p>
<p>Se consideriamo le istruzioni <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> come nodi in un grafo e aggiungiamo un arco dal nodo A al nodo B ovunque A debba trovarsi prima di B, possiamo ottenere un DAG. Usiamo il termine «sequenza» per indicare un percorso diretto in questo DAG. Ora, se scomponiamo il DAG in sequenze, dobbiamo solo sapere a quali sequenze appartiene ciascuna <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> per poter ricostruire il DAG originale.</p>
<p>Quindi, per specificare l’ordine parziale sulle expectation dobbiamo fare due cose: prima definire degli oggetti <code class="docutils literal notranslate"><span class="pre">Sequence</span></code>, e poi per ciascuna <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code> dire si quale oggetto <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> fa parte.</p>
<p>Le expectation nella stessa sequenza devono verificarsi nell’ordine in cui sono scritte. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Sequence</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">Sequence</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</pre></div>
</div>
<p>specifica il seguente DAG (dove <code class="docutils literal notranslate"><span class="pre">s1</span></code> è <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code> e <code class="docutils literal notranslate"><span class="pre">s2</span></code> è <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">C</span> <span class="pre">-&gt;</span> <span class="pre">D</span></code>):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>       +---&gt; B
       |
  A ---|
       |
       +---&gt; C ---&gt; D
</pre></div>
</div>
<p>Ciò significa che A deve verificarsi prima di B e C, e C deve verificarsi prima di D. Non ci sono restrizioni sull’ordine diverso da questi.</p>
</section>
<section id="controlling-when-an-expectation-retires">
<h4>Controllare Quando una Expectation viene Ritirata<a class="headerlink" href="#controlling-when-an-expectation-retires" title="Link to this heading">¶</a></h4>
<p>Quando viene chiamato un metodo mock, gMock considera solo le expectation ancora attive. Una expectation è attiva quando viene creata e diventa inattiva (ovvero <em>va in pensione</em>) quando si verifica una chiamata che deve avvenire in seguito. Ad esempio, in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Sequence</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">Sequence</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;File too large.&quot;</span><span class="p">))</span><span class="w">      </span><span class="c1">// #1</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Data set is empty.&quot;</span><span class="p">))</span><span class="w">   </span><span class="c1">// #2</span>
<span class="w">      </span><span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;User not found.&quot;</span><span class="p">))</span><span class="w">      </span><span class="c1">// #3</span>
<span class="w">      </span><span class="p">.</span><span class="n">InSequence</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</pre></div>
</div>
<p>non appena il #2 o il #3 verranno abbinati [match], il #1 verrà ritirato. Se successivamente viene loggato un warning <code class="docutils literal notranslate"><span class="pre">&quot;File</span> <span class="pre">too</span> <span class="pre">large.&quot;</span></code>, si tratterà di un errore.</p>
<p>Notare che una expectation viene ritirata automaticamente quando è saturata. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">));</span><span class="w">                     </span><span class="c1">// #1</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;File too large.&quot;</span><span class="p">));</span><span class="w">     </span><span class="c1">// #2</span>
</pre></div>
</div>
<p>dice che ci sarà esattamente un warning con il messaggio <code class="docutils literal notranslate"><span class="pre">&quot;File</span> <span class="pre">too</span> <span class="pre">large.&quot;</span></code>. Se anche il secondo warning contiene questo messaggio, #2 corrisponderà [match] nuovamente e genererà un errore di violazione del limite superiore [upper-bound-violated].</p>
<p>Se questo non è quello che si desidera, si può a chiedere una expectation ritirarsi non appena diventa satura:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">));</span><span class="w">                     </span><span class="c1">// #1</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;File too large.&quot;</span><span class="p">))</span><span class="w">      </span><span class="c1">// #2</span>
<span class="w">      </span><span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
</pre></div>
</div>
<p>Qui #2 può essere utilizzato solo una volta, quindi se si hanno due warning con il messaggio <code class="docutils literal notranslate"><span class="pre">&quot;File</span> <span class="pre">too</span> <span class="pre">large.&quot;</span></code>, il primo corrisponderà [match] a #2 e il secondo corrisponderà a #1: non ci sarà errore.</p>
</section>
</section>
<section id="using-actions">
<h3>Usare le Action<a class="headerlink" href="#using-actions" title="Link to this heading">¶</a></h3>
<section id="returning-references-from-mock-methods">
<h4>Restituire Riferimenti dai Metodi Mock<a class="headerlink" href="#returning-references-from-mock-methods" title="Link to this heading">¶</a></h4>
<p>Se il tipo di ritorno di una funzione mock è un riferimento, si deve usare <code class="docutils literal notranslate"><span class="pre">ReturnRef()</span></code> anziché <code class="docutils literal notranslate"><span class="pre">Return()</span></code> per restituire un risultato:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ReturnRef</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Bar</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">GetBar</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">Bar</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">GetBar</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>
<span class="p">...</span>
</pre></div>
</div>
</section>
<section id="returning-live-values-from-mock-methods">
<h4>Restituire Valori Live dai Metodi Mock<a class="headerlink" href="#returning-live-values-from-mock-methods" title="Link to this heading">¶</a></h4>
<p>L’azione <code class="docutils literal notranslate"><span class="pre">Return(x)</span></code> salva una copia di <code class="docutils literal notranslate"><span class="pre">x</span></code> quando l’azione viene creata e restituisce sempre lo stesso valore ogni volta che viene eseguita. A volte si vorrebbe restituire invece il valore <em>live</em> di <code class="docutils literal notranslate"><span class="pre">x</span></code> (ovvero il suo valore nel momento in cui l’azione viene <em>eseguita</em>.). Si usa o <code class="docutils literal notranslate"><span class="pre">ReturnRef()</span></code> oppure <code class="docutils literal notranslate"><span class="pre">ReturnPointee()</span></code> per questo.</p>
<p>Se il tipo restituito dalla funzione mock è un riferimento, lo si può fare utilizzando <code class="docutils literal notranslate"><span class="pre">ReturnRef(x)</span></code>, come mostrato nella ricetta precedente («Restituire Riferimenti dai Metodi Mock»). Tuttavia, gMock non consente di utilizzare <code class="docutils literal notranslate"><span class="pre">ReturnRef()</span></code> in una funzione mock il cui tipo restituito non è un riferimento, poiché ciò di solito indica un errore dell’utente. Allora, cosa si farà?</p>
<p>Anche se si potrebbe essere tentati, NON USARE <code class="docutils literal notranslate"><span class="pre">std::ref()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">GetValue</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">GetValue</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">)));</span><span class="w">  </span><span class="c1">// Wrong!</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">GetValue</span><span class="p">(),</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
</pre></div>
</div>
<p>Sfortunatamente, qui non funziona. Il codice precedente fallirà con errore:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Value of: foo.GetValue()
  Actual: 0
Expected: 42
</pre></div>
</div>
<p>Il motivo è che <code class="docutils literal notranslate"><span class="pre">Return(*value*)</span></code> converte <code class="docutils literal notranslate"><span class="pre">value</span></code> nel tipo restituito effettivo della funzione mock nel momento in cui l’azione viene <em>creata</em>, non quando viene <em>eseguita</em>. (Questo comportamento è stato scelto perché l’azione fosse sicura quando <code class="docutils literal notranslate"><span class="pre">value</span></code> è un oggetto proxy che fa riferimento ad alcuni oggetti temporanei). Di conseguenza, <code class="docutils literal notranslate"><span class="pre">std::ref(x)</span></code> è convertito in un valore <code class="docutils literal notranslate"><span class="pre">int</span></code> (anziché un <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int&amp;</span></code>) quando la expectation è impostata e <code class="docutils literal notranslate"><span class="pre">Return(std::ref(x))</span></code> restituirà sempre 0.</p>
<p><code class="docutils literal notranslate"><span class="pre">ReturnPointee(pointer)</span></code> è stato fornito per risolvere specificamente questo problema. Restituisce il valore puntato da <code class="docutils literal notranslate"><span class="pre">pointer</span></code> nel momento in cui l’azione viene <em>eseguita</em>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ReturnPointee</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">GetValue</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">ReturnPointee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">));</span><span class="w">  </span><span class="c1">// Note the &amp; here.</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">GetValue</span><span class="p">(),</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span><span class="w">  </span><span class="c1">// This will succeed now.</span>
</pre></div>
</div>
</section>
<section id="combining-actions">
<h4>Combinazione di Azioni<a class="headerlink" href="#combining-actions" title="Link to this heading">¶</a></h4>
<p>Si vuol fare più di una cosa quando viene chiamata una funzione? Va bene. <code class="docutils literal notranslate"><span class="pre">DoAll()</span></code> consente di eseguire una sequenza di azioni ogni volta. Verrà utilizzato solo il valore restituito dell’ultima azione nella sequenza.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoAll</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DoAll</span><span class="p">(</span><span class="n">action_1</span><span class="p">,</span>
<span class="w">                      </span><span class="n">action_2</span><span class="p">,</span>
<span class="w">                      </span><span class="p">...</span>
<span class="w">                      </span><span class="n">action_n</span><span class="p">));</span>
</pre></div>
</div>
<p>Il valore restituito dell’ultima azione <strong>deve</strong> corrispondere al tipo restituito del metodo mock-ato. Nell’esempio sopra, <code class="docutils literal notranslate"><span class="pre">action_n</span></code> potrebbe essere <code class="docutils literal notranslate"><span class="pre">Return(true)</span></code> o una lambda che restituisce un <code class="docutils literal notranslate"><span class="pre">bool</span></code>, ma non <code class="docutils literal notranslate"><span class="pre">SaveArg</span></code>, che restituisce <code class="docutils literal notranslate"><span class="pre">void</span></code>. Altrimenti la firma [signature] di <code class="docutils literal notranslate"><span class="pre">DoAll</span></code> non corrisponderebbe a quella prevista da <code class="docutils literal notranslate"><span class="pre">WillOnce</span></code>, che è la firma del metodo mock-ato, e non verrebbe compilato.</p>
</section>
<section id="verifying-complex-arguments-saveargverify">
<h4>Verifica di argomenti Complessi {#SaveArgVerify}<a class="headerlink" href="#verifying-complex-arguments-saveargverify" title="Link to this heading">¶</a></h4>
<p>Per verificare che un metodo venga chiamato con un argomento particolare ma i criteri di corrispondenza [match] sono complessi, può essere difficile distinguere tra errori di cardinalità (chiamare il metodo il numero sbagliato di volte) e gli errori di corrispondenza [match] dell’argomento. Allo stesso modo, se si c’è il «match» di più parametri, potrebbe non essere facile distinguere quale argomento non è riuscito a corrispondere. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Not ideal: this could fail because of a problem with arg1 or arg2, or maybe</span>
<span class="w">  </span><span class="c1">// just the method wasn&#39;t called.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">SendValues</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">ElementsAre</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">),</span><span class="w"> </span><span class="n">EqualsProto</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">)));</span>
</pre></div>
</div>
<p>Si possono invece salvare gli argomenti e testarli individualmente:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">SendValues</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DoAll</span><span class="p">(</span><span class="n">SaveArg</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actual_array</span><span class="p">),</span><span class="w"> </span><span class="n">SaveArg</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">actual_proto</span><span class="p">)));</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">test</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">actual_array</span><span class="p">,</span><span class="w"> </span><span class="n">ElementsAre</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">actual_proto</span><span class="p">,</span><span class="w"> </span><span class="n">EqualsProto</span><span class="p">(</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="mocking-side-effects-mockingsideeffects">
<h4>Effetti Collaterali dei Mock {#MockingSideEffects}<a class="headerlink" href="#mocking-side-effects-mockingsideeffects" title="Link to this heading">¶</a></h4>
<p>A volte un metodo mostra il suo effetto non restituendo un valore ma tramite degli effetti collaterali. Ad esempio, potrebbe modificare alcuni stati globali o modificare un argomento di output. Per mock-are gli oggetti collaterali, in generale si può definire la propria azione implementando <code class="docutils literal notranslate"><span class="pre">::testing::ActionInterface</span></code>.</p>
<p>Se tutto ciò che si deve fare è modificare un argomento di output, conviene la «action» nativa <code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArgPointee</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockMutator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Mutator</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Mutate</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">mutate</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MockMutator</span><span class="w"> </span><span class="n">mutator</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mutator</span><span class="p">,</span><span class="w"> </span><span class="n">Mutate</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">SetArgPointee</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>In questo esempio, quando viene chiamato <code class="docutils literal notranslate"><span class="pre">mutator.Mutate()</span></code>, assegneremo 5 alla variabile <code class="docutils literal notranslate"><span class="pre">int</span></code> puntata dall’argomento #1 (in base 0).</p>
<p><code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> crea comodamente una copia interna del valore che gli si passa, eliminando la necessità di mantenere il valore nello scope e in vita [alive]. L’implicazione tuttavia è che il valore deve avere un costruttore di copia e un operatore di assegnazione.</p>
<p>Se anche il metodo mock deve restituire un valore, si può concatenare <code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> con <code class="docutils literal notranslate"><span class="pre">Return()</span></code> usando <code class="docutils literal notranslate"><span class="pre">DoAll()</span></code>, ricordando di mettere l’istruzione <code class="docutils literal notranslate"><span class="pre">Return()</span></code> in ultimo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoAll</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArgPointee</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockMutator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Mutator</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">MutateInt</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MockMutator</span><span class="w"> </span><span class="n">mutator</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mutator</span><span class="p">,</span><span class="w"> </span><span class="n">MutateInt</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DoAll</span><span class="p">(</span><span class="n">SetArgPointee</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="w">                      </span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">)));</span>
</pre></div>
</div>
<p>Notare, tuttavia, che se si usa il metodo <code class="docutils literal notranslate"><span class="pre">ReturnOKWith()</span></code>, esso sovrascriverà [override] i valori forniti da <code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> nei parametri di risposta della chiamata di funzione.</p>
<p>Se l’argomento di output è un array, si usa invece l’azione <code class="docutils literal notranslate"><span class="pre">SetArrayArgument&lt;N&gt;(first,</span> <span class="pre">last)</span></code>. Questa copia gli elementi nell’intervallo di origine <code class="docutils literal notranslate"><span class="pre">[first,</span> <span class="pre">last)</span></code> nell’array puntato dall’argomento <code class="docutils literal notranslate"><span class="pre">N</span></code>-esimo (in base 0):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NotNull</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArrayArgument</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockArrayMutator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ArrayMutator</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Mutate</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_values</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MockArrayMutator</span><span class="w"> </span><span class="n">mutator</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mutator</span><span class="p">,</span><span class="w"> </span><span class="n">Mutate</span><span class="p">(</span><span class="n">NotNull</span><span class="p">(),</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">SetArrayArgument</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">,</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>Funziona anche quando l’argomento è un iteratore di output:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArrayArgument</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockRolodex</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Rolodex</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">GetNames</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">back_insert_iterator</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">),</span>
<span class="w">              </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MockRolodex</span><span class="w"> </span><span class="n">rolodex</span><span class="p">;</span>
<span class="w">  </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;George&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Thomas&quot;</span><span class="p">};</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">rolodex</span><span class="p">,</span><span class="w"> </span><span class="n">GetNames</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">SetArrayArgument</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">names</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
</pre></div>
</div>
</section>
<section id="changing-a-mock-object-s-behavior-based-on-the-state">
<h4>Modifica del Comportamento di un Oggetto Mock in Base allo Stato<a class="headerlink" href="#changing-a-mock-object-s-behavior-based-on-the-state" title="Link to this heading">¶</a></h4>
<p>Se si prevede che una chiamata modifichi il comportamento di un oggetto mock, si può usare <code class="docutils literal notranslate"><span class="pre">::testing::InSequence</span></code> per specificare comportamenti diversi prima e dopo la chiamata:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InSequence</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="p">...</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">     </span><span class="n">InSequence</span><span class="w"> </span><span class="n">seq</span><span class="p">;</span>
<span class="w">     </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span><span class="w"> </span><span class="n">IsDirty</span><span class="p">())</span>
<span class="w">         </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
<span class="w">     </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span><span class="w"> </span><span class="n">Flush</span><span class="p">());</span>
<span class="w">     </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span><span class="w"> </span><span class="n">IsDirty</span><span class="p">())</span>
<span class="w">         </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">my_mock</span><span class="p">.</span><span class="n">FlushIfDirty</span><span class="p">();</span>
</pre></div>
</div>
<p>Questo fa sì che <code class="docutils literal notranslate"><span class="pre">my_mock.IsDirty()</span></code> restituisca <code class="docutils literal notranslate"><span class="pre">true</span></code> prima che <code class="docutils literal notranslate"><span class="pre">my_mock.Flush()</span></code> venga chiamato e restituisca <code class="docutils literal notranslate"><span class="pre">false</span></code> successivamente.</p>
<p>Se la modifica del comportamento è più complessa, se ne possono memorizzare gli effetti in una variabile e fare in modo che un metodo mock ottenga il valore restituito da quella variabile:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SaveArg</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="n">ACTION_P</span><span class="p">(</span><span class="n">ReturnPointee</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">previous_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span><span class="w"> </span><span class="n">GetPrevValue</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">ReturnPointee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previous_value</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">my_mock</span><span class="p">,</span><span class="w"> </span><span class="n">UpdateValue</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">SaveArg</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">previous_value</span><span class="p">));</span>
<span class="w">  </span><span class="n">my_mock</span><span class="p">.</span><span class="n">DoSomethingToUpdateValue</span><span class="p">();</span>
</pre></div>
</div>
<p>Qui <code class="docutils literal notranslate"><span class="pre">my_mock.GetPrevValue()</span></code> restituirà sempre l’argomento dell’ultima chiamata <code class="docutils literal notranslate"><span class="pre">UpdateValue()</span></code>.</p>
</section>
<section id="setting-the-default-value-for-a-return-type-defaultvalue">
<h4>Impostazione del Valore di Default per un Tipo Restituito {#DefaultValue}<a class="headerlink" href="#setting-the-default-value-for-a-return-type-defaultvalue" title="Link to this heading">¶</a></h4>
<p>Se il tipo restituito di un metodo mock è un tipo o puntatore C++ nativo, per default restituirà 0 quando richiamato. Inoltre, in C++ 11 e versioni successive, un metodo mock il cui tipo restituito ha un costruttore di default, restituirà di default un valore costruito per default. Si deve solo specificare un’azione se questo valore di default non corrisponde alle proprie esigenze.</p>
<p>A volte, si vuole modificare questo valore di default o specificare un valore di default per i tipi di cui gMock non è a conoscenza. Lo si può fare utilizzando la classe template <code class="docutils literal notranslate"><span class="pre">::testing::DefaultValue</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DefaultValue</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="n">CalculateBar</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>


<span class="p">...</span>
<span class="w">  </span><span class="n">Bar</span><span class="w"> </span><span class="n">default_bar</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Sets the default return value for type Bar.</span>
<span class="w">  </span><span class="n">DefaultValue</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;::</span><span class="n">Set</span><span class="p">(</span><span class="n">default_bar</span><span class="p">);</span>

<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// We don&#39;t need to specify an action here, as the default</span>
<span class="w">  </span><span class="c1">// return value works for us.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">CalculateBar</span><span class="p">());</span>

<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">CalculateBar</span><span class="p">();</span><span class="w">  </span><span class="c1">// This should return default_bar.</span>

<span class="w">  </span><span class="c1">// Unsets the default return value.</span>
<span class="w">  </span><span class="n">DefaultValue</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;::</span><span class="n">Clear</span><span class="p">();</span>
</pre></div>
</div>
<p>Notare che la modifica del valore di default per un tipo può rendere difficile la comprensione dei test. Consigliamo di utilizzare questa funzione con giudizio. Ad esempio, per assicurarsi che le chiamate <code class="docutils literal notranslate"><span class="pre">Set()</span></code> e <code class="docutils literal notranslate"><span class="pre">Clear()</span></code> siano proprio accanto al codice che utilizza il mock.</p>
</section>
<section id="setting-the-default-actions-for-a-mock-method">
<h4>Impostazione delle Azioni di Default per un Metodo Mock<a class="headerlink" href="#setting-the-default-actions-for-a-mock-method" title="Link to this heading">¶</a></h4>
<p>Abbiamo imparato come modificare il valore di default di un determinato tipo. Tuttavia, questo potrebbe essere troppo grossolano per i propri scopi: forse ci sono due metodi mock con lo stesso tipo di ritorno e si vuole che abbiano comportamenti diversi. La macro <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code> consente di personalizzare il comportamento del mock a livello del metodo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AnyNumber</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Gt</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Sign</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">-1</span><span class="p">));</span>
<span class="w">  </span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Sign</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Sign</span><span class="p">(</span><span class="n">Gt</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Sign</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span>

<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w">   </span><span class="c1">// This should return 1.</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="mi">-9</span><span class="p">);</span><span class="w">  </span><span class="c1">// This should return -1.</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">   </span><span class="c1">// This should return 0.</span>
</pre></div>
</div>
<p>Come intuito, quando ci sono più istruzioni <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code>, quelle più recenti nell’ordine hanno la precedenza su quelle più vecchie. In altre parole, verrà utilizzato l”<strong>ultimo</strong> che corrisponde agli argomenti della funzione. Questo ordine di corrispondenza consente di impostare il comportamento comune nel costruttore di un oggetto mock o nella fase di impostazione della fixture e di specializzare il comportamento del mock in seguito.</p>
<p>Notare che sia <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> che <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> hanno la stessa regola «le istruzioni successive hanno la precedenza», ma non interagiscono. Cioè, le <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> hanno il proprio ordine di precedenza distinto da quello di <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code>.</p>
</section>
<section id="using-functions-methods-functors-lambdas-as-actions-functionsasactions">
<h4>Utilizzo di Funzioni/Metodi/Funtori/Lambda come Azioni {#FunctionsAsActions}<a class="headerlink" href="#using-functions-methods-functors-lambdas-as-actions-functionsasactions" title="Link to this heading">¶</a></h4>
<p>Se le azioni native non soddisfano, si può utilizzare un chiamabile [callable] esistente (funzione, <code class="docutils literal notranslate"><span class="pre">std::function</span></code>, metodo, funtore, lambda) come azione.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Sum</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">ComplexJob</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">CalculateSum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Sum3</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Helper</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">ComplexJob</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">Helper</span><span class="w"> </span><span class="n">helper</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Sum</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CalculateSum</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">NewPermanentCallback</span><span class="p">(</span><span class="n">Sum3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">ComplexJob</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">helper</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Helper</span><span class="o">::</span><span class="n">ComplexJob</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">([]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="p">})</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">([](</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>

<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w">         </span><span class="c1">// Invokes CalculateSum(5, 6).</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">         </span><span class="c1">// Invokes Sum3(1, 2, 3).</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">ComplexJob</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">    </span><span class="c1">// Invokes helper.ComplexJob(10).</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">ComplexJob</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w">    </span><span class="c1">// Invokes the inline lambda.</span>
</pre></div>
</div>
<p>L’unico requisito è che il tipo della funzione, ecc. deve essere <em>compatibile</em> con la firma della funzione mock, il che significa che gli argomenti di quest’ultima (se ne accetta qualcuno) possono essere convertiti implicitamente negli argomenti corrispondenti del primo e il tipo restituito del primo possono essere convertiti implicitamente in quello del secondo. Quindi, si può invocare qualcosa il cui tipo <em>non</em> sia esattamente lo stesso della funzione mock, purché sia sicuro farlo: bello, eh?</p>
<p>Notare che:</p>
<ul>
<li><p>L’azione assume la proprietà [ownership] della callback e la eliminerà [delete] quando l’azione stessa verrà distrutta.</p></li>
<li><p>Se il tipo della callback deriva da un tipo di callback di base <code class="docutils literal notranslate"><span class="pre">C</span></code>, è necessario implicitamente eseguire il cast a <code class="docutils literal notranslate"><span class="pre">C</span></code> per risolvere l’overload, ad es.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">ResultCallback</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">is_ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">Invoke</span><span class="p">(</span><span class="n">is_ok</span><span class="p">)</span><span class="w"> </span><span class="p">...;</span><span class="w">  </span><span class="c1">// This works.</span>

<span class="w">  </span><span class="n">BlockingClosure</span><span class="o">*</span><span class="w"> </span><span class="n">done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BlockingClosure</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">Invoke</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">done</span><span class="p">))</span><span class="w"> </span><span class="p">...;</span><span class="w">  </span><span class="c1">// The cast is necessary.</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="using-functions-with-extra-info-as-actions">
<h4>Uso di Funzioni con Informazioni Extra come Azioni<a class="headerlink" href="#using-functions-with-extra-info-as-actions" title="Link to this heading">¶</a></h4>
<p>La funzione o il funtore che si chiama utilizzando <code class="docutils literal notranslate"><span class="pre">Invoke()</span></code> deve avere lo stesso numero di argomenti della funzione mock per cui la si usa. A volte si potrebbe avere una funzione che accetta più argomenti e si è disposti a passare manualmente gli argomenti extra per colmare il divario. In gMock lo si può fare utilizzando le callback con argomenti pre-associati [pre-bound]. Ecco un esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="kt">char</span><span class="w"> </span><span class="nf">SignOfSum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Test</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">NewPermanentCallback</span><span class="p">(</span><span class="n">SignOfSum</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)));</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="p">);</span><span class="w">  </span><span class="c1">// Invokes SignOfSum(5, 2).</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="invoking-a-function-method-functor-lambda-callback-without-arguments">
<h4>Invcare una Funzione/Metodo/Funtore/Lambda/Callback Senza Argomenti<a class="headerlink" href="#invoking-a-function-method-functor-lambda-callback-without-arguments" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Invoke()</span></code> passa gli argomenti della funzione mock alla funzione, ecc. invocata in modo tale che il chiamato abbia l’intero contesto della chiamata con cui lavorare.. Se la funzione invocata non è interessata ad alcuni o a tutti gli argomenti, può semplicemente ignorarli.</p>
<p>Tuttavia, un pattern comune è che l’autore di un test desidera invocare una funzione senza gli argomenti della funzione mock. Potrebbe farlo utilizzando una funzione wrapper che elimina gli argomenti prima di invocare una [nullary function]. Inutile dire che questo può essere noioso e oscurare lo scopo del test.</p>
<p>Ci sono due soluzioni a questo problema. Innanzitutto, si può passare qualsiasi «callable» di zero arg come azione. In alternativa, si usa <code class="docutils literal notranslate"><span class="pre">InvokeWithoutArgs()</span></code>, che è come <code class="docutils literal notranslate"><span class="pre">Invoke()</span></code> tranne per il fatto che non passa gli argomenti della funzione fittizia al chiamato. Ecco un esempio di ciascuno:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeWithoutArgs</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">ComplexJob</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">Job1</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">Job2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">ComplexJob</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">([]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Job1</span><span class="p">();</span><span class="w"> </span><span class="p">});</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">InvokeWithoutArgs</span><span class="p">(</span><span class="n">NewPermanentCallback</span><span class="p">(</span><span class="n">Job2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">)));</span>

<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">ComplexJob</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// Invokes Job1().</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">ComplexJob</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span><span class="w">  </span><span class="c1">// Invokes Job2(5, &#39;a&#39;).</span>
</pre></div>
</div>
<p>Notare che:</p>
<ul>
<li><p>L’azione assume la proprietà [ownership] della callback e la eliminerà [delete] quando l’azione stessa verrà distrutta.</p></li>
<li><p>Se il tipo della callback deriva da un tipo di callback di base <code class="docutils literal notranslate"><span class="pre">C</span></code>, è necessario implicitamente eseguire il cast a <code class="docutils literal notranslate"><span class="pre">C</span></code> per risolvere l’overload, ad es.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeWithoutArgs</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">ResultCallback</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">is_ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">InvokeWithoutArgs</span><span class="p">(</span><span class="n">is_ok</span><span class="p">)</span><span class="w"> </span><span class="p">...;</span><span class="w">  </span><span class="c1">// This works.</span>

<span class="w">  </span><span class="n">BlockingClosure</span><span class="o">*</span><span class="w"> </span><span class="n">done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">InvokeWithoutArgs</span><span class="p">(</span><span class="n">implicit_cast</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">done</span><span class="p">))</span><span class="w"> </span><span class="p">...;</span>
<span class="w">  </span><span class="c1">// The cast is necessary.</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="invoking-an-argument-of-the-mock-function">
<h4>Invocare un Argomento della Funzione Mock<a class="headerlink" href="#invoking-an-argument-of-the-mock-function" title="Link to this heading">¶</a></h4>
<p>A volte una funzione mock riceverà un puntatore a funzione, un funtore (in altre parole, un «callable») come argomento, ad es.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">ResultCallback1</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">callback</span><span class="p">)),</span>
<span class="w">              </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>e si potrebbe invocare questo argomento richiamabile:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(...);</span>
<span class="w">      </span><span class="c1">// Will execute callback-&gt;Run(5), where callback is the</span>
<span class="w">      </span><span class="c1">// second argument DoThis() receives.</span>
</pre></div>
</div>
<p>{: .callout .note} NOTA: La sezione seguente è la documentazione di prima che il C++ avesse le lambda:</p>
<p>Arghh, si deve fare riferimento a un argomento di funzione mock ma il C++ non ha (ancora) le lambda, quindi si deve definire la propria azione. :-( Oh! veramente?</p>
<p>Beh, gMock ha un’azione per risolvere <em>esattamente</em> questo problema:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">InvokeArgument</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg_1</span><span class="p">,</span><span class="w"> </span><span class="n">arg_2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">arg_m</span><span class="p">)</span>
</pre></div>
</div>
<p>invocherà l”<code class="docutils literal notranslate"><span class="pre">N</span></code>-esimo (0-based) argomento ricevuto dalla funzione mock, con <code class="docutils literal notranslate"><span class="pre">arg_1</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_2</span></code>, …, e <code class="docutils literal notranslate"><span class="pre">arg_m</span></code>. Non importa se l’argomento è un puntatore a funzione, un funtore o una callback. gMock li gestisce tutti.</p>
<p>Con ciò, si potrebbe scrivere:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeArgument</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">InvokeArgument</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="w">      </span><span class="c1">// Will execute callback-&gt;Run(5), where callback is the</span>
<span class="w">      </span><span class="c1">// second argument DoThis() receives.</span>
</pre></div>
</div>
<p>Cosa succede se il «callable» accetta un argomento per riferimento? Nessun problema: basta racchiuderlo all’interno di <code class="docutils literal notranslate"><span class="pre">std::ref()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">,</span>
<span class="w">              </span><span class="p">((</span><span class="n">ResultCallback2</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Helper</span><span class="o">&amp;&gt;*</span><span class="w"> </span><span class="n">callback</span><span class="p">)),</span>
<span class="w">              </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeArgument</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">Helper</span><span class="w"> </span><span class="n">helper</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">InvokeArgument</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">helper</span><span class="p">)));</span>
<span class="w">      </span><span class="c1">// std::ref(helper) guarantees that a reference to helper, not a copy of</span>
<span class="w">      </span><span class="c1">// it, will be passed to the callback.</span>
</pre></div>
</div>
<p>Cosa succede se il callable accetta un argomento per riferimento e <strong>non</strong> racchiudiamo l’argomento in <code class="docutils literal notranslate"><span class="pre">std::ref()</span></code>? In questo caso <code class="docutils literal notranslate"><span class="pre">InvokeArgument()</span></code> <em>creerà una copia</em> dell’argomento e passerà un <em>riferimento alla copia</em>, invece di un riferimento al valore originale, al richiamabile [callable]. Ciò è particolarmente utile quando l’argomento è un valore temporaneo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)),</span>
<span class="w">              </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InvokeArgument</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">InvokeArgument</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="s">&quot;Hi&quot;</span><span class="p">)));</span>
<span class="w">      </span><span class="c1">// Will execute (*f)(5.0, string(&quot;Hi&quot;)), where f is the function pointer</span>
<span class="w">      </span><span class="c1">// DoThat() receives.  Note that the values 5.0 and string(&quot;Hi&quot;) are</span>
<span class="w">      </span><span class="c1">// temporary and dead once the EXPECT_CALL() statement finishes.  Yet</span>
<span class="w">      </span><span class="c1">// it&#39;s fine to perform this action later, since a copy of the values</span>
<span class="w">      </span><span class="c1">// are kept inside the InvokeArgument action.</span>
</pre></div>
</div>
</section>
<section id="ignoring-an-action-s-result">
<h4>Ignorare un Risultato di un’Azione<a class="headerlink" href="#ignoring-an-action-s-result" title="Link to this heading">¶</a></h4>
<p>A volte si ha un’azione che restituisce <em>qualcosa</em>, ma c’è bisogno di un’azione che restituisca <code class="docutils literal notranslate"><span class="pre">void</span></code> (forse per usarla in una funzione mock che restituisca <code class="docutils literal notranslate"><span class="pre">void</span></code>, o forse deve essere utilizzato in <code class="docutils literal notranslate"><span class="pre">DoAll()</span></code> e non è l’ultimo della lista). <code class="docutils literal notranslate"><span class="pre">IgnoreResult()</span></code> consente di farlo. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoAll</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">IgnoreResult</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">Process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="n">string</span><span class="w"> </span><span class="nf">DoSomething</span><span class="p">();</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Abc</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Xyz</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Abc</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="c1">// .WillOnce(Invoke(Process));</span>
<span class="w">      </span><span class="c1">// The above line won&#39;t compile as Process() returns int but Abc() needs</span>
<span class="w">      </span><span class="c1">// to return void.</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">IgnoreResult</span><span class="p">(</span><span class="n">Process</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Xyz</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DoAll</span><span class="p">(</span><span class="n">IgnoreResult</span><span class="p">(</span><span class="n">DoSomething</span><span class="p">),</span>
<span class="w">                      </span><span class="c1">// Ignores the string DoSomething() returns.</span>
<span class="w">                      </span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">)));</span>
</pre></div>
</div>
<p>Notare che <strong>non si può</strong> usare <code class="docutils literal notranslate"><span class="pre">IgnoreResult()</span></code> su un’azione che restituisce già <code class="docutils literal notranslate"><span class="pre">void</span></code>. Ciò porterà a brutti errori del compilatore.</p>
</section>
<section id="selecting-an-action-s-arguments-selectingargs">
<h4>Selezionare gli Argomenti di un’Azione {#SelectingArgs}<a class="headerlink" href="#selecting-an-action-s-arguments-selectingargs" title="Link to this heading">¶</a></h4>
<p>Supponiamo che si abbia una funzione mock <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> che accetta sette argomenti e che si abbia un’azione personalizzata che da invocare quando viene chiamata <code class="docutils literal notranslate"><span class="pre">Foo()</span></code>. Il problema è che l’azione personalizzata richiede solo tre argomenti:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">,</span>
<span class="w">              </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">visible</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">               </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">map</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">),</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">weight</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">min_weight</span><span class="p">,</span>
<span class="w">               </span><span class="kt">double</span><span class="w"> </span><span class="n">max_wight</span><span class="p">));</span>
<span class="p">...</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">IsVisibleInQuadrant1</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">visible</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">visible</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">IsVisibleInQuadrant1</span><span class="p">));</span><span class="w">  </span><span class="c1">// Uh, won&#39;t compile. :-(</span>
</pre></div>
</div>
<p>Per compiacere il dio del compilatore, si deve definire un «adaptor» che abbia la stessa firma di <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> e si chiama l’azione personalizzata con gli argomenti giusti:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="p">...</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">MyIsVisibleInQuadrant1</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">visible</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">map</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">weight</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">double</span><span class="w"> </span><span class="n">min_weight</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">max_wight</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">IsVisibleInQuadrant1</span><span class="p">(</span><span class="n">visible</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">MyIsVisibleInQuadrant1</span><span class="p">));</span><span class="w">  </span><span class="c1">// Now it works.</span>
</pre></div>
</div>
<p>Ma non è imbarazzante?</p>
<p>gMock fornisce un <em>action adaptor</em> generico, così ci si può dedicare agli affari più importanti piuttosto che scrivere i propri adaptor. Ecco la sintassi:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">WithArgs</span><span class="o">&lt;</span><span class="n">N1</span><span class="p">,</span><span class="w"> </span><span class="n">N2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">Nk</span><span class="o">&gt;</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
</pre></div>
</div>
<p>crea un’azione che passa gli argomenti della funzione mock agli indici dati (in base 0) all”<code class="docutils literal notranslate"><span class="pre">action</span></code> interna e la esegue. Utilizzando <code class="docutils literal notranslate"><span class="pre">WithArgs</span></code>, l’esempio originale può essere scritto come:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">WithArgs</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">WithArgs</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">IsVisibleInQuadrant1</span><span class="p">)));</span><span class="w">  </span><span class="c1">// No need to define your own adaptor.</span>
</pre></div>
</div>
<p>Per una migliore leggibilità, gMock offre anche:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">WithoutArgs(action)</span></code> quando l”<code class="docutils literal notranslate"><span class="pre">action</span></code> interna accetta <em>nessun</em> argomento, e</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WithArg&lt;N&gt;(action)</span></code> (nessuna <code class="docutils literal notranslate"><span class="pre">s</span></code> dopo <code class="docutils literal notranslate"><span class="pre">Arg</span></code>) quando l”<code class="docutils literal notranslate"><span class="pre">action</span></code> interna prende <em>un</em> argomento.</p></li>
</ul>
<p>Si comprenderà che <code class="docutils literal notranslate"><span class="pre">InvokeWithoutArgs(...)</span></code> è solo «zucchero sintattico» per <code class="docutils literal notranslate"><span class="pre">WithoutArgs(Invoke(...))</span></code>.</p>
<p>Ecco ulteriori suggerimenti:</p>
<ul class="simple">
<li><p>L’azione interna utilizzata in <code class="docutils literal notranslate"><span class="pre">WithArgs</span></code> e simili non deve essere necessariamente <code class="docutils literal notranslate"><span class="pre">Invoke()</span></code>: può essere qualsiasi cosa.</p></li>
<li><p>Se necessario è possibile ripetere un argomento nell’elenco, ad es. <code class="docutils literal notranslate"><span class="pre">WithArgs&lt;2,</span> <span class="pre">3,</span> <span class="pre">3,</span> <span class="pre">5&gt;(...)</span></code>.</p></li>
<li><p>Si può cambiare l’ordine degli argomenti, p.es. <code class="docutils literal notranslate"><span class="pre">WithArgs&lt;3,</span> <span class="pre">2,</span> <span class="pre">1&gt;(...)</span></code>.</p></li>
<li><p>I tipi degli argomenti selezionati <em>non</em> devono corrispondere esattamente alla firma dell’azione interna. Funziona finché possono essere convertiti implicitamente negli argomenti corrispondenti dell’azione interna. Ad esempio, se il quarto argomento della funzione mock è un <code class="docutils literal notranslate"><span class="pre">int</span></code> e <code class="docutils literal notranslate"><span class="pre">my_action</span></code> accetta un <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">WithArg&lt;4&gt;(my_action)</span></code> funzionerà.</p></li>
</ul>
</section>
<section id="ignoring-arguments-in-action-functions">
<h4>Ignorare gli Argomenti nella Funzioni Azioni<a class="headerlink" href="#ignoring-arguments-in-action-functions" title="Link to this heading">¶</a></h4>
<p>La ricetta <a class="reference internal" href="#SelectingArgs"><span class="xref myst">selecting-an-action’s-arguments</span></a> ci ha mostrato un modo per far combaciare una funzione mock e un’azione con elenchi di argomenti incompatibili. Lo svantaggio è che racchiudere l’azione in <code class="docutils literal notranslate"><span class="pre">WithArgs&lt;...&gt;()</span></code> può diventare noioso per le persone che scrivono i test.</p>
<p>Se si sta definendo una funzione (o metodo, funtore, lambda, callback) da utilizzare con <code class="docutils literal notranslate"><span class="pre">Invoke*()</span></code> e non si è interessati ad alcuni dei suoi argomenti, un’alternativa a <code class="docutils literal notranslate"><span class="pre">WithArgs</span></code> consiste nel dichiarare gli argomenti non interessanti come <code class="docutils literal notranslate"><span class="pre">Unused</span></code>. Ciò rende la definizione meno confusa e meno fragile nel caso in cui cambino i tipi di argomenti poco interessanti. Potrebbe anche aumentare la possibilità che la funzione dell’azione possa essere riutilizzata. Per esempio, dato</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">label</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">),</span>
<span class="w">              </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
</pre></div>
</div>
<p>invece di</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>

<span class="kt">double</span><span class="w"> </span><span class="nf">DistanceToOriginWithLabel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">label</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">DistanceToOriginWithIndex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">DistanceToOriginWithLabel</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">DistanceToOriginWithIndex</span><span class="p">));</span>
</pre></div>
</div>
<p>si può scrivere</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Unused</span><span class="p">;</span>

<span class="kt">double</span><span class="w"> </span><span class="nf">DistanceToOrigin</span><span class="p">(</span><span class="n">Unused</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">DistanceToOrigin</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">DistanceToOrigin</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="sharing-actions">
<h4>Condivisione di Azioni<a class="headerlink" href="#sharing-actions" title="Link to this heading">¶</a></h4>
<p>Proprio come i matcher, un oggetto azione gMock è costituito da un puntatore a un oggetto di implementazione con conteggio dei riferimenti. Pertanto anche le azioni di copia sono consentite e molto efficienti. Quando l’ultima azione che fa riferimento all’oggetto di implementazione muore, l’oggetto di implementazione verrà eliminato.</p>
<p>Se si ha un’azione complessa che da utilizzare più e più volte, si potrebbe non doverla creare da zero ogni volta. Se l’azione non ha uno stato interno (cioè se fa sempre la stessa cosa indipendentemente da quante volte è stata chiamata), si può assegnarla a una variabile di azione e utilizzare quella variabile ripetutamente. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Action</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">DoAll</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">SetArgPointee</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">Action</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">set_flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DoAll</span><span class="p">(</span><span class="n">SetArgPointee</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
<span class="w">                                      </span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">set_flag</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">()</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">()</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>Tuttavia, se l’azione ha un proprio stato, si potrebbe rimanere sorpresi se si condivide l’oggetto dell’azione. Supponiamo di avere una action factory <code class="docutils literal notranslate"><span class="pre">IncrementCounter(init)</span></code> che crea un’azione che incrementa e restituisce un contatore il cui valore iniziale è <code class="docutils literal notranslate"><span class="pre">init</span></code>, utilizzando due azioni create dalla stessa espressione e utilizzando un’azione condivisa mostrerà comportamenti diversi. Esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">IncrementCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">IncrementCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">();</span><span class="w">  </span><span class="c1">// Returns 1.</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">();</span><span class="w">  </span><span class="c1">// Returns 2.</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThat</span><span class="p">();</span><span class="w">  </span><span class="c1">// Returns 1 - DoThat() uses a different</span>
<span class="w">                 </span><span class="c1">// counter than DoThis()&#39;s.</span>
</pre></div>
</div>
<p>contro</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Action</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">Action</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IncrementCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">();</span><span class="w">  </span><span class="c1">// Returns 1.</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">();</span><span class="w">  </span><span class="c1">// Returns 2.</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThat</span><span class="p">();</span><span class="w">  </span><span class="c1">// Returns 3 - the counter is shared.</span>
</pre></div>
</div>
</section>
<section id="testing-asynchronous-behavior">
<h4>Testare il Comportamento Asincrono<a class="headerlink" href="#testing-asynchronous-behavior" title="Link to this heading">¶</a></h4>
<p>Un problema spesso riscontrato con gMock è che può essere difficile testare il comportamento asincrono. Supponiamo di avere una classe <code class="docutils literal notranslate"><span class="pre">EventQueue</span></code> da testare e che sia stata creata un’interfaccia <code class="docutils literal notranslate"><span class="pre">EventDispatcher</span></code> separata in modo da poterla facilmente renderla mock. Tuttavia, l’implementazione della classe ha attivato tutti gli eventi su un thread in background, rendendo difficile la tempistica dei test. Si potrebbero semplicemente inserire le istruzioni <code class="docutils literal notranslate"><span class="pre">sleep()</span></code> e sperare per il meglio, ma ciò rende il comportamento del test non deterministico. Un modo migliore è quello di utilizzare le azioni gMock e gli oggetti <code class="docutils literal notranslate"><span class="pre">Notification</span></code> per forzare il test asincrono a comportarsi in modo sincrono.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockEventDispatcher</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">EventDispatcher</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">DispatchEvent</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">int32</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">EventQueueTest</span><span class="p">,</span><span class="w"> </span><span class="n">EnqueueEventTest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MockEventDispatcher</span><span class="w"> </span><span class="n">mock_event_dispatcher</span><span class="p">;</span>
<span class="w">  </span><span class="n">EventQueue</span><span class="w"> </span><span class="nf">event_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_event_dispatcher</span><span class="p">);</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">int32</span><span class="w"> </span><span class="n">kEventId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">321</span><span class="p">;</span>
<span class="w">  </span><span class="n">absl</span><span class="o">::</span><span class="n">Notification</span><span class="w"> </span><span class="n">done</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_event_dispatcher</span><span class="p">,</span><span class="w"> </span><span class="n">DispatchEvent</span><span class="p">(</span><span class="n">kEventId</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">([</span><span class="o">&amp;</span><span class="n">done</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">done</span><span class="p">.</span><span class="n">Notify</span><span class="p">();</span><span class="w"> </span><span class="p">});</span>

<span class="w">  </span><span class="n">event_queue</span><span class="p">.</span><span class="n">EnqueueEvent</span><span class="p">(</span><span class="n">kEventId</span><span class="p">);</span>
<span class="w">  </span><span class="n">done</span><span class="p">.</span><span class="n">WaitForNotification</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Nell’esempio sopra, impostiamo le nostre normali expectation gMock, ma poi aggiungiamo un’azione aggiuntiva per notificare l’oggetto <code class="docutils literal notranslate"><span class="pre">Notification</span></code>. Ora possiamo semplicemente chiamare <code class="docutils literal notranslate"><span class="pre">Notification::WaitForNotification()</span></code> nel thread principale per attendere il completamento della chiamata asincrona. Successivamente, la nostra suite di test è completa e possiamo uscire in sicurezza.</p>
<p>{: .callout .note} Nota: questo esempio ha uno svantaggio: ovvero, se la expectation non viene soddisfatta, il test verrà eseguito all’infinito. Alla fine andrà in timeout e fallirà, ma richiederà più tempo e sarà leggermente più difficile eseguire il debug. Per alleviare questo problema, si può utilizzare <code class="docutils literal notranslate"><span class="pre">WaitForNotificationWithTimeout(ms)</span></code> invece di <code class="docutils literal notranslate"><span class="pre">WaitForNotification()</span></code>.</p>
</section>
</section>
<section id="misc-recipes-on-using-gmock">
<h3>Ricette Varie sull’Uso di gMock<a class="headerlink" href="#misc-recipes-on-using-gmock" title="Link to this heading">¶</a></h3>
<section id="mocking-methods-that-use-move-only-types">
<h4>Mock di Metodi Che Usano Tipi Move-Only<a class="headerlink" href="#mocking-methods-that-use-move-only-types" title="Link to this heading">¶</a></h4>
<p>Il C++11 ha introdotto i <em>tipi move-only</em> (tipi di solo spostamento). Un valore «move-only-typed» può essere spostato da un oggetto a un altro, ma non può essere copiato. <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;T&gt;</span></code> è probabilmente il tipo di solo spostamento [move-only] più comunemente utilizzato.</p>
<p>Il mock di un metodo che accetta e/o restituisce tipi move-only presenta alcune sfide, ma nulla di insormontabile. Questa ricetta mostra come lo si può fare. Notare che il supporto per gli argomenti move-only di metodi è stato introdotto in gMock solo nell’aprile 2017; nel codice più vecchio si trovano dei <a class="reference internal" href="#LegacyMoveOnly"><span class="xref myst">workarounds</span></a> più complessi per la mancanza di questa funzionalità.</p>
<p>Diciamo che stiamo lavorando a un progetto immaginario che consente di pubblicare e condividere frammenti chiamati “buzzes”. Il codice utilizza questi tipi:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AccessLevel</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">kInternal</span><span class="p">,</span><span class="w"> </span><span class="n">kPublic</span><span class="w"> </span><span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Buzz</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">explicit</span><span class="w"> </span><span class="n">Buzz</span><span class="p">(</span><span class="n">AccessLevel</span><span class="w"> </span><span class="n">access</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Buzzer</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Buzzer</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeBuzz</span><span class="p">(</span><span class="n">StringPiece</span><span class="w"> </span><span class="n">text</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">ShareBuzz</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buzz</span><span class="p">,</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">timestamp</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Un oggetto <code class="docutils literal notranslate"><span class="pre">Buzz</span></code> rappresenta un frammento [snippet] pubblicato. Una classe che implementa l’interfaccia <code class="docutils literal notranslate"><span class="pre">Buzzer</span></code> è in grado di creare e condividere dei <code class="docutils literal notranslate"><span class="pre">Buzz</span></code>. I metodi in <code class="docutils literal notranslate"><span class="pre">Buzzer</span></code> possono restituire un <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Buzz&gt;</span></code> o ricevere un <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Buzz&gt;</span></code>. Ora dobbiamo mock-are <code class="docutils literal notranslate"><span class="pre">Buzzer</span></code> nei nostri test.</p>
<p>Per il mock di un metodo che accetta o restituisce tipi move-only, si usa semplicemente la familiare sintassi <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockBuzzer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Buzzer</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBuzz</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">StringPiece</span><span class="w"> </span><span class="n">text</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">ShareBuzz</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buzz</span><span class="p">,</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">timestamp</span><span class="p">),</span>
<span class="w">              </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Ora che abbiamo definito la classe mock, possiamo usarla nei test. Nei seguenti esempi di codice, assumiamo di aver definito un oggetto <code class="docutils literal notranslate"><span class="pre">MockBuzzer</span></code> chiamato <code class="docutils literal notranslate"><span class="pre">mock_buzzer_</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">MockBuzzer</span><span class="w"> </span><span class="n">mock_buzzer_</span><span class="p">;</span>
</pre></div>
</div>
<p>Per prima cosa vediamo come possiamo impostare le expectation sul metodo <code class="docutils literal notranslate"><span class="pre">MakeBuzz()</span></code>, che restituisce un <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Buzz&gt;</span></code>.</p>
<p>Come al solito, se si imposta una expectation senza un’azione (ad esempio la clausola <code class="docutils literal notranslate"><span class="pre">.WillOnce()</span></code> o la <code class="docutils literal notranslate"><span class="pre">.WillRepeatedly()</span></code>), quando si attiva la expectation, l’azione di default per quel metodo verrà intrapresa. Poiché <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;&gt;</span></code> ha un costruttore di default che restituisce un <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> nullo, questo è ciò che si ottiene se non si specifica un’azione:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">IsNull</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// Use the default action.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Triggers the previous EXPECT_CALL.</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">IsNull</span><span class="p">());</span>
</pre></div>
</div>
<p>Se non si è soddisfatti dell’azione di default, la si può modificare come al solito; vedere <a class="reference internal" href="#OnCall"><span class="xref myst">Impostazione delle Azioni di Default</span></a>.</p>
<p>Se c’è solo da restituire un valore move-only, lo si può usare in combinazione con <code class="docutils literal notranslate"><span class="pre">WillOnce</span></code>. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">)));</span>
<span class="w">  </span><span class="n">EXPECT_NE</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Tempo di quiz! Cosa accadrà se un’azione <code class="docutils literal notranslate"><span class="pre">Return</span></code> viene eseguita più di una volta (ad esempio scrivendo <code class="docutils literal notranslate"><span class="pre">...</span> <span class="pre">.WillRepeatedly(Return(std::move(...)));</span></code>)? Rifletteteci, dopo la prima volta che viene eseguita l’azione, il valore sorgente verrà consumato (poiché è un valore di solo spostamento [move-only]), quindi la volta successiva, non c’è alcun valore da spostare - si otterrà un errore a run-time secondo cui <code class="docutils literal notranslate"><span class="pre">Return(std::move(...))</span></code> può essere eseguito solo una volta.</p>
<p>Se c’è bisogno che il metodo mock faccia qualcosa di più del semplice spostamento di un valore di default, ricordarsi che si può sempre utilizzare un oggetto lambda o un richiamabile [callable], che può fare praticamente tutto:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">([](</span><span class="n">StringPiece</span><span class="w"> </span><span class="n">text</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">);</span>
<span class="w">      </span><span class="p">});</span>

<span class="w">  </span><span class="n">EXPECT_NE</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_NE</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Ogni volta che questa <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> si attiva, verrà creato e restituito un nuovo <code class="docutils literal notranslate"><span class="pre">unique_ptr&lt;Buzz&gt;</span></code>. Non lo si può fare con <code class="docutils literal notranslate"><span class="pre">Return(std::make_unique&lt;...&gt;(...))</span></code>.</p>
<p>Ciò riguarda la restituzione di valori move-only; ma come lavoriamo con metodi che accettano argomenti move-only? La risposta è che funzionano normalmente, anche se alcune azioni non verranno compilate quando uno qualsiasi degli argomenti del metodo è move-only. Si può sempre usare <code class="docutils literal notranslate"><span class="pre">Return</span></code>, o una <a class="reference internal" href="#FunctionsAsActions"><span class="xref myst">lambda o un funtore</span></a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Unused</span><span class="p">;</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span><span class="w"> </span><span class="n">ShareBuzz</span><span class="p">(</span><span class="n">NotNull</span><span class="p">(),</span><span class="w"> </span><span class="n">_</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">ShareBuzz</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">)),</span>
<span class="w">              </span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span><span class="w"> </span><span class="n">ShareBuzz</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span>
<span class="w">      </span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buzz</span><span class="p">,</span><span class="w"> </span><span class="n">Unused</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">buzz</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">ShareBuzz</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p>Molte azioni native (<code class="docutils literal notranslate"><span class="pre">WithArgs</span></code>, <code class="docutils literal notranslate"><span class="pre">WithoutArgs</span></code>,<code class="docutils literal notranslate"><span class="pre">DeleteArg</span></code>, <code class="docutils literal notranslate"><span class="pre">SaveArg</span></code>, …) potrebbero in linea di principio supportare argomenti move-only, ma il supporto per questo non è ancora implementato. Se questo è bloccante, segnalare un bug.</p>
<p>Alcune azioni (ad esempio <code class="docutils literal notranslate"><span class="pre">DoAll</span></code>) copiano i loro argomenti internamente, quindi non possono mai funzionare con oggetti non copiabili; si dovranno usare invece i funtori.</p>
<section id="legacy-workarounds-for-move-only-types-legacymoveonly">
<h5>Workarounds legacy per i tipi move-only {#LegacyMoveOnly}<a class="headerlink" href="#legacy-workarounds-for-move-only-types-legacymoveonly" title="Link to this heading">¶</a></h5>
<p>Il supporto per gli argomenti move-only di funzioni è stato introdotto in gMock solo nell’aprile del 2017. Nel codice precedente, si potrebbe riscontrare la seguente soluzione alternativa per la mancanza di questa funzionalità (non è più necessaria: la includiamo solo come riferimento):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockBuzzer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Buzzer</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">DoShareBuzz</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Buzz</span><span class="o">*</span><span class="w"> </span><span class="n">buzz</span><span class="p">,</span><span class="w"> </span><span class="n">Time</span><span class="w"> </span><span class="n">timestamp</span><span class="p">));</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">ShareBuzz</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buzz</span><span class="p">,</span><span class="w"> </span><span class="n">Time</span><span class="w"> </span><span class="n">timestamp</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">DoShareBuzz</span><span class="p">(</span><span class="n">buzz</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span><span class="w"> </span><span class="n">timestamp</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Il trucco sta nel delegare il metodo <code class="docutils literal notranslate"><span class="pre">ShareBuzz()</span></code> a un metodo mock (chiamiamolo <code class="docutils literal notranslate"><span class="pre">DoShareBuzz()</span></code>) che non accetta parametri move-only. Poi, invece di impostare le expectation su <code class="docutils literal notranslate"><span class="pre">ShareBuzz()</span></code>, si impostano su l metodo mock <code class="docutils literal notranslate"><span class="pre">DoShareBuzz()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">MockBuzzer</span><span class="w"> </span><span class="n">mock_buzzer_</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span><span class="w"> </span><span class="n">DoShareBuzz</span><span class="p">(</span><span class="n">NotNull</span><span class="p">(),</span><span class="w"> </span><span class="n">_</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// When one calls ShareBuzz() on the MockBuzzer like this, the call is</span>
<span class="w">  </span><span class="c1">// forwarded to DoShareBuzz(), which is mocked.  Therefore this statement</span>
<span class="w">  </span><span class="c1">// will trigger the above EXPECT_CALL.</span>
<span class="w">  </span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">ShareBuzz</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="making-the-compilation-faster">
<h4>Velocizzare la Compilazione<a class="headerlink" href="#making-the-compilation-faster" title="Link to this heading">¶</a></h4>
<p>Che ci si creda o meno, la <em>stragrande maggioranza</em> del tempo impiegato nella compilazione di una classe mock è nella generazione del suo costruttore e del distruttore, poiché eseguono compiti non banali (ad esempio la verifica delle expectation). Inoltre, i metodi mock con firme diverse hanno tipi diversi e quindi i loro costruttori/distruttori devono essere generati separatamente dal compilatore. Di conseguenza, se ci sono molti tipi diversi di metodi mock, la compilazione della classe mock può diventare molto lenta.</p>
<p>Se si riscontra una compilazione lenta, si può spostare la definizione del costruttore e del distruttore della classe mock fuori dal corpo della classe e in un file <code class="docutils literal notranslate"><span class="pre">.cc</span></code>. In questo modo, anche se si <code class="docutils literal notranslate"><span class="pre">#include</span></code> la classe mock in N file, il compilatore dovrà generare il suo costruttore e distruttore solo una volta, ne risulterà una compilazione molto più veloce.</p>
<p>Illustriamo l’idea con un esempio. Ecco la definizione di una classe mock prima di applicare questa ricetta:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// File mock_foo.h.</span>
<span class="p">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Since we don&#39;t declare the constructor or the destructor,</span>
<span class="w">  </span><span class="c1">// the compiler will generate them in every translation unit</span>
<span class="w">  </span><span class="c1">// where this mock class is used.</span>

<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">mock</span><span class="w"> </span><span class="n">methods</span><span class="w"> </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Dopo la modifica, sarebbe simile a:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// File mock_foo.h.</span>
<span class="p">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// The constructor and destructor are declared, but not defined, here.</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">MockFoo</span><span class="p">();</span>

<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">mock</span><span class="w"> </span><span class="n">methods</span><span class="w"> </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>e</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// File mock_foo.cc.</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;path/to/mock_foo.h&quot;</span>

<span class="c1">// The definitions may appear trivial, but the functions actually do a</span>
<span class="c1">// lot of things through the constructors/destructors of the member</span>
<span class="c1">// variables used to implement the mock methods.</span>
<span class="n">MockFoo</span><span class="o">::</span><span class="n">MockFoo</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="n">MockFoo</span><span class="o">::~</span><span class="n">MockFoo</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
</section>
<section id="forcing-a-verification">
<h4>Forzare una Verifica<a class="headerlink" href="#forcing-a-verification" title="Link to this heading">¶</a></h4>
<p>Quando verrà distrutto, l’oggetto mock verificherà automaticamente che tutte le sue expectation siano state soddisfatte e, in caso contrario, genererà errori di googletest. Questo è conveniente perché lascia con una cosa in meno di cui preoccuparsi. Cioè, a meno che non si sia sicuri che l’oggetto mock verrà distrutto.</p>
<p>Come è possibile che l’oggetto mock alla fine non venga distrutto? Ebbene, potrebbe essere creato nell’heap e posseduto [own] dal codice che si sta testando Supponiamo che ci sia un bug in quel codice e che non si effettui correttamente il delete dell’oggetto mock: si potrebbe finire con un test positivo quando in realtà c’è un bug.</p>
<p>L’utilizzo di un «heap checker» è una buona idea e può alleviare i problemi, ma la sua implementazione non è affidabile al 100%. Quindi, a volte si vuole <em>forzare</em> gMock a verificare un oggetto mock prima che venga (si spera) distrutto. Lo si può fare con <code class="docutils literal notranslate"><span class="pre">Mock::VerifyAndClearExpectations(&amp;mock_object)</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">MyServerTest</span><span class="p">,</span><span class="w"> </span><span class="n">ProcessesRequest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Mock</span><span class="p">;</span>

<span class="w">  </span><span class="n">MockFoo</span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MockFoo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="p">...)...;</span>
<span class="w">  </span><span class="c1">// ... other expectations ...</span>

<span class="w">  </span><span class="c1">// server now owns foo.</span>
<span class="w">  </span><span class="n">MyServer</span><span class="w"> </span><span class="nf">server</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="w">  </span><span class="n">server</span><span class="p">.</span><span class="n">ProcessRequest</span><span class="p">(...);</span>

<span class="w">  </span><span class="c1">// In case that server&#39;s destructor will forget to delete foo,</span>
<span class="w">  </span><span class="c1">// this will verify the expectations anyway.</span>
<span class="w">  </span><span class="n">Mock</span><span class="o">::</span><span class="n">VerifyAndClearExpectations</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// server is destroyed when it goes out of scope here.</span>
</pre></div>
</div>
<p>{: .callout .tip} <strong>Tip:</strong> La funzione <code class="docutils literal notranslate"><span class="pre">Mock::VerifyAndClearExpectations()</span></code> restituisce un <code class="docutils literal notranslate"><span class="pre">bool</span></code> per indicare se la verifica ha avuto esito positivo (<code class="docutils literal notranslate"><span class="pre">true</span></code> per sì), quindi si può racchiudere la chiamata alla funzione all’interno di <code class="docutils literal notranslate"><span class="pre">ASSERT_TRUE()</span></code> se non ha senso andare oltre in caso quando la verifica non è riuscita.</p>
<p>Non stabilire nuove expectation dopo aver verificato e ripulito un mock dopo il suo utilizzo. L’impostazione delle expectation dopo il codice che esercita il mock ha un comportamento indefinito. Vedere <span class="xref myst">Uso dei Mock nei Test</span> per ulteriori informazioni.</p>
</section>
<section id="using-checkpoints-usingcheckpoints">
<h4>Uso dei Checkpoint {#UsingCheckPoints}<a class="headerlink" href="#using-checkpoints-usingcheckpoints" title="Link to this heading">¶</a></h4>
<p>A volte si deve testare il comportamento di un oggetto mock in fasi le cui dimensioni sono gestibili, oppure si devono impostare expectation più dettagliate su quali chiamate API richiamano quali funzioni mock.</p>
<p>Una tecnica utilizzabile è quella di mettere le expectation in una sequenza e inserire chiamate a una funzione fittizia di «checkpoint» in punti specifici. Poi si può verificare che le chiamate alle funzioni mock avvengano al momento giusto. Ad esempio, per testare il codice:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>e per verificare che <code class="docutils literal notranslate"><span class="pre">Foo(1)</span></code> e <code class="docutils literal notranslate"><span class="pre">Foo(3)</span></code> invochino entrambe <code class="docutils literal notranslate"><span class="pre">mock.Bar(&quot;a&quot;)</span></code>, ma che <code class="docutils literal notranslate"><span class="pre">Foo(2)</span></code> non invoca nulla, si può scrivere:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MockFunction</span><span class="p">;</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">InvokesBarCorrectly</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyMock</span><span class="w"> </span><span class="n">mock</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Class MockFunction&lt;F&gt; has exactly one mock method.  It is named</span>
<span class="w">  </span><span class="c1">// Call() and has type F.</span>
<span class="w">  </span><span class="n">MockFunction</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">check_point_name</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">check</span><span class="p">;</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">InSequence</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>

<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">check</span><span class="p">,</span><span class="w"> </span><span class="n">Call</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">check</span><span class="p">,</span><span class="w"> </span><span class="n">Call</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">check</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">check</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La specifica della expectation dice che la prima chiamata <code class="docutils literal notranslate"><span class="pre">Bar(&quot;a&quot;)</span></code> deve avvenire prima del checkpoint «1», la seconda chiamata <code class="docutils literal notranslate"><span class="pre">Bar(&quot;a&quot;)</span></code> deve avvenire dopo il checkpoint «2», e tra i due checkpoint non dovrebbe succedere nulla. I checkpoint espliciti chiariscono quale <code class="docutils literal notranslate"><span class="pre">Bar(&quot;a&quot;)</span></code> viene chiamata da quale chiamata a <code class="docutils literal notranslate"><span class="pre">Foo()</span></code>.</p>
</section>
<section id="mocking-destructors">
<h4>Mock dei Distruttori<a class="headerlink" href="#mocking-destructors" title="Link to this heading">¶</a></h4>
<p>A volte si vuol verificare che un oggetto mock venga distrutto al momento giusto, ad es. dopo la chiamata a <code class="docutils literal notranslate"><span class="pre">bar-&gt;A()</span></code> ma prima di chiamare <code class="docutils literal notranslate"><span class="pre">bar-&gt;B()</span></code>. Sappiamo già che è possibile specificare vincoli sull”<a class="reference internal" href="#OrderedCalls"><span class="xref myst">ordine</span></a> delle chiamate alla funzione mock, quindi tutto ciò che dobbiamo fare è avere il mock del distruttore della funzione mock.</p>
<p>Sembra semplice, tranne che per un problema: un distruttore è una funzione speciale con una sintassi e una semantica speciali e la macro <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code> non funziona per questo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="n">MockFoo</span><span class="p">,</span><span class="w"> </span><span class="p">());</span><span class="w">  </span><span class="c1">// Won&#39;t compile!</span>
</pre></div>
</div>
<p>La buona notizia è che si può usare un semplice pattern per ottenere lo stesso effetto. Innanzitutto, si aggiunge una funzione mock <code class="docutils literal notranslate"><span class="pre">Die()</span></code> alla classe mock e la si chiama nel distruttore, in questo modo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// Add the following two lines to the mock class.</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Die</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>
<span class="w">  </span><span class="o">~</span><span class="n">MockFoo</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Die</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>(Se il nome <code class="docutils literal notranslate"><span class="pre">Die()</span></code> entra in conflitto con un simbolo esistente, si sceglie un altro nome). Ora, abbiamo tradotto il problema di testare quando un oggetto <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code> «muore» nel testare quando viene chiamato il metodo <code class="docutils literal notranslate"><span class="pre">Die()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">MockFoo</span><span class="o">*</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MockFoo</span><span class="p">;</span>
<span class="w">  </span><span class="n">MockBar</span><span class="o">*</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MockBar</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">InSequence</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Expects *foo to die after bar-&gt;A() and before bar-&gt;B().</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">());</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Die</span><span class="p">());</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>E questo è tutto.</p>
</section>
<section id="using-gmock-and-threads-usingthreads">
<h4>Usare gMock e i Thread {#UsingThreads}<a class="headerlink" href="#using-gmock-and-threads-usingthreads" title="Link to this heading">¶</a></h4>
<p>In una <strong>unit</strong> test, è meglio isolare e testare una parte di codice in un contesto a thread singolo. Ciò evita condizioni di «race» e «dead lock» e semplifica molto il debug del test.</p>
<p>Eppure la maggior parte dei programmi sono multi-thread e talvolta per testare qualcosa abbiamo bisogno di lavorarci sopra da più di un thread. gMock funziona anche per questo scopo.</p>
<p>Si ricordano i passaggi per utilizzare un mock:</p>
<ol class="arabic simple">
<li><p>Si crea un oggetto mock <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p></li>
<li><p>Se ne impostano le azioni e le expectation con <code class="docutils literal notranslate"><span class="pre">ON_CALL()</span></code> e con <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL()</span></code>.</p></li>
<li><p>Il codice da testare chiama i metodi di <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p></li>
<li><p>Facoltativamente, verificare e reimpostare il mock.</p></li>
<li><p>Distruggere il mock manualmente o lasciare che sia il codice sotto test a farlo. Il distruttore lo verificherà automaticamente.</p></li>
</ol>
<p>Seguendo queste semplici regole, i mock e i thread possono convivere felicemente:</p>
<ul class="simple">
<li><p>Si esegue il <em>codice di test</em> (in contrapposizione al codice da testare) in <em>un solo</em> thread. Ciò facilita il test da eseguire.</p></li>
<li><p>Ovviamente si può fare il passo #1 senza il locking.</p></li>
<li><p>Quando si eseguono i passi #2 e #5, nessun altro thread deve accedere a <code class="docutils literal notranslate"><span class="pre">foo</span></code>. Anch’esso ovvio, huh?</p></li>
<li><p>#3 e #4 possono essere eseguiti in un thread o in più thread, - come si vuole. gMock si occupa del locking, quindi non si deve fare nulla, a meno che non sia richiesto dalla logica del test.</p></li>
</ul>
<p>Se si violano le regole (ad esempio, se si impostano le expectation su un mock mentre un altro thread ne chiama i metodi), si otterrà un comportamento indefinito. Questo non è bello, quindi non farlo.</p>
<p>gMock garantisce che l’azione per una funzione mock venga eseguita nello stesso thread che ha chiamato la funzione mock. Ad esempio, in</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">action1</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">action2</span><span class="p">);</span>
</pre></div>
</div>
<p>se <code class="docutils literal notranslate"><span class="pre">Foo(1)</span></code> viene chiamato nel thread 1 e <code class="docutils literal notranslate"><span class="pre">Foo(2)</span></code> viene chiamato nel thread 2, gMock eseguirà <code class="docutils literal notranslate"><span class="pre">action1</span></code> nel thread 1 e <code class="docutils literal notranslate"><span class="pre">action2</span></code> nel thread 2.</p>
<p>gMock <em>non</em> impone una sequenza sulle azioni eseguite in thread diversi (farlo potrebbe creare situazioni di stallo poiché le azioni potrebbero dover cooperare). Ciò significa che l’esecuzione di <code class="docutils literal notranslate"><span class="pre">action1</span></code> e di <code class="docutils literal notranslate"><span class="pre">action2</span></code> nell’esempio precedente <em>può</em> interlacciarsi. Se questo è un problema, si deve aggiungere una logica di sincronizzazione adeguata ad <code class="docutils literal notranslate"><span class="pre">action1</span></code> e ad <code class="docutils literal notranslate"><span class="pre">action2</span></code> per rendere il test thread-safe.</p>
<p>Ricordarsi, inoltre, che <code class="docutils literal notranslate"><span class="pre">DefaultValue&lt;T&gt;</span></code> è una risorsa globale che potenzialmente influenza <em>tutti</em> gli oggetti mock attivi nel programma. Naturalmente, non ci si vorrà ingarbugliare con più thread o quando ci sono ancora mock in azione.</p>
</section>
<section id="controlling-how-much-information-gmock-prints">
<h4>Controllare la Quantità di Informazioni che Scrive gMock<a class="headerlink" href="#controlling-how-much-information-gmock-prints" title="Link to this heading">¶</a></h4>
<p>Quando gMock vede qualcosa che potrebbe essere un errore (ad esempio viene chiamata una funzione mock senza una expectation, ovvero una chiamata poco interessante, che è consentita ma forse si è dimenticato di vietare esplicitamente la chiamata), stampa alcuni messaggi di warning, incluso gli argomenti della funzione, il valore restituito e il trace dello stack. Si spera che questo ricordi di dare un’occhiata e vedere se c’è davvero un problema.</p>
<p>A volte si è sicuri che i test siano corretti e si potrebbe non apprezzare messaggi così amichevoli. Altre volte, si sta eseguendo il debug dei test o si sta imparando il comportamento del codice in esame e si vorrebbe poter osservare ogni chiamata mock che avviene (inclusi i valori degli argomenti, il valore restituito e il trace dello stack). Chiaramente, una sola taglia non va bene per tutti.</p>
<p>Si può controllare quanto gMock stampa utilizzando il flag della riga di comando <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=LEVEL</span></code>, dove <code class="docutils literal notranslate"><span class="pre">LEVEL</span></code> è una stringa con tre possibili valori:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">info</span></code>: gMock stamperà tutti i messaggi informativi, i warning e gli errori (i più dettagliati). Con questa impostazione, gMock loggerà anche tutte le chiamate alle macro <code class="docutils literal notranslate"><span class="pre">ON_CALL/EXPECT_CALL</span></code>. Includerà uno stack trace nei warning «uninteresting call».</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warning</span></code>: gMock stamperà sia i warning che gli errori (meno dettagliato); ometterà gli stack trace nei warning «uninteresting call». Questo è il default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code>: gMock stamperà solo gli errori (i meno dettagliati).</p></li>
</ul>
<p>In alternativa, si può aggiustare il valore del flag dai test in questo modo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">FLAGS_gmock_verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;error&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Se si trova che gMock stampa troppi stack frame con i suoi messaggi informativi o di warning, se ne può controllare la quantità con il flag <code class="docutils literal notranslate"><span class="pre">--gtest_stack_trace_depth=max_depth</span></code> flag.</p>
<p>Ora, usare giudiziosamente il flag giusto per consentire a gMock di servire al meglio!</p>
</section>
<section id="gaining-super-vision-into-mock-calls">
<h4>Ottenere la Supervisione nelle Chiamate Mock<a class="headerlink" href="#gaining-super-vision-into-mock-calls" title="Link to this heading">¶</a></h4>
<p>Abbiamo un test che usa gMock. Fallisce: gMock ti dice che alcune expectation non sono soddisfatte. Tuttavia, non si è sicuri del perché: c’è un errore di battitura da qualche parte nei matcher? È sbagliato l’ordine delle <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>? Oppure il codice sotto test sta facendo qualcosa di sbagliato? Come scoprirne la causa?</p>
<p>Non sarebbe bello se si avesse la vista a raggi X e si potessi effettivamente vedere la traccia di tutte le <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> e delle chiamate dei metodo mock mentre vengono effettuate? Per ogni chiamata, si potrebbero vedere i valori effettivi degli argomenti e a quale <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> gMock crede che corrisponda [match]? Se c’è ancora bisogno di aiuto per capire chi ha effettuato queste chiamate, potrebbe essere utile poter vedere lo stack trace completo ad ogni chiamata mock?</p>
<p>Si può sbloccare questo potere eseguendo il test con il flag <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=info</span></code>. Ad esempio, dato il programma di test:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gmock/gmock.h&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">HasSubstr</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">));</span>
<span class="p">};</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">mock</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)).</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">());</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">));</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">HasSubstr</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">)));</span>

<span class="w">  </span><span class="n">mock</span><span class="p">.</span><span class="n">F</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;good&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">mock</span><span class="p">.</span><span class="n">F</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>se lo si esegue con <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=info</span></code>, si vedrà questo output:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="o">[</span><span class="w"> </span>RUN<span class="w">       </span><span class="o">]</span><span class="w"> </span>Foo.Bar

foo_test.cc:14:<span class="w"> </span>EXPECT_CALL<span class="o">(</span>mock,<span class="w"> </span>F<span class="o">(</span>_,<span class="w"> </span>_<span class="o">))</span><span class="w"> </span>invoked
Stack<span class="w"> </span>trace:<span class="w"> </span>...

foo_test.cc:15:<span class="w"> </span>EXPECT_CALL<span class="o">(</span>mock,<span class="w"> </span>F<span class="o">(</span><span class="s2">&quot;a&quot;</span>,<span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="o">))</span><span class="w"> </span>invoked
Stack<span class="w"> </span>trace:<span class="w"> </span>...

foo_test.cc:16:<span class="w"> </span>EXPECT_CALL<span class="o">(</span>mock,<span class="w"> </span>F<span class="o">(</span><span class="s2">&quot;c&quot;</span>,<span class="w"> </span>HasSubstr<span class="o">(</span><span class="s2">&quot;d&quot;</span><span class="o">)))</span><span class="w"> </span>invoked
Stack<span class="w"> </span>trace:<span class="w"> </span>...

foo_test.cc:14:<span class="w"> </span>Mock<span class="w"> </span><span class="k">function</span><span class="w"> </span>call<span class="w"> </span>matches<span class="w"> </span>EXPECT_CALL<span class="o">(</span>mock,<span class="w"> </span>F<span class="o">(</span>_,<span class="w"> </span>_<span class="o">))</span>...
<span class="w">    </span>Function<span class="w"> </span>call:<span class="w"> </span>F<span class="o">(</span>@0x7fff7c8dad40<span class="s2">&quot;a&quot;</span>,@0x7fff7c8dad10<span class="s2">&quot;good&quot;</span><span class="o">)</span>
Stack<span class="w"> </span>trace:<span class="w"> </span>...

foo_test.cc:15:<span class="w"> </span>Mock<span class="w"> </span><span class="k">function</span><span class="w"> </span>call<span class="w"> </span>matches<span class="w"> </span>EXPECT_CALL<span class="o">(</span>mock,<span class="w"> </span>F<span class="o">(</span><span class="s2">&quot;a&quot;</span>,<span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="o">))</span>...
<span class="w">    </span>Function<span class="w"> </span>call:<span class="w"> </span>F<span class="o">(</span>@0x7fff7c8dada0<span class="s2">&quot;a&quot;</span>,@0x7fff7c8dad70<span class="s2">&quot;b&quot;</span><span class="o">)</span>
Stack<span class="w"> </span>trace:<span class="w"> </span>...

foo_test.cc:16:<span class="w"> </span>Failure
Actual<span class="w"> </span><span class="k">function</span><span class="w"> </span>call<span class="w"> </span>count<span class="w"> </span>doesn<span class="err">&#39;</span>t<span class="w"> </span>match<span class="w"> </span>EXPECT_CALL<span class="o">(</span>mock,<span class="w"> </span>F<span class="o">(</span><span class="s2">&quot;c&quot;</span>,<span class="w"> </span>HasSubstr<span class="o">(</span><span class="s2">&quot;d&quot;</span><span class="o">)))</span>...
<span class="w">         </span>Expected:<span class="w"> </span>to<span class="w"> </span>be<span class="w"> </span>called<span class="w"> </span>once
<span class="w">           </span>Actual:<span class="w"> </span>never<span class="w"> </span>called<span class="w"> </span>-<span class="w"> </span>unsatisfied<span class="w"> </span>and<span class="w"> </span>active
<span class="o">[</span><span class="w">  </span>FAILED<span class="w">  </span><span class="o">]</span><span class="w"> </span>Foo.Bar
</pre></div>
</div>
<p>Supponiamo che il bug sia che la <code class="docutils literal notranslate"><span class="pre">&quot;c&quot;</span></code> nella terza <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> sia un errore di battitura e in realtà dovrebbe essere <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>. Col messaggio precedente, si vedrebbe che l’effettiva chiamata <code class="docutils literal notranslate"><span class="pre">F(&quot;a&quot;,</span> <span class="pre">&quot;good&quot;)</span></code> corrisponde alla prima <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>, non alla terza come si pensava. Da ciò dovrebbe essere ovvio che il terzo <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> è scritto in modo errato. Caso risolto.</p>
<p>Se si è interessati alla call trace dei mock ma non a quelle dello stack, si può combinare <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=info</span></code> con <code class="docutils literal notranslate"><span class="pre">--gtest_stack_trace_depth=0</span></code> sulla riga di comando del test.</p>
</section>
<section id="running-tests-in-emacs">
<h4>Esecuzione di Test in Emacs<a class="headerlink" href="#running-tests-in-emacs" title="Link to this heading">¶</a></h4>
<p>Se si creano ed eseguono i test in Emacs utilizzando il comando <code class="docutils literal notranslate"><span class="pre">M-x</span> <span class="pre">google-compile</span></code> (come fanno molti utenti di googletest), le posizioni dei sorgenti di gMock e gli errori di googletest verranno evidenziati. Basta premere <code class="docutils literal notranslate"><span class="pre">&lt;Enter&gt;</span></code> su uno di essi e si verrà indirizzati alla riga incriminata. Oppure si può semplicemente digitare <code class="docutils literal notranslate"><span class="pre">C-x</span></code> per passare all’errore successivo.</p>
<p>Per semplificarlo ulteriormente, si possono aggiungere le seguenti righe al file <code class="docutils literal notranslate"><span class="pre">~/.emacs</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(global-set-key &quot;\M-m&quot;  &#39;google-compile)  ; m is for make
(global-set-key [M-down] &#39;next-error)
(global-set-key [M-up]  &#39;(lambda () (interactive) (next-error -1)))
</pre></div>
</div>
<p>Poi si può digitare <code class="docutils literal notranslate"><span class="pre">M-m</span></code> per avviare una build (se si vuole eseguire anche il test, assicurarsi solo che <code class="docutils literal notranslate"><span class="pre">foo_test.run</span></code> o <code class="docutils literal notranslate"><span class="pre">runtests</span></code> sia nel comando di compilazione fornito dopo aver digitato <code class="docutils literal notranslate"><span class="pre">M-m</span></code>, o <code class="docutils literal notranslate"><span class="pre">M-up</span></code>/<code class="docutils literal notranslate"><span class="pre">M-down</span></code> per spostarsi avanti e indietro tra gli errori.</p>
</section>
</section>
<section id="extending-gmock">
<h3>Estendere gMock<a class="headerlink" href="#extending-gmock" title="Link to this heading">¶</a></h3>
<section id="writing-new-matchers-quickly-newmatchers">
<h4>Scrivere Rapidamente Nuovi Matcher {#NewMatchers}<a class="headerlink" href="#writing-new-matchers-quickly-newmatchers" title="Link to this heading">¶</a></h4>
<p>{: .callout .warning} ATTENZIONE: gMock non garantisce quando o quante volte un matcher verrà invocato. Pertanto, tutti i matcher devono essere funzionalmente puri. Consultare <a class="reference internal" href="#PureMatchers"><span class="xref myst">questa sezione</span></a> per ulteriori dettagli.</p>
<p>La famiglia delle macro <code class="docutils literal notranslate"><span class="pre">MATCHER*</span></code> può essere utilizzata per definire facilmente dei matcher custom. La sintassi:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">description_string_expression</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">statements</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>definirà un matcher con il nome dato che esegue le istruzioni, che deve restituire un <code class="docutils literal notranslate"><span class="pre">bool</span></code> per indicare se la corrispondenza ha successo. All’interno delle istruzioni, si può fare riferimento al valore a cui corrisponde <code class="docutils literal notranslate"><span class="pre">arg</span></code> e fare riferimento al suo tipo tramite <code class="docutils literal notranslate"><span class="pre">arg_type</span></code>.</p>
<p>La <em>description string</em> è un’espressione di tipo <code class="docutils literal notranslate"><span class="pre">string</span></code> che documenta ciò che fa il matcher e viene utilizzata per generare il messaggio di errore quando la corrispondenza fallisce. Può (e dovrebbe) fare riferimento alla variabile <code class="docutils literal notranslate"><span class="pre">bool</span></code> speciale <code class="docutils literal notranslate"><span class="pre">negation</span></code> e dovrebbe valutare la descrizione del matcher quando <code class="docutils literal notranslate"><span class="pre">negation</span></code> è <code class="docutils literal notranslate"><span class="pre">false</span></code>, o quello della negazione del matcher quando <code class="docutils literal notranslate"><span class="pre">negation</span></code> è <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Per comodità, supponiamo che la stringa della descrizione sia vuota (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>), nel qual caso gMock utilizzerà la sequenza di parole nel nome del matcher come descrizione.</p>
<section id="basic-example">
<h5>Basic Example<a class="headerlink" href="#basic-example" title="Link to this heading">¶</a></h5>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">arg</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>consente di scrivere</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Expects mock_foo.Bar(n) to be called where n is divisible by 7.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">()));</span>
</pre></div>
</div>
<p>o,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Not</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// Verifies that a value is divisible by 7 and the other is not.</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">some_expression</span><span class="p">,</span><span class="w"> </span><span class="n">IsDivisibleBy7</span><span class="p">());</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">some_other_expression</span><span class="p">,</span><span class="w"> </span><span class="n">Not</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">()));</span>
</pre></div>
</div>
<p>Se le affermazioni di cui sopra falliscono, stamperanno qualcosa come:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span>Value<span class="w"> </span>of:<span class="w"> </span>some_expression
<span class="w">  </span>Expected:<span class="w"> </span>is<span class="w"> </span>divisible<span class="w"> </span>by<span class="w"> </span><span class="m">7</span>
<span class="w">    </span>Actual:<span class="w"> </span><span class="m">27</span>
<span class="w">  </span>...
<span class="w">  </span>Value<span class="w"> </span>of:<span class="w"> </span>some_other_expression
<span class="w">  </span>Expected:<span class="w"> </span>not<span class="w"> </span><span class="o">(</span>is<span class="w"> </span>divisible<span class="w"> </span>by<span class="w"> </span><span class="m">7</span><span class="o">)</span>
<span class="w">    </span>Actual:<span class="w"> </span><span class="m">21</span>
</pre></div>
</div>
<p>dove le descrizioni <code class="docutils literal notranslate"><span class="pre">&quot;is</span> <span class="pre">divisible</span> <span class="pre">by</span> <span class="pre">7&quot;</span></code> e <code class="docutils literal notranslate"><span class="pre">&quot;not</span> <span class="pre">(is</span> <span class="pre">divisible</span> <span class="pre">by</span> <span class="pre">7)&quot;</span></code> vengono calcolate automaticamente dal nome del matcher <code class="docutils literal notranslate"><span class="pre">IsDivisibleBy7</span></code>.</p>
</section>
<section id="adding-custom-failure-messages">
<h5>Adding Custom Failure Messages<a class="headerlink" href="#adding-custom-failure-messages" title="Link to this heading">¶</a></h5>
<p>Come notato, le descrizioni generate automaticamente (specialmente quelle per la negazione) potrebbero non essere così eccezionali. Si possono sempre sovrascriverle con un’espressione <code class="docutils literal notranslate"><span class="pre">string</span></code> a scelta:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">,</span>
<span class="w">        </span><span class="n">absl</span><span class="o">::</span><span class="n">StrCat</span><span class="p">(</span><span class="n">negation</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;isn&#39;t&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;is&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; divisible by 7&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">arg</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Facoltativamente, si possono trasmettere informazioni aggiuntive a un argomento nascosto denominato <code class="docutils literal notranslate"><span class="pre">result_listener</span></code> per spiegare il risultato della corrispondenza [match]. Ad esempio, una definizione migliore di <code class="docutils literal notranslate"><span class="pre">IsDivisibleBy7</span></code> è:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">arg</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="o">*</span><span class="n">result_listener</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the remainder is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">arg</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Con questa definizione, l’affermazione di cui sopra darà un messaggio migliore:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span>Value<span class="w"> </span>of:<span class="w"> </span>some_expression
<span class="w">  </span>Expected:<span class="w"> </span>is<span class="w"> </span>divisible<span class="w"> </span>by<span class="w"> </span><span class="m">7</span>
<span class="w">    </span>Actual:<span class="w"> </span><span class="m">27</span><span class="w"> </span><span class="o">(</span>the<span class="w"> </span>remainder<span class="w"> </span>is<span class="w"> </span><span class="m">6</span><span class="o">)</span>
</pre></div>
</div>
</section>
<section id="using-expect-statements-in-matchers">
<h5>Using EXPECT_ Statements in Matchers<a class="headerlink" href="#using-expect-statements-in-matchers" title="Link to this heading">¶</a></h5>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">EXPECT_...</span></code> statements inside custom matcher definitions. In many cases, this allows you to write your matcher more concisely while still providing an informative error message. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER</span><span class="p">(</span><span class="n">IsDivisibleBy7</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">remainder</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you write a test that includes the line <code class="docutils literal notranslate"><span class="pre">EXPECT_THAT(27,</span> <span class="pre">IsDivisibleBy7());</span></code>,
you will get an error something like the following:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Expected<span class="w"> </span>equality<span class="w"> </span>of<span class="w"> </span>these<span class="w"> </span>values:
<span class="w">  </span>remainder
<span class="w">    </span>Which<span class="w"> </span>is:<span class="w"> </span><span class="m">6</span>
<span class="w">  </span><span class="m">0</span>
</pre></div>
</div>
</section>
<section id="matchandexplain">
<h5><code class="docutils literal notranslate"><span class="pre">MatchAndExplain</span></code><a class="headerlink" href="#matchandexplain" title="Link to this heading">¶</a></h5>
<p>Si dovrebbe consentire a <code class="docutils literal notranslate"><span class="pre">MatchAndExplain()</span></code> di stampare <em>qualsiasi informazione aggiuntiva</em> che possa aiutare un utente a comprendere il risultato della corrispondenza [match]. Notare che dovrebbe spiegare perché la corrispondenza ha successo in caso di successo (a meno che non sia ovvio) - questo è utile quando il matcher viene utilizzato all’interno di <code class="docutils literal notranslate"><span class="pre">Not()</span></code>. Non è necessario stampare il valore dell’argomento stesso, poiché gMock lo stampa già.</p>
</section>
<section id="argument-types">
<h5>Argument Types<a class="headerlink" href="#argument-types" title="Link to this heading">¶</a></h5>
<p>The type of the value being matched (<code class="docutils literal notranslate"><span class="pre">arg_type</span></code>) is determined by the context in which you use the matcher and is supplied to you by the compiler, so you don’t need to worry about declaring it (nor can you). Ciò consente al matcher di essere polimorfico. Ad esempio, <code class="docutils literal notranslate"><span class="pre">IsDivisibleBy7()</span></code> può essere utilizzato per corrispondere [match] a qualsiasi tipo in cui il valore di <code class="docutils literal notranslate"><span class="pre">(arg</span> <span class="pre">%</span> <span class="pre">7)</span> <span class="pre">==</span> <span class="pre">0</span></code> può essere convertito implicitamente in un <code class="docutils literal notranslate"><span class="pre">bool</span></code>. Nell’esempio <code class="docutils literal notranslate"><span class="pre">Bar(IsDivisibleBy7())</span></code> sopra, se il metodo <code class="docutils literal notranslate"><span class="pre">Bar()</span></code> accetta un <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_type</span></code> sarà <code class="docutils literal notranslate"><span class="pre">int</span></code>; se richiede un <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>, <code class="docutils literal notranslate"><span class="pre">arg_type</span></code> sarà <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span></code>; e così via.</p>
</section>
</section>
<section id="writing-new-parameterized-matchers-quickly">
<h4>Scrivere Rapidamente Nuovi Matcher Parametrizzati<a class="headerlink" href="#writing-new-parameterized-matchers-quickly" title="Link to this heading">¶</a></h4>
<p>A volte servirà un matcher che abbia parametri. Per questo si può usare la macro:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_P</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">param_name</span><span class="p">,</span><span class="w"> </span><span class="n">description_string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">statements</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>dove la description string può essere <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> o un’espressione <code class="docutils literal notranslate"><span class="pre">string</span></code> che fa riferimento a <code class="docutils literal notranslate"><span class="pre">negation</span></code> e a <code class="docutils literal notranslate"><span class="pre">param_name</span></code>.</p>
<p>Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_P</span><span class="p">(</span><span class="n">HasAbsoluteValue</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">abs</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>consentirà di scrivere:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">Blah</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">HasAbsoluteValue</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
</pre></div>
</div>
<p>che può portare a questo messaggio (assumendo che <code class="docutils literal notranslate"><span class="pre">n</span></code> sia 10):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span>Value<span class="w"> </span>of:<span class="w"> </span>Blah<span class="o">(</span><span class="s2">&quot;a&quot;</span><span class="o">)</span>
<span class="w">  </span>Expected:<span class="w"> </span>has<span class="w"> </span>absolute<span class="w"> </span>value<span class="w"> </span><span class="m">10</span>
<span class="w">    </span>Actual:<span class="w"> </span>-9
</pre></div>
</div>
<p>Notare che vengono stampati sia la descrizione del matcher che il suo parametro, rendendo il messaggio di facile comprensione.</p>
<p>Nel corpo della definizione del matcher, si può scrivere <code class="docutils literal notranslate"><span class="pre">foo_type</span></code> per fare riferimento al tipo di un parametro chiamato <code class="docutils literal notranslate"><span class="pre">foo</span></code>. Ad esempio, nel corpo di <code class="docutils literal notranslate"><span class="pre">MATCHER_P(HasAbsoluteValue,</span> <span class="pre">value)</span></code> sopra, si può scrivere <code class="docutils literal notranslate"><span class="pre">value_type</span></code> per fare riferimento al tipo di <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>gMock fornisce anche <code class="docutils literal notranslate"><span class="pre">MATCHER_P2</span></code>, <code class="docutils literal notranslate"><span class="pre">MATCHER_P3</span></code>, …, fino a <code class="docutils literal notranslate"><span class="pre">MATCHER_P10</span></code> per supportare i matcher multiparametro:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_Pk</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">param_1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">param_k</span><span class="p">,</span><span class="w"> </span><span class="n">description_string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">statements</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Notare che la stringa di descrizione personalizzata è per una particolare <em>istanza</em> del matcher, in cui i parametri sono stati associati a valori effettivi. Pertanto di solito i valori dei parametri faranno parte della descrizione. gMock consente di farlo facendo riferimento ai parametri del matcher nell’espressione della stringa della descrizione.</p>
<p>Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">PrintToString</span><span class="p">;</span>
<span class="n">MATCHER_P2</span><span class="p">(</span><span class="n">InClosedRange</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">hi</span><span class="p">,</span>
<span class="w">           </span><span class="n">absl</span><span class="o">::</span><span class="n">StrFormat</span><span class="p">(</span><span class="s">&quot;%s in range [%s, %s]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">negation</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;isn&#39;t&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;is&quot;</span><span class="p">,</span>
<span class="w">                           </span><span class="n">PrintToString</span><span class="p">(</span><span class="n">low</span><span class="p">),</span><span class="w"> </span><span class="n">PrintToString</span><span class="p">(</span><span class="n">hi</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">hi</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">EXPECT_THAT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">InClosedRange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span>
</pre></div>
</div>
<p>genererebbe un errore che contiene il messaggio:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span>Expected:<span class="w"> </span>is<span class="w"> </span><span class="k">in</span><span class="w"> </span>range<span class="w"> </span><span class="o">[</span><span class="m">4</span>,<span class="w"> </span><span class="m">6</span><span class="o">]</span>
</pre></div>
</div>
<p>Specificando <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> come descrizione, il messaggio di errore conterrà la sequenza di parole nel nome del matcher seguita dai valori dei parametri stampati come una tupla. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">MATCHER_P2</span><span class="p">(</span><span class="n">InClosedRange</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">,</span><span class="w"> </span><span class="n">hi</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_THAT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">InClosedRange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">));</span>
</pre></div>
</div>
<p>genererebbe un errore che contiene il testo:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="w">  </span>Expected:<span class="w"> </span><span class="k">in</span><span class="w"> </span>closed<span class="w"> </span>range<span class="w"> </span><span class="o">(</span><span class="m">4</span>,<span class="w"> </span><span class="m">6</span><span class="o">)</span>
</pre></div>
</div>
<p>Ai fini della tipizzazione, è possibile visualizzare</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_Pk</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">pk</span><span class="p">,</span><span class="w"> </span><span class="n">description_string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>come abbreviazione di</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">p1_type</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">pk_type</span><span class="o">&gt;</span>
<span class="n">FooMatcherPk</span><span class="o">&lt;</span><span class="n">p1_type</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">pk_type</span><span class="o">&gt;</span>
<span class="n">Foo</span><span class="p">(</span><span class="n">p1_type</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">pk_type</span><span class="w"> </span><span class="n">pk</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Scrivendo <code class="docutils literal notranslate"><span class="pre">Foo(v1,</span> <span class="pre">...,</span> <span class="pre">vk)</span></code>, il compilatore deduce i tipi dei parametri <code class="docutils literal notranslate"><span class="pre">v1</span></code>, …, e <code class="docutils literal notranslate"><span class="pre">vk</span></code> autonomamente. Se non soddisfa il risultato dell’inferenza del tipo, si possono specificare i tipi istanziando esplicitamente il template, come in <code class="docutils literal notranslate"><span class="pre">Foo&lt;long,</span> <span class="pre">bool&gt;(5,</span> <span class="pre">false)</span></code>. Come detto in precedenza, non si può (né si deve) specificare <code class="docutils literal notranslate"><span class="pre">arg_type</span></code> poiché viene determinato dal contesto in cui viene utilizzato il matcher.</p>
<p>Si può assegnare il risultato dell’espressione <code class="docutils literal notranslate"><span class="pre">Foo(p1,</span> <span class="pre">...,</span> <span class="pre">pk)</span></code> ad una variabile di tipo <code class="docutils literal notranslate"><span class="pre">FooMatcherPk&lt;p1_type,</span> <span class="pre">...,</span> <span class="pre">pk_type&gt;</span></code>. Questo può essere utile quando si compongono i matcher. I matcher che non hanno un parametro o ne hanno solo uno hanno tipi speciali: si può assegnare <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> a una variabile di tipo <code class="docutils literal notranslate"><span class="pre">FooMatcher</span></code> e assegnare <code class="docutils literal notranslate"><span class="pre">Foo(p)</span></code> a una variabile di tipo <code class="docutils literal notranslate"><span class="pre">FooMatcherP&lt;p_type&gt;</span></code>.</p>
<p>Sebbene sia possibile creare un’istanza di un template matcher con tipi riferimento, il passaggio dei parametri tramite puntatore in genere rende il codice più leggibile. Se però si deve comunque passare un parametro per riferimento, si tenga presente che nel messaggio di errore generato dal matcher si vedrà il valore dell’oggetto referenziato ma non il suo indirizzo.</p>
<p>Si può avere l’overload dei matcher con diversi numeri di parametri:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MATCHER_P</span><span class="p">(</span><span class="n">Blah</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">description_string_1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">MATCHER_P2</span><span class="p">(</span><span class="n">Blah</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">description_string_2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Sebbene sia forte la tentazione di utilizzare sempre le macro <code class="docutils literal notranslate"><span class="pre">MATCHER*</span></code> quando si definisce un nuovo matcher, di dovrebbe anche considerare di implementare direttamente l’interfaccia del matcher (vedere le ricette che seguono), soprattutto se c’è bisogno di usare molto il matcher. Sebbene questi approcci richiedano più lavoro, offrono un maggiore controllo sui tipi del valore da abbinare e sui parametri del matcher, il che in generale porta a messaggi di errore del compilatore migliori che ripagano nel lungo periodo. Consentono inoltre l’overloading di matcher in base ai tipi di parametri (invece che basarsi solo sul numero di parametri).</p>
</section>
<section id="writing-new-monomorphic-matchers">
<h4>Scrivere Nuovi Matcher Monomorfici<a class="headerlink" href="#writing-new-monomorphic-matchers" title="Link to this heading">¶</a></h4>
<p>A matcher of type <code class="docutils literal notranslate"><span class="pre">testing::Matcher&lt;T&gt;</span></code> implements the matcher interface for <code class="docutils literal notranslate"><span class="pre">T</span></code> and does two things: it tests whether a value of type <code class="docutils literal notranslate"><span class="pre">T</span></code> matches the matcher, and can describe what kind of values it matches. Quest’ultima capacità viene utilizzata per generare messaggi di errore leggibili quando le expectation vengono violate. Some matchers can even explain why it matches or doesn’t match a certain value, which can be helpful when the reason isn’t obvious.</p>
<p>Because a matcher of type <code class="docutils literal notranslate"><span class="pre">testing::Matcher&lt;T&gt;</span></code> for a particular type <code class="docutils literal notranslate"><span class="pre">T</span></code> can
only be used to match a value of type <code class="docutils literal notranslate"><span class="pre">T</span></code>, we call it «monomorphic.»</p>
<p>Un matcher di <code class="docutils literal notranslate"><span class="pre">T</span></code> deve dichiarare un typedef come:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">is_gtest_matcher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="p">;</span>
</pre></div>
</div>
<p>e supporta le seguenti operazioni:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Match a value and optionally explain into an ostream.</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">matched</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">matcher</span><span class="p">.</span><span class="n">MatchAndExplain</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">maybe_os</span><span class="p">);</span>
<span class="c1">// where `value` is of type `T` and</span>
<span class="c1">// `maybe_os` is of type `std::ostream*`, where it can be null if the caller</span>
<span class="c1">// is not interested in there textual explanation.</span>

<span class="n">matcher</span><span class="p">.</span><span class="n">DescribeTo</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="n">matcher</span><span class="p">.</span><span class="n">DescribeNegationTo</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="c1">// where `os` is of type `std::ostream*`.</span>
</pre></div>
</div>
<p>Se c’è bisogno di un matcher personalizzato ma <code class="docutils literal notranslate"><span class="pre">Truly()</span></code> non è una buona opzione (ad esempio, non soddisfa il modo in cui <code class="docutils literal notranslate"><span class="pre">Truly(predicate)</span></code> si descrive, oppure per rendere il matcher polimorfico come lo è <code class="docutils literal notranslate"><span class="pre">Eq(value)</span></code>), si può definire un matcher in due passaggi: prima si implementa l’interfaccia del matcher e poi si definisce una funzione factory per creare un’istanza del matcher. Il secondo passaggio non è strettamente necessario ma rende più gradevole la sintassi dell’utilizzo del matcher.</p>
<p>Ad esempio, si può definire un matcher per verificare se un <code class="docutils literal notranslate"><span class="pre">int</span></code> è divisibile per 7 e poi usarlo in questo modo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Matcher</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">DivisibleBy7Matcher</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">is_gtest_matcher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="p">;</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">MatchAndExplain</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;is divisible by 7&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;is not divisible by 7&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">Matcher</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">DivisibleBy7</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">DivisibleBy7Matcher</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">DivisibleBy7</span><span class="p">()));</span>
</pre></div>
</div>
<p>Il messaggio del matcher è migliorabile trasmettendo informazioni aggiuntive all’argomento <code class="docutils literal notranslate"><span class="pre">os</span></code> in <code class="docutils literal notranslate"><span class="pre">MatchAndExplain()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DivisibleBy7Matcher</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">MatchAndExplain</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">remainder</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;the remainder is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">remainder</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">remainder</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Poi, <code class="docutils literal notranslate"><span class="pre">EXPECT_THAT(x,</span> <span class="pre">DivisibleBy7());</span></code> può generare un messaggio come questo:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Value<span class="w"> </span>of:<span class="w"> </span>x
Expected:<span class="w"> </span>is<span class="w"> </span>divisible<span class="w"> </span>by<span class="w"> </span><span class="m">7</span>
<span class="w">  </span>Actual:<span class="w"> </span><span class="m">23</span><span class="w"> </span><span class="o">(</span>the<span class="w"> </span>remainder<span class="w"> </span>is<span class="w"> </span><span class="m">2</span><span class="o">)</span>
</pre></div>
</div>
<p>{: .callout .tip} Tip: per comodità, <code class="docutils literal notranslate"><span class="pre">MatchAndExplain()</span></code> può accettare un <code class="docutils literal notranslate"><span class="pre">MatchResultListener*</span></code> invece di <code class="docutils literal notranslate"><span class="pre">std::ostream*</span></code>.</p>
</section>
<section id="writing-new-polymorphic-matchers">
<h4>Scrivere Nuovi Matcher Polimorfici<a class="headerlink" href="#writing-new-polymorphic-matchers" title="Link to this heading">¶</a></h4>
<p>Unlike a monomorphic matcher, which can only be used to match a value of a
particular type, a <em>polymorphic</em> matcher is one that can be used to match values
of multiple types. For example, <code class="docutils literal notranslate"><span class="pre">Eq(5)</span></code> is a polymorhpic matcher as it can be
used to match an <code class="docutils literal notranslate"><span class="pre">int</span></code>, a <code class="docutils literal notranslate"><span class="pre">double</span></code>, a <code class="docutils literal notranslate"><span class="pre">float</span></code>, and so on. You should think of a
polymorphic matcher as a <em>matcher factory</em> as opposed to a
<code class="docutils literal notranslate"><span class="pre">testing::Matcher&lt;SomeType&gt;</span></code> - itself is not an actual matcher, but can be
implicitly converted to a <code class="docutils literal notranslate"><span class="pre">testing::Matcher&lt;SomeType&gt;</span></code> depending on the context.</p>
<p>Expanding what we learned above to polymorphic matchers is now as simple as
adding templates in the right place.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">NotNullMatcher</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">is_gtest_matcher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// To implement a polymorphic matcher, we just need to make MatchAndExplain a</span>
<span class="w">  </span><span class="c1">// template on its first argument.</span>

<span class="w">  </span><span class="c1">// In this example, we want to use NotNull() with any pointer, so</span>
<span class="w">  </span><span class="c1">// MatchAndExplain() accepts a pointer of any type as its first argument.</span>
<span class="w">  </span><span class="c1">// In general, you can define MatchAndExplain() as an ordinary method or</span>
<span class="w">  </span><span class="c1">// a method template, or even overload it.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">MatchAndExplain</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Describes the property of a value matching this matcher.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;is not NULL&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Describes the property of a value NOT matching this matcher.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;is NULL&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">NotNullMatcher</span><span class="w"> </span><span class="nf">NotNull</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">NotNullMatcher</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">NotNull</span><span class="p">()));</span><span class="w">  </span><span class="c1">// The argument must be a non-NULL pointer.</span>
</pre></div>
</div>
</section>
<section id="legacy-matcher-implementation">
<h4>Implementazione di Matcher Legacy<a class="headerlink" href="#legacy-matcher-implementation" title="Link to this heading">¶</a></h4>
<p>La definizione dei matcher era un po” più complicata, in quanto richiedeva diverse classi di supporto e funzioni virtuali. Per implementare un matcher per il tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> utilizzando l’API legacy si deve derivare da <code class="docutils literal notranslate"><span class="pre">MatcherInterface&lt;T&gt;</span></code> e chiamare <code class="docutils literal notranslate"><span class="pre">MakeMatcher</span></code> per costruire l’oggetto.</p>
<p>L’interfaccia è simile alla seguente:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MatchResultListener</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="c1">// Streams x to the underlying ostream; does nothing if the ostream</span>
<span class="w">  </span><span class="c1">// is NULL.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">MatchResultListener</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Returns the underlying ostream.</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="nf">stream</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MatcherInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">MatcherInterface</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Returns true if and only if the matcher matches x; also explains the match</span>
<span class="w">  </span><span class="c1">// result to &#39;listener&#39;.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">MatchAndExplain</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">MatchResultListener</span><span class="o">*</span><span class="w"> </span><span class="n">listener</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Describes this matcher to an ostream.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Describes the negation of this matcher to an ostream.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Fortunatamente, la maggior parte delle volte si può definire facilmente un matcher polimorfico con l’aiuto di <code class="docutils literal notranslate"><span class="pre">MakePolymorphicMatcher()</span></code>. Ecco un esempio di come si possa definire <code class="docutils literal notranslate"><span class="pre">NotNull()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MakePolymorphicMatcher</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MatchResultListener</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">PolymorphicMatcher</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">NotNullMatcher</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// To implement a polymorphic matcher, first define a COPYABLE class</span>
<span class="w">  </span><span class="c1">// that has three members MatchAndExplain(), DescribeTo(), and</span>
<span class="w">  </span><span class="c1">// DescribeNegationTo(), like the following.</span>

<span class="w">  </span><span class="c1">// In this example, we want to use NotNull() with any pointer, so</span>
<span class="w">  </span><span class="c1">// MatchAndExplain() accepts a pointer of any type as its first argument.</span>
<span class="w">  </span><span class="c1">// In general, you can define MatchAndExplain() as an ordinary method or</span>
<span class="w">  </span><span class="c1">// a method template, or even overload it.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">MatchAndExplain</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">,</span>
<span class="w">                       </span><span class="n">MatchResultListener</span><span class="o">*</span><span class="w"> </span><span class="cm">/* listener */</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Describes the property of a value matching this matcher.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;is not NULL&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Describes the property of a value NOT matching this matcher.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DescribeNegationTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;is NULL&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// To construct a polymorphic matcher, pass an instance of the class</span>
<span class="c1">// to MakePolymorphicMatcher().  Note the return type.</span>
<span class="n">PolymorphicMatcher</span><span class="o">&lt;</span><span class="n">NotNullMatcher</span><span class="o">&gt;</span><span class="w"> </span><span class="n">NotNull</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MakePolymorphicMatcher</span><span class="p">(</span><span class="n">NotNullMatcher</span><span class="p">());</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">NotNull</span><span class="p">()));</span><span class="w">  </span><span class="c1">// The argument must be a non-NULL pointer.</span>
</pre></div>
</div>
<p>{: .callout .note} <strong>Nota:</strong> La classe matcher polimorfica <strong>non</strong> ha bisogno di ereditare da <code class="docutils literal notranslate"><span class="pre">MatcherInterface</span></code> o qualsiasi altra classe, e i suoi metodi <strong>non</strong> devono essere virtuali.</p>
<p>Come in un matcher monomorfico, si può spiegare il risultato della corrispondenza trasmettendo informazioni aggiuntive all’argomento <code class="docutils literal notranslate"><span class="pre">listener</span></code> in <code class="docutils literal notranslate"><span class="pre">MatchAndExplain()</span></code>.</p>
</section>
<section id="implementing-composite-matchers-compositematchers">
<h4>Implementing Composite Matchers {#CompositeMatchers}<a class="headerlink" href="#implementing-composite-matchers-compositematchers" title="Link to this heading">¶</a></h4>
<p>Sometimes we want to define a matcher that takes other matchers as parameters.
For example, <code class="docutils literal notranslate"><span class="pre">DistanceFrom(target,</span> <span class="pre">m)</span></code> is a polymorphic matcher that takes a
matcher <code class="docutils literal notranslate"><span class="pre">m</span></code> as a parameter. It tests that the distance from <code class="docutils literal notranslate"><span class="pre">target</span></code> to the
value being matched satisfies sub-matcher <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p>If you are implementing such a composite matcher, you’ll need to generate the
description of the matcher based on the description(s) of its sub-matcher(s).
You can see the implementation of <code class="docutils literal notranslate"><span class="pre">DistanceFrom()</span></code> in
<code class="docutils literal notranslate"><span class="pre">googlemock/include/gmock/gmock-matchers.h</span></code> for an example. In particular, pay
attention to <code class="docutils literal notranslate"><span class="pre">DistanceFromMatcherImpl</span></code>. Notice that it stores the sub-matcher as
a <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">Matcher&lt;const</span> <span class="pre">Distance&amp;&gt;</span> <span class="pre">distance_matcher_</span></code> instead of a polymorphic
matcher - this allows it to call <code class="docutils literal notranslate"><span class="pre">distance_matcher_.DescribeTo(os)</span></code> to describe
the sub-matcher. If the sub-matcher is stored as a polymorphic matcher instead,
it would not be possible to get its description as in general polymorphic
matchers don’t know how to describe themselves - they are matcher factories
instead of actual matchers; only after being converted to <code class="docutils literal notranslate"><span class="pre">Matcher&lt;SomeType&gt;</span></code>
can they be described.</p>
</section>
<section id="writing-new-cardinalities">
<h4>Scrivere Nuove Cardinalità<a class="headerlink" href="#writing-new-cardinalities" title="Link to this heading">¶</a></h4>
<p>Una cardinalità viene utilizzata in <code class="docutils literal notranslate"><span class="pre">Times()</span></code> per dire a gMock quante volte ci si aspetta che avvenga una chiamata. Non deve essere esatta. Ad esempio, si può dire <code class="docutils literal notranslate"><span class="pre">AtLeast(5)</span></code> o <code class="docutils literal notranslate"><span class="pre">Between(2,</span> <span class="pre">4)</span></code>.</p>
<p>Se l”<span class="xref myst">insieme nativo</span> delle cardinalità non è sufficiente, se ne può definire uno implementando la seguente interfaccia (nel namespace <code class="docutils literal notranslate"><span class="pre">testing</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">CardinalityInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">CardinalityInterface</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Returns true if and only if call_count calls will satisfy this cardinality.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsSatisfiedByCallCount</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">call_count</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Returns true if and only if call_count calls will saturate this</span>
<span class="w">  </span><span class="c1">// cardinality.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsSaturatedByCallCount</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">call_count</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Describes self to an ostream.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Ad esempio, per specificare che una chiamata deve avvenire un numero pari di volte, è possibile scrivere</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Cardinality</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">CardinalityInterface</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MakeCardinality</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">EvenNumberCardinality</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">CardinalityInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsSatisfiedByCallCount</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">call_count</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">call_count</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsSaturatedByCallCount</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">call_count</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">DescribeTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">*</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;called even number of times&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">Cardinality</span><span class="w"> </span><span class="nf">EvenNumber</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MakeCardinality</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">EvenNumberCardinality</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">EvenNumber</span><span class="p">());</span>
</pre></div>
</div>
</section>
<section id="writing-new-actions-quicknewactions">
<h4>Scrivere Nuove Action {#QuickNewActions}<a class="headerlink" href="#writing-new-actions-quicknewactions" title="Link to this heading">¶</a></h4>
<p>Se le azioni [action] native non funzionano, se ne può facilmente definirne una propria. Tutto ciò di cui si ha bisogno è un operatore di chiamata con una firma compatibile con la funzione mock-ata. Poi si può usare una lambda:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MockFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mock</span><span class="p">;</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Call</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">([](</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">mock</span><span class="p">.</span><span class="n">AsStdFunction</span><span class="p">()(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span>
</pre></div>
</div>
<p>O una struct con un operatore di chiamata (anche uno basato su template):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MultiplyBy</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">multiplier</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">multiplier</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Then use:</span>
<span class="c1">// EXPECT_CALL(...).WillOnce(MultiplyBy{7});</span>
</pre></div>
</div>
<p>Va bene anche che il callable non accetti argomenti, ignorando gli argomenti forniti alla funzione mock:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MockFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mock</span><span class="p">;</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Call</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">([]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">mock</span><span class="p">.</span><span class="n">AsStdFunction</span><span class="p">()(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">17</span><span class="p">);</span>
</pre></div>
</div>
<p>Se utilizzato con <code class="docutils literal notranslate"><span class="pre">WillOnce</span></code>, il callable può presupporre che verrà chiamato al massimo una volta e può essere di tipo move-only:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// An action that contains move-only types and has an &amp;&amp;-qualified operator,</span>
<span class="c1">// demanding in the type system that it be called at most once. This can be</span>
<span class="c1">// used with WillOnce, but the compiler will reject it if handed to</span>
<span class="c1">// WillRepeatedly.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MoveOnlyAction</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">move_only_state</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">operator</span><span class="p">()()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">move_only_state</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">MockFunction</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mock</span><span class="p">;</span>
<span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Call</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">MoveOnlyAction</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">17</span><span class="p">)});</span>
<span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">mock</span><span class="p">.</span><span class="n">AsStdFunction</span><span class="p">()(),</span><span class="w"> </span><span class="n">Pointee</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="mi">17</span><span class="p">)));</span>
</pre></div>
</div>
<p>Più in generale, da utilizzare con una funzione mock la cui firma è <code class="docutils literal notranslate"><span class="pre">R(Args...)</span></code> l’oggetto può essere qualsiasi cosa convertibile in <code class="docutils literal notranslate"><span class="pre">OnceAction&lt;R(Args...)&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">Action&lt;R(Args...)&gt;</span></code>. La differenza tra i due è che <code class="docutils literal notranslate"><span class="pre">OnceAction</span></code> ha requisiti più deboli (<code class="docutils literal notranslate"><span class="pre">Action</span></code> richiede un input con costruttore-copia che può essere chiamato ripetutamente mentre <code class="docutils literal notranslate"><span class="pre">OnceAction</span></code> richiede un costruttore-move e supporta operatori di chiamata qualificati <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>), ma può essere utilizzato solo con <code class="docutils literal notranslate"><span class="pre">WillOnce</span></code>. <code class="docutils literal notranslate"><span class="pre">OnceAction</span></code> è in genere rilevante solo quando si supportano tipi o azioni move-only che richiedono che un type-system garantisca che verranno chiamati al massimo una volta.</p>
<p>In genere non è necessario fare riferimento direttamente ai template <code class="docutils literal notranslate"><span class="pre">OnceAction</span></code> e <code class="docutils literal notranslate"><span class="pre">Action</span></code> nelle action: basta una struct o una classe con un operatore di chiamata, come negli esempi precedenti. Ma azioni polimorfiche più sofisticate che necessitano di conoscere il tipo di ritorno specifico della funzione mock possono definire operatori di conversione basati su template per renderlo possibile. Per gli esempi consultare <code class="docutils literal notranslate"><span class="pre">gmock-actions.h</span></code>.</p>
<section id="legacy-macro-based-actions">
<h5>Action Legacy basate su macro<a class="headerlink" href="#legacy-macro-based-actions" title="Link to this heading">¶</a></h5>
<p>Prima di C++11 le azioni basate su funtori non erano supportate; il vecchio modo di scriverle era attraverso una serie di macro <code class="docutils literal notranslate"><span class="pre">ACTION*</span></code>. Suggeriamo di evitarle nel nuovo codice; si nasconde molta logica dietro la macro, portando potenzialmente a errori del compilatore difficili da comprendere. Tuttavia, li descriviamo qui per completezza.</p>
<p>Scrivendo</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">statements</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>nello scope di un namespace (cioè non all’interno di una classe o funzione), si definirà un’azione con il nome dato che esegue le istruzioni. Il valore restituito dalle <code class="docutils literal notranslate"><span class="pre">istruzioni</span></code> verrà utilizzato come valore di ritorno dell’azione. All’interno delle istruzioni, si può fare riferimento all’argomento K-esimo (in base 0) della funzione mock come <code class="docutils literal notranslate"><span class="pre">argK</span></code>. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION</span><span class="p">(</span><span class="n">IncrementArg1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">arg1</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>consente di scrivere</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"> </span><span class="n">WillOnce</span><span class="p">(</span><span class="n">IncrementArg1</span><span class="p">());</span>
</pre></div>
</div>
<p>Notare che non è necessario specificare i tipi degli argomenti della funzione mock. Sicuramente il codice è type-safe: si riceverà un errore del compilatore se <code class="docutils literal notranslate"><span class="pre">*arg1</span></code> non supporta l’operatore <code class="docutils literal notranslate"><span class="pre">++</span></code>, o se il tipo di <code class="docutils literal notranslate"><span class="pre">++(*arg1)</span></code> non è compatibile con il tipo restituito della funzione mock.</p>
<p>Un altro esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">arg2</span><span class="p">)(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">  </span><span class="n">Blah</span><span class="p">();</span>
<span class="w">  </span><span class="o">*</span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">arg0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>definisce un’azione <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> che invoca l’argomento #2 (un puntatore a funzione) con 5, chiama la funzione <code class="docutils literal notranslate"><span class="pre">Blah()</span></code>, imposta il valore puntato dall’argomento #1 a 0 e restituisce l’argomento #0.</p>
<p>Per maggiore comodità e flessibilità, si possono utilizzare i seguenti simboli predefiniti nel corpo di <code class="docutils literal notranslate"><span class="pre">ACTION</span></code>:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-left"><p><code class="docutils literal notranslate"><span class="pre">argK_type</span></code></p></th>
<th class="head text-left"><p>Il tipo dell’argomento K-esimo (in base 0) della funzione mock</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></td>
<td class="text-left"><p>Tutti gli argomenti della funzione mock come una tupla</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">args_type</span></code></p></td>
<td class="text-left"><p>Il tipo di tutti gli argomenti della funzione mock come tupla</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">return_type</span></code></p></td>
<td class="text-left"><p>Il tipo restituito della funzione mock</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">function_type</span></code></p></td>
<td class="text-left"><p>Il tipo della funzione mock</p></td>
</tr>
</tbody>
</table>
<p>Ad esempio, quando si utilizza <code class="docutils literal notranslate"><span class="pre">ACTION</span></code> come azione stub per la funzione mock:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">DoSomething</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>abbiamo:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Simbolo Pre-definito</p></th>
<th class="head"><p>è [Bound] A</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">arg0</span></code></p></td>
<td><p>il valore di <code class="docutils literal notranslate"><span class="pre">flag</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">arg0_type</span></code></p></td>
<td><p>il tipo <code class="docutils literal notranslate"><span class="pre">bool</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">arg1</span></code></p></td>
<td><p>il valore di <code class="docutils literal notranslate"><span class="pre">ptr</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">arg1_type</span></code></p></td>
<td><p>il tipo <code class="docutils literal notranslate"><span class="pre">int*</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">args</span></code></p></td>
<td><p>la tuple <code class="docutils literal notranslate"><span class="pre">(flag,</span> <span class="pre">ptr)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">args_type</span></code></p></td>
<td><p>il tipo <code class="docutils literal notranslate"><span class="pre">std::tuple&lt;bool,</span> <span class="pre">int*&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">return_type</span></code></p></td>
<td><p>il tipo <code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">function_type</span></code></p></td>
<td><p>il tipo <code class="docutils literal notranslate"><span class="pre">int(bool,</span> <span class="pre">int*)</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="legacy-macro-based-parameterized-actions">
<h5>Azioni legacy parametrizzate basate su macro<a class="headerlink" href="#legacy-macro-based-parameterized-actions" title="Link to this heading">¶</a></h5>
<p>Talvolta si vuole parametrizzare una action che si definisce. Per questo abbiamo un’altra macro</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_P</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">statements</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_P</span><span class="p">(</span><span class="n">Add</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">arg0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>permetterà di scrivere</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns argument #0 + 5.</span>
<span class="p">...</span><span class="w"> </span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
</pre></div>
</div>
<p>Per comodità, utilizziamo il termine <em>argomenti</em> per i valori utilizzati per invocare la funzione mock e il termine <em>parametri</em> per i valori utilizzati per istanziare un’azione.</p>
<p>Notare che non è necessario fornire nemmeno il tipo del parametro. Supponiamo che il parametro si chiami <code class="docutils literal notranslate"><span class="pre">param</span></code>, si può anche utilizzare il simbolo definito da gMock <code class="docutils literal notranslate"><span class="pre">param_type</span></code> per fare riferimento al tipo del parametro come dedotto dal compilatore. Ad esempio, nel corpo di <code class="docutils literal notranslate"><span class="pre">ACTION_P(Add,</span> <span class="pre">n)</span></code> sopra, si può scrivere <code class="docutils literal notranslate"><span class="pre">n_type</span></code> per il tipo di <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>gMock fornisce anche <code class="docutils literal notranslate"><span class="pre">ACTION_P2</span></code>, <code class="docutils literal notranslate"><span class="pre">ACTION_P3</span></code> e così via per supportare azioni multi-parametro. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_P2</span><span class="p">(</span><span class="n">ReturnDistanceTo</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>permette di scrivere</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span><span class="w"> </span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnDistanceTo</span><span class="p">(</span><span class="mf">5.0</span><span class="p">,</span><span class="w"> </span><span class="mf">26.5</span><span class="p">));</span>
</pre></div>
</div>
<p>Si può vedere <code class="docutils literal notranslate"><span class="pre">ACTION</span></code> come un’azione parametrizzata degenerata in cui il numero di parametri è 0.</p>
<p>Si possono anche definire facilmente overload di azioni sul numero di parametri:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_P</span><span class="p">(</span><span class="n">Plus</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">ACTION_P2</span><span class="p">(</span><span class="n">Plus</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="restricting-the-type-of-an-argument-or-parameter-in-an-action">
<h4>Restrizioni sul tipo dell’argomento o del parametro in una ACTION<a class="headerlink" href="#restricting-the-type-of-an-argument-or-parameter-in-an-action" title="Link to this heading">¶</a></h4>
<p>Per la massima brevità e riusabilità, le macro <code class="docutils literal notranslate"><span class="pre">ACTION*</span></code> non chiedono di fornire i tipi degli argomenti della funzione mock né i parametri dell’azione. Lasciamo invece che sia il compilatore a dedurre i tipi.</p>
<p>A volte, tuttavia, potremmo voler essere più espliciti riguardo ai tipi. Ci sono diversi trucchi per farlo. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Makes sure arg0 can be converted to int.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arg0</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">instead</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">arg0</span><span class="w"> </span><span class="n">here</span><span class="w"> </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">ACTION_P</span><span class="p">(</span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Makes sure the type of arg1 is const char*.</span>
<span class="w">  </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">StaticAssertTypeEq</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">arg1_type</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Makes sure param can be converted to bool.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">param</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>dove <code class="docutils literal notranslate"><span class="pre">StaticAssertTypeEq</span></code> è un’asserzione in fase di compilazione in googletest che verifica che due tipi siano uguali.</p>
</section>
<section id="writing-new-action-templates-quickly">
<h4>Scrivere Rapidamente una Nuove Template di Action<a class="headerlink" href="#writing-new-action-templates-quickly" title="Link to this heading">¶</a></h4>
<p>A volte è necessario fornire a un’azione parametri template espliciti che non possono essere dedotti dai parametri del valore. <code class="docutils literal notranslate"><span class="pre">ACTION_TEMPLATE()</span></code> lo supporta e può essere visto come un’estensione di <code class="docutils literal notranslate"><span class="pre">ACTION()</span></code> e di <code class="docutils literal notranslate"><span class="pre">ACTION_P*()</span></code>.</p>
<p>La sintassi:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ACTION_TEMPLATE</span><span class="p">(</span><span class="n">ActionName</span><span class="p">,</span>
<span class="w">                </span><span class="n">HAS_m_TEMPLATE_PARAMS</span><span class="p">(</span><span class="n">kind1</span><span class="p">,</span><span class="w"> </span><span class="n">name1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">kind_m</span><span class="p">,</span><span class="w"> </span><span class="n">name_m</span><span class="p">),</span>
<span class="w">                </span><span class="n">AND_n_VALUE_PARAMS</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">p_n</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">statements</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>definisce una action template che accetta <em>m</em> parametri template espliciti e <em>n</em> parametri di valore, dove <em>m</em> è in [1, 10] e <em>n</em> è in [0, 10]. <code class="docutils literal notranslate"><span class="pre">name_i</span></code> è il nome dell”<em>i</em>-esimo parametro template, e <code class="docutils literal notranslate"><span class="pre">kind_i</span></code> specifica se si tratta di un <code class="docutils literal notranslate"><span class="pre">typename</span></code>, un integrale costante o un template. <code class="docutils literal notranslate"><span class="pre">p_i</span></code> è il nome del parametro valore <em>i</em>-esimo.</p>
<p>Esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// DuplicateArg&lt;k, T&gt;(output) converts the k-th argument of the mock</span>
<span class="c1">// function to type T and copies it to *output.</span>
<span class="n">ACTION_TEMPLATE</span><span class="p">(</span><span class="n">DuplicateArg</span><span class="p">,</span>
<span class="w">                </span><span class="c1">// Note the comma between int and k:</span>
<span class="w">                </span><span class="n">HAS_2_TEMPLATE_PARAMS</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">),</span>
<span class="w">                </span><span class="n">AND_1_VALUE_PARAMS</span><span class="p">(</span><span class="n">output</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">*</span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">k</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Per creare un’istanza di una action template, si scrive:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ActionName</span><span class="o">&lt;</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">t_m</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">v_n</span><span class="p">)</span>
</pre></div>
</div>
<p>dove le <code class="docutils literal notranslate"><span class="pre">t</span></code> sono gli argomenti template e le <code class="docutils literal notranslate"><span class="pre">v</span></code> sono gli argomenti valore. I tipi degli argomenti valore vengono dedotti dal compilatore. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">DuplicateArg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">));</span>
</pre></div>
</div>
<p>Per specificare esplicitamente i tipi degli argomenti valore, si possono fornire argomenti template aggiuntivi:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ActionName</span><span class="o">&lt;</span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">t_m</span><span class="p">,</span><span class="w"> </span><span class="n">u1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">u_k</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">v_n</span><span class="p">)</span>
</pre></div>
</div>
<p>dove <code class="docutils literal notranslate"><span class="pre">u_i</span></code> è il tipo desiderato di <code class="docutils literal notranslate"><span class="pre">v_i</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ACTION_TEMPLATE</span></code> e <code class="docutils literal notranslate"><span class="pre">ACTION</span></code>/<code class="docutils literal notranslate"><span class="pre">ACTION_P*</span></code> si possono overload-are sul numero di parametri valore, ma non sul numero di parametri template. Senza la restrizione, il significato di quanto segue non è chiaro:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">OverloadedAction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>Stiamo utilizzando un’azione con parametro tempale singolo in cui <code class="docutils literal notranslate"><span class="pre">bool</span></code> si riferisce al tipo di <code class="docutils literal notranslate"><span class="pre">x</span></code>, o un’azione con due parametri template in cui al compilatore viene chiesto di dedurre il tipo di <code class="docutils literal notranslate"><span class="pre">x</span></code>?</p>
</section>
<section id="using-the-action-object-s-type">
<h4>Usare il Tipo dell’Oggetto ACTION<a class="headerlink" href="#using-the-action-object-s-type" title="Link to this heading">¶</a></h4>
<p>Per scrivere una funzione che restituisce un oggetto <code class="docutils literal notranslate"><span class="pre">ACTION</span></code>, se ne deve conoscere il tipo. Il tipo dipende dalla macro utilizzata per definire l’azione e i tipi dei parametri. La regola è relativamente semplice:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Definizione Data</p></th>
<th class="head"><p>Espressione</p></th>
<th class="head"><p>Ha il Tipo</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ACTION(Foo)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Foo()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">FooAction</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ACTION_TEMPLATE(Foo,</span> <span class="pre">HAS_m_TEMPLATE_PARAMS(...),</span> <span class="pre">AND_0_VALUE_PARAMS())</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Foo&lt;t1,</span> <span class="pre">...,</span> <span class="pre">t_m&gt;()</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">FooAction&lt;t1,</span> <span class="pre">...,</span> <span class="pre">t_m&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ACTION_P(Bar,</span> <span class="pre">param)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Bar(int_value)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BarActionP&lt;int&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ACTION_TEMPLATE(Bar,</span> <span class="pre">HAS_m_TEMPLATE_PARAMS(...),</span> <span class="pre">AND_1_VALUE_PARAMS(p1))</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Bar&lt;t1,</span> <span class="pre">...,</span> <span class="pre">t_m&gt;(int_value)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BarActionP&lt;t1,</span> <span class="pre">...,</span> <span class="pre">t_m,</span> <span class="pre">int&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ACTION_P2(Baz,</span> <span class="pre">p1,</span> <span class="pre">p2)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Baz(bool_value,</span> <span class="pre">int_value)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BazActionP2&lt;bool,</span> <span class="pre">int&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ACTION_TEMPLATE(Baz,</span> <span class="pre">HAS_m_TEMPLATE_PARAMS(...),</span> <span class="pre">AND_2_VALUE_PARAMS(p1,</span> <span class="pre">p2))</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Baz&lt;t1,</span> <span class="pre">...,</span> <span class="pre">t_m&gt;(bool_value,</span> <span class="pre">int_value)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BazActionP2&lt;t1,</span> <span class="pre">...,</span> <span class="pre">t_m,</span> <span class="pre">bool,</span> <span class="pre">int&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
</tbody>
</table>
<p>Notare che dobbiamo scegliere suffissi diversi (<code class="docutils literal notranslate"><span class="pre">Action</span></code>, <code class="docutils literal notranslate"><span class="pre">ActionP</span></code>, <code class="docutils literal notranslate"><span class="pre">ActionP2</span></code>, ecc.) per azioni con numeri diversi di parametri valore, oppure non si possono avere overload delle definizioni delle azioni rispetto al loro numero.</p>
</section>
<section id="writing-new-monomorphic-actions-newmonoactions">
<h4>Scrivere Nuove Azioni Monomorfiche {#NewMonoActions}<a class="headerlink" href="#writing-new-monomorphic-actions-newmonoactions" title="Link to this heading">¶</a></h4>
<p>Sebbene le macro <code class="docutils literal notranslate"><span class="pre">ACTION*</span></code> siano molto comode, a volte sono inappropriate. Ad esempio, nonostante i trucchi mostrati nelle ricette precedenti, non consentono di specificare direttamente i tipi degli argomenti della funzione mock e dei parametri dell’azione, il che in generale porta a messaggi di errore del compilatore non ottimizzati che possono confondere gli utenti non esperti. Inoltre, non consentono overload di azioni basate sui tipi di parametri senza eseguire alcuni passaggi.</p>
<p>Un’alternativa alle macro <code class="docutils literal notranslate"><span class="pre">ACTION*</span></code> è implementare <code class="docutils literal notranslate"><span class="pre">::testing::ActionInterface&lt;F&gt;</span></code>, dove <code class="docutils literal notranslate"><span class="pre">F</span></code> è il tipo della funzione mock in cui verrà utilizzata l’azione. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">F</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ActionInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">ActionInterface</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Performs the action.  Result is the return type of function type</span>
<span class="w">  </span><span class="c1">// F, and ArgumentTuple is the tuple of arguments of F.</span>
<span class="w">  </span><span class="c1">//</span>

<span class="w">  </span><span class="c1">// For example, if F is int(bool, const string&amp;), then Result would</span>
<span class="w">  </span><span class="c1">// be int, and ArgumentTuple would be std::tuple&lt;bool, const string&amp;&gt;.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="nf">Perform</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ArgumentTuple</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Action</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">ActionInterface</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MakeAction</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">IncrementMethod</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>

<span class="k">class</span><span class="w"> </span><span class="nc">IncrementArgumentAction</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ActionInterface</span><span class="o">&lt;</span><span class="n">IncrementMethod</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">Perform</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span><span class="w">  </span><span class="c1">// Grabs the first argument.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">Action</span><span class="o">&lt;</span><span class="n">IncrementMethod</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IncrementArgument</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MakeAction</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">IncrementArgumentAction</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Baz</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">IncrementArgument</span><span class="p">());</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">Baz</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span><span class="w">  </span><span class="c1">// Should return 5 and change n to 6.</span>
</pre></div>
</div>
</section>
<section id="writing-new-polymorphic-actions-newpolyactions">
<h4>Scrivere Nuove Action Polimorfiche {#NewPolyActions}<a class="headerlink" href="#writing-new-polymorphic-actions-newpolyactions" title="Link to this heading">¶</a></h4>
<p>La ricetta precedente ha mostrato come definire una propria azione. Va tutto bene, tranne che è necessario conoscere il tipo della funzione in cui verrà utilizzata l’azione. A volte questo può essere un problema. Ad esempio, per utilizzare l’azione in funzioni con tipi <em>diversi</em> (ad esempio come <code class="docutils literal notranslate"><span class="pre">Return()</span></code> e <code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code>).</p>
<p>Se un’azione può essere utilizzata in diversi tipi di funzioni mock, diciamo che è <em>polimorfica</em>. La funzione template <code class="docutils literal notranslate"><span class="pre">MakePolymorphicAction()</span></code> semplifica la definizione di tale azione:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">testing</span><span class="w"> </span><span class="p">{</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Impl</span><span class="o">&gt;</span>
<span class="n">PolymorphicAction</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakePolymorphicAction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Impl</span><span class="o">&amp;</span><span class="w"> </span><span class="n">impl</span><span class="p">);</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace testing</span>
</pre></div>
</div>
<p>Come esempio, definiamo un’azione che restituisce il secondo argomento nell’elenco degli argomenti della funzione mock. Il primo passo è definire una classe di implementazione:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ReturnSecondArgumentAction</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Result</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ArgumentTuple</span><span class="o">&gt;</span>
<span class="w">  </span><span class="n">Result</span><span class="w"> </span><span class="n">Perform</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ArgumentTuple</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// To get the i-th (0-based) argument, use std::get(args).</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Questa classe di implementazione <em>non</em> ha bisogno di ereditare da una classe particolare. Ciò che conta è che deve avere un metodo template <code class="docutils literal notranslate"><span class="pre">Perform()</span></code>. Questo metodo template accetta gli argomenti della funzione mock come una tupla in un argomento <strong>singolo</strong> e restituisce il risultato dell’azione. Può essere <code class="docutils literal notranslate"><span class="pre">const</span></code> o meno, ma deve essere invocabile esattamente con un argomento template, che è il tipo del risultato. In altre parole, si deve essere in grado di chiamare <code class="docutils literal notranslate"><span class="pre">Perform&lt;R&gt;(args)</span></code> dove <code class="docutils literal notranslate"><span class="pre">R</span></code> è il tipo restituito dalla funzione mock e <code class="docutils literal notranslate"><span class="pre">args</span></code> sono i suoi argomenti in una tupla.</p>
<p>Poi, usiamo <code class="docutils literal notranslate"><span class="pre">MakePolymorphicAction()</span></code> per trasformare un’istanza della classe di implementazione nell’azione polimorfica di cui abbiamo bisogno. Sarà conveniente avere un wrapper per questo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">MakePolymorphicAction</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">PolymorphicAction</span><span class="p">;</span>

<span class="n">PolymorphicAction</span><span class="o">&lt;</span><span class="n">ReturnSecondArgumentAction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ReturnSecondArgument</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">MakePolymorphicAction</span><span class="p">(</span><span class="n">ReturnSecondArgumentAction</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ora si può utilizzare questa azione polimorfica nello stesso modo in cui si usano quelle native:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str2</span><span class="p">),</span>
<span class="w">              </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThis</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnSecondArgument</span><span class="p">());</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">DoThat</span><span class="p">).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnSecondArgument</span><span class="p">());</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThis</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will return 5.</span>
<span class="w">  </span><span class="n">foo</span><span class="p">.</span><span class="n">DoThat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hi&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Bye&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// Will return &quot;Hi&quot;.</span>
</pre></div>
</div>
</section>
<section id="teaching-gmock-how-to-print-your-values">
<h4>Insegnare a gMock Come Stampare i Propri Valori<a class="headerlink" href="#teaching-gmock-how-to-print-your-values" title="Link to this heading">¶</a></h4>
<p>Quando avviene una chiamata [uninteresting] o inaspettata [unexpected], gMock stampa i valori degli argomenti e lo stack trace come aiuto al debug. Anche le macro di asserzione come <code class="docutils literal notranslate"><span class="pre">EXPECT_THAT</span></code> e <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ</span></code> stampano i valori in questione quando l’asserzione fallisce. gMock e googletest lo fanno utilizzando la stampante di valori estensibile dall’utente di googletest.</p>
<p>Questa stampante sa lavorare con i tipi nativi di C++, gli array, i contenitori STL e qualsiasi tipo che supporti l’operatore <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>. Per gli altri tipi, stampa i byte grezzi nel valore e spera che l’utente possa capirlo. <span class="xref myst">La Guida Avanzata di GoogleTest</span> spiega come estendere la stampante per eseguire un lavoro migliore stampando il tipo particolare piuttosto che il dump dei byte.</p>
</section>
</section>
<section id="useful-mocks-created-using-gmock">
<h3>Mock Utili Creati Con gMock<a class="headerlink" href="#useful-mocks-created-using-gmock" title="Link to this heading">¶</a></h3>
<!--#include file="includes/g3_testing_LOGs.md"-->
<!--#include file="includes/g3_mock_callbacks.md"-->
<section id="mock-std-function-mockfunction">
<h4>Mock std::function {#MockFunction}<a class="headerlink" href="#mock-std-function-mockfunction" title="Link to this heading">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">std::function</span></code> è un tipo di funzione generale introdotto in C++11. È un modo preferito per passare le callback a nuove interfacce. Le funzioni sono copiabili e di solito non vengono passate tramite puntatore, il che le rende difficili da rendere mock. Niente paura - <code class="docutils literal notranslate"><span class="pre">MockFunction</span></code> è d’aiuto.</p>
<p><code class="docutils literal notranslate"><span class="pre">MockFunction&lt;R(T1,</span> <span class="pre">...,</span> <span class="pre">Tn)&gt;</span></code> ha un metodo mock <code class="docutils literal notranslate"><span class="pre">Call()</span></code> con la signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="nf">Call</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">Tn</span><span class="p">);</span>
</pre></div>
</div>
<p>C’è anche il metodo <code class="docutils literal notranslate"><span class="pre">AsStdFunction()</span></code>, che crea un proxy <code class="docutils literal notranslate"><span class="pre">std::function</span></code> che inoltra [forward] a Call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">Tn</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AsStdFunction</span><span class="p">();</span>
</pre></div>
</div>
<p>Per utilizzare <code class="docutils literal notranslate"><span class="pre">MockFunction</span></code>, si crea prima un oggetto <code class="docutils literal notranslate"><span class="pre">MockFunction</span></code> e si impostano le expectation sul suo metodo <code class="docutils literal notranslate"><span class="pre">Call</span></code>. Poi si passa il proxy ottenuto da <code class="docutils literal notranslate"><span class="pre">AsStdFunction()</span></code> al codice da testare. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">RunsCallbackWithBarArgument</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 1. Create a mock object.</span>
<span class="w">  </span><span class="n">MockFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mock_function</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 2. Set expectations on Call() method.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_function</span><span class="p">,</span><span class="w"> </span><span class="n">Call</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// 3. Exercise code that uses std::function.</span>
<span class="w">  </span><span class="n">Foo</span><span class="p">(</span><span class="n">mock_function</span><span class="p">.</span><span class="n">AsStdFunction</span><span class="p">());</span>
<span class="w">  </span><span class="c1">// Foo&#39;s signature can be either of:</span>
<span class="w">  </span><span class="c1">// void Foo(const std::function&lt;int(string)&gt;&amp; fun);</span>
<span class="w">  </span><span class="c1">// void Foo(std::function&lt;int(string)&gt; fun);</span>

<span class="w">  </span><span class="c1">// 4. All expectations will be verified when mock_function</span>
<span class="w">  </span><span class="c1">//     goes out of scope and is destroyed.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Da ricordare che gli oggetti funzione creati con <code class="docutils literal notranslate"><span class="pre">AsStdFunction()</span></code> vengono solo [forwarder]. Se se ne creano di più, condivideranno lo stesso insieme di expectation.</p>
<p>Sebbene <code class="docutils literal notranslate"><span class="pre">std::function</span></code> supporti un numero illimitato di argomenti, l’implementazione di <code class="docutils literal notranslate"><span class="pre">MockFunction</span></code> è limitata a dieci. Se mai si raggiungesse questo limite… beh, la richiamata ha problemi più grandi del poter essere mock. :-)</p>
</section>
</section>
</section>
<span id="document-docs/gmock_cheat_sheet"></span><section id="gmock-cheat-sheet">
<h2>Cheat Sheet di gMock<a class="headerlink" href="#gmock-cheat-sheet" title="Link to this heading">¶</a></h2>
<section id="defining-a-mock-class">
<h3>Definizione di una Classe Mock<a class="headerlink" href="#defining-a-mock-class" title="Link to this heading">¶</a></h3>
<section id="mocking-a-normal-class-mockclass">
<h4>Mock di una Classe Normale {#MockClass}<a class="headerlink" href="#mocking-a-normal-class-mockclass" title="Link to this heading">¶</a></h4>
<p>Dato</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Foo</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GetSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="nf">Describe</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="nf">Describe</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Process</span><span class="p">(</span><span class="n">Bar</span><span class="w"> </span><span class="n">elem</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>(notare che <code class="docutils literal notranslate"><span class="pre">~Foo()</span></code> <strong>deve</strong> essere virtual) possiamo definirne il mock come</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;gmock/gmock.h&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">GetSize</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Describe</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Describe</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Process</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Bar</span><span class="w"> </span><span class="n">elem</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Per creare un «nice» mock, che ignora tutte le chiamate [uninteresting], un mock «naggy», che emette warning su tutte le chiamate [uninteresting], o un mock «strict», che li tratta come fallimenti:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NiceMock</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">NaggyMock</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">StrictMock</span><span class="p">;</span>

<span class="n">NiceMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">nice_foo</span><span class="p">;</span><span class="w">      </span><span class="c1">// The type is a subclass of MockFoo.</span>
<span class="n">NaggyMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">naggy_foo</span><span class="p">;</span><span class="w">    </span><span class="c1">// The type is a subclass of MockFoo.</span>
<span class="n">StrictMock</span><span class="o">&lt;</span><span class="n">MockFoo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strict_foo</span><span class="p">;</span><span class="w">  </span><span class="c1">// The type is a subclass of MockFoo.</span>
</pre></div>
</div>
<p>{: .callout .note} <strong>Nota:</strong> Un oggetto mock è attualmente naggy per default. Potremmo renderlo nice per default in futuro.</p>
</section>
<section id="mocking-a-class-template-mocktemplate">
<h4>Mock di una Classe Template {#MockTemplate}<a class="headerlink" href="#mocking-a-class-template-mocktemplate" title="Link to this heading">¶</a></h4>
<p>Le classi templates si possono rendere mocked proprio come qualsiasi classe.</p>
<p>Per il mock di</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Elem</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StackInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">StackInterface</span><span class="p">();</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GetSize</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Push</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Elem</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>(notare che il mock di tutte le funzioni membro, compreso <code class="docutils literal notranslate"><span class="pre">~StackInterface()</span></code> <strong>devono</strong> essere virtual).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Elem</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MockStack</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">StackInterface</span><span class="o">&lt;</span><span class="n">Elem</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">GetSize</span><span class="p">,</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="k">override</span><span class="p">));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Push</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Elem</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="specifying-calling-conventions-for-mock-functions">
<h4>Specificare le Convenzioni di Chiamata per le Funzioni Mock<a class="headerlink" href="#specifying-calling-conventions-for-mock-functions" title="Link to this heading">¶</a></h4>
<p>Se la funzione mock non utilizza la convenzione di chiamata di default, la si può specificare aggiungendo <code class="docutils literal notranslate"><span class="pre">Calltype(convention)</span></code> al quarto parametro di <code class="docutils literal notranslate"><span class="pre">MOCK_METHOD</span></code>. Per esempio,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">Calltype</span><span class="p">(</span><span class="n">STDMETHODCALLTYPE</span><span class="p">)));</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">),</span>
<span class="w">              </span><span class="p">(</span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="n">Calltype</span><span class="p">(</span><span class="n">STDMETHODCALLTYPE</span><span class="p">)));</span>
</pre></div>
</div>
<p>dove <code class="docutils literal notranslate"><span class="pre">STDMETHODCALLTYPE</span></code> è definito da <code class="docutils literal notranslate"><span class="pre">&lt;objbase.h&gt;</span></code> su Windows.</p>
</section>
</section>
<section id="using-mocks-in-tests-usingmocks">
<h3>Uso dei Mock nei Test {#UsingMocks}<a class="headerlink" href="#using-mocks-in-tests-usingmocks" title="Link to this heading">¶</a></h3>
<p>Il flusso di lavoro tipico è:</p>
<ol class="arabic simple">
<li><p>Si importano i nomi gMock da utilizzare. Tutti i simboli gMock si trovano nel namespace <code class="docutils literal notranslate"><span class="pre">testing</span></code> a meno che non siano macro o diversamente indicati.</p></li>
<li><p>Si creano gli oggetti mock.</p></li>
<li><p>Facoltativamente, imposta le azioni di default degli oggetti mock.</p></li>
<li><p>Si settano le expectation sugli oggetti mock (Come verranno chiamati? Cosa faranno?).</p></li>
<li><p>Codice di esercizio che utilizza gli oggetti mock; se necessario, si controlla il risultato utilizzando le asserzioni di googletest.</p></li>
<li><p>Quando un oggetto mock viene distrutto, gMock verifica automaticamente che tutte le expectation su di esso siano state soddisfatte.</p></li>
</ol>
<p>Ecco un esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span><span class="w">                          </span><span class="c1">// #1</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">BarTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoesThis</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MockFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w">                                    </span><span class="c1">// #2</span>

<span class="w">  </span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">GetSize</span><span class="p">())</span><span class="w">                         </span><span class="c1">// #3</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillByDefault</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// ... other default actions ...</span>

<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Describe</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="w">                   </span><span class="c1">// #4</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="s">&quot;Category 5&quot;</span><span class="p">));</span>
<span class="w">  </span><span class="c1">// ... other expectations ...</span>

<span class="w">  </span><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">MyProductionFunction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;good&quot;</span><span class="p">);</span><span class="w">  </span><span class="c1">// #5</span>
<span class="p">}</span><span class="w">                                                 </span><span class="c1">// #6</span>
</pre></div>
</div>
</section>
<section id="setting-default-actions-oncall">
<h3>Impostazione delle Azioni di Default {#OnCall}<a class="headerlink" href="#setting-default-actions-oncall" title="Link to this heading">¶</a></h3>
<p>gMock ha un”<strong>azione di default nativa</strong> per qualsiasi funzione che restituisce <code class="docutils literal notranslate"><span class="pre">void</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, un valore numerico o un puntatore. In C++11, it additionally returns the default-constructed value, if one exists for the given type.</p>
<p>Per personalizzare l’azione di default per le funzioni con tipo restituito <code class="docutils literal notranslate"><span class="pre">T</span></code>, si usa <a class="reference internal" href="#reference/mocking.md#DefaultValue"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">DefaultValue&lt;T&gt;</span></code></span></a>. Per esempio:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Sets the default action for return type std::unique_ptr&lt;Buzz&gt; to</span>
<span class="w">  </span><span class="c1">// creating a new Buzz every time.</span>
<span class="w">  </span><span class="n">DefaultValue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;&gt;::</span><span class="n">SetFactory</span><span class="p">(</span>
<span class="w">      </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AccessLevel</span><span class="o">::</span><span class="n">kInternal</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>

<span class="w">  </span><span class="c1">// When this fires, the default action of MakeBuzz() will run, which</span>
<span class="w">  </span><span class="c1">// will return a new Buzz object.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_buzzer_</span><span class="p">,</span><span class="w"> </span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)).</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">buzz1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">buzz2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mock_buzzer_</span><span class="p">.</span><span class="n">MakeBuzz</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_NE</span><span class="p">(</span><span class="n">buzz1</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_NE</span><span class="p">(</span><span class="n">buzz2</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">  </span><span class="n">EXPECT_NE</span><span class="p">(</span><span class="n">buzz1</span><span class="p">,</span><span class="w"> </span><span class="n">buzz2</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Resets the default action for return type std::unique_ptr&lt;Buzz&gt;,</span>
<span class="w">  </span><span class="c1">// to avoid interfere with other tests.</span>
<span class="w">  </span><span class="n">DefaultValue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Buzz</span><span class="o">&gt;&gt;::</span><span class="n">Clear</span><span class="p">();</span>
</pre></div>
</div>
<p>Per personalizzare l’azione di default per un metodo particolare di uno specifico oggetto mock, si usa <a class="reference internal" href="#reference/mocking.md#ON_CALL"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code></span></a>. <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> ha una sintassi simile a <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>, ma viene utilizzato per impostare comportamenti di default quando non è necessario che venga chiamato il metodo mock. Vedere <span class="xref myst">Quando usare Expect</span> per una discussione più dettagliata.</p>
</section>
<section id="setting-expectations-expectcall">
<h3>Impostare le Expectation {#ExpectCall}<a class="headerlink" href="#setting-expectations-expectcall" title="Link to this heading">¶</a></h3>
<p>Vedere <a class="reference internal" href="#reference/mocking.md#EXPECT_CALL"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code></span></a> nella «Guida al Mocking».</p>
</section>
<section id="matchers-matcherlist">
<h3>I Matcher {#MatcherList}<a class="headerlink" href="#matchers-matcherlist" title="Link to this heading">¶</a></h3>
<p>Vedere i <a class="reference internal" href="#reference/matchers.md"><span class="xref myst">Riferimenti ai Matcher</span></a>.</p>
</section>
<section id="actions-actionlist">
<h3>Le Action {#ActionList}<a class="headerlink" href="#actions-actionlist" title="Link to this heading">¶</a></h3>
<p>Vedere i <a class="reference internal" href="#reference/actions.md"><span class="xref myst">Riferimenti alle Action</span></a>.</p>
</section>
<section id="cardinalities-cardinalitylist">
<h3>Cardinalità {#CardinalityList}<a class="headerlink" href="#cardinalities-cardinalitylist" title="Link to this heading">¶</a></h3>
<p>Vedere le <a class="reference internal" href="#reference/mocking.md#EXPECT_CALL.Times"><span class="xref myst">clausole <code class="docutils literal notranslate"><span class="pre">Times</span></code> </span></a> di <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> nella «Guida al Mocking».</p>
</section>
<section id="expectation-order">
<h3>Ordine delle Expectation<a class="headerlink" href="#expectation-order" title="Link to this heading">¶</a></h3>
<p>Per default, le expectation possono essere soddisfatte in <em>qualsiasi</em> ordine. Se alcune o tutte le expectation devono essere soddisfatte in un determinato ordine, si può utilizzare la <a class="reference internal" href="#reference/mocking.md#EXPECT_CALL.After"><span class="xref myst">clausola <code class="docutils literal notranslate"><span class="pre">After</span></code></span></a> o la <a class="reference internal" href="#reference/mocking.md#EXPECT_CALL.InSequence"><span class="xref myst">clausola <code class="docutils literal notranslate"><span class="pre">InSequence</span></code></span></a> di <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code>, oppure usare un <a class="reference internal" href="#reference/mocking.md#InSequence"><span class="xref myst">oggetto <code class="docutils literal notranslate"><span class="pre">InSequence</span></code></span></a>.</p>
</section>
<section id="verifying-and-resetting-a-mock">
<h3>Verificare e Resettare un Mock<a class="headerlink" href="#verifying-and-resetting-a-mock" title="Link to this heading">¶</a></h3>
<p>gMock verificherà le expectation su un oggetto mock quando viene distrutto, oppure lo si può fare prima:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Mock</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// Verifies and removes the expectations on mock_obj;</span>
<span class="c1">// returns true if and only if successful.</span>
<span class="n">Mock</span><span class="o">::</span><span class="n">VerifyAndClearExpectations</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_obj</span><span class="p">);</span>
<span class="p">...</span>
<span class="c1">// Verifies and removes the expectations on mock_obj;</span>
<span class="c1">// also removes the default actions set by ON_CALL();</span>
<span class="c1">// returns true if and only if successful.</span>
<span class="n">Mock</span><span class="o">::</span><span class="n">VerifyAndClear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_obj</span><span class="p">);</span>
</pre></div>
</div>
<p>Non stabilire nuove expectation dopo aver verificato e ripulito un mock dopo il suo utilizzo. L’impostazione delle expectation dopo il codice che esercita il mock ha un comportamento indefinito. Vedere <span class="xref myst">Uso dei Mock nei Test</span> per ulteriori informazioni.</p>
<p>Si può anche dire a gMock che un oggetto mock può essere perso [leaked] e non è necessario verificarlo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Mock</span><span class="o">::</span><span class="n">AllowLeak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mock_obj</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="mock-classes">
<h3>Classi Mock<a class="headerlink" href="#mock-classes" title="Link to this heading">¶</a></h3>
<p>gMock definisce un comodo template di classe mock</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MockFunction</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">An</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">Call</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">An</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Consultare questa <span class="xref myst">ricetta</span> per una sua applicazione.</p>
</section>
<section id="flags">
<h3>I Flag<a class="headerlink" href="#flags" title="Link to this heading">¶</a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-left"><p>Flag</p></th>
<th class="head text-left"><p>Descrizione</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">--gmock_catch_leaked_mocks=0</span></code></p></td>
<td class="text-left"><p>Non segnalare gli oggetti mock [leaked] come fallimenti.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">--gmock_verbose=LEVEL</span></code></p></td>
<td class="text-left"><p>Imposta il livello di verbosità di default (<code class="docutils literal notranslate"><span class="pre">info</span></code>, <code class="docutils literal notranslate"><span class="pre">warning</span></code>, o <code class="docutils literal notranslate"><span class="pre">error</span></code>) dei messaggi di Google Mock.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</div>
</section>
<section id="references">
<h1>Riferimenti<a class="headerlink" href="#references" title="Link to this heading">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-docs/faq"></span><section id="googletest-faq">
<h2>FAQ di GoogleTest<a class="headerlink" href="#googletest-faq" title="Link to this heading">¶</a></h2>
<section id="why-should-test-suite-names-and-test-names-not-contain-underscore">
<h3>Perché i nomi delle test suite e dei test non devono contenere un underscore?<a class="headerlink" href="#why-should-test-suite-names-and-test-names-not-contain-underscore" title="Link to this heading">¶</a></h3>
<p>{: .callout .note} Nota: GoogleTest si riserva l’underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) per parole chiave con scopi speciali, come <span class="xref myst">il prefisso <code class="docutils literal notranslate"><span class="pre">DISABLED_</span></code></span>, in aggiunta alla motivazione seguente.</p>
<p>Underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) è speciale, poiché il C++ riserva quanto segue per essere utilizzato dal compilatore e dalla libreria standard:</p>
<ol class="arabic simple">
<li><p>qualsiasi identificatore che inizia con un <code class="docutils literal notranslate"><span class="pre">_</span></code> seguito da una lettera maiuscola e</p></li>
<li><p>qualsiasi identificatore che contiene due underscore consecutivi (cioè <code class="docutils literal notranslate"><span class="pre">__</span></code>) <em>ovunque</em> nel suo nome.</p></li>
</ol>
<p>Al codice utente è <em>vietato</em> utilizzare tali identificatori.</p>
<p>Ora vediamo cosa significa per <code class="docutils literal notranslate"><span class="pre">TEST</span></code> e <code class="docutils literal notranslate"><span class="pre">TEST_F</span></code>.</p>
<p>Attualmente <code class="docutils literal notranslate"><span class="pre">TEST(TestSuiteName,</span> <span class="pre">TestName)</span></code> genera una classe denominata <code class="docutils literal notranslate"><span class="pre">TestSuiteName_TestName_Test</span></code>. Cosa succede se <code class="docutils literal notranslate"><span class="pre">TestSuiteName</span></code> o <code class="docutils literal notranslate"><span class="pre">TestName</span></code> contengono <code class="docutils literal notranslate"><span class="pre">_</span></code>?</p>
<ol class="arabic simple">
<li><p>Se <code class="docutils literal notranslate"><span class="pre">TestSuiteName</span></code> inizia con un <code class="docutils literal notranslate"><span class="pre">_</span></code> seguito da una lettera maiuscola (ad esempio <code class="docutils literal notranslate"><span class="pre">_Foo</span></code>), finiamo con <code class="docutils literal notranslate"><span class="pre">_Foo_TestName_Test</span></code>, che è riservato e quindi non valido.</p></li>
<li><p>Se <code class="docutils literal notranslate"><span class="pre">TestSuiteName</span></code> termina con un <code class="docutils literal notranslate"><span class="pre">_</span></code> (ad esempio <code class="docutils literal notranslate"><span class="pre">Foo_</span></code>), otteniamo <code class="docutils literal notranslate"><span class="pre">Foo__TestName_Test</span></code>, che non è valido.</p></li>
<li><p>Se <code class="docutils literal notranslate"><span class="pre">TestName</span></code> inizia con un <code class="docutils literal notranslate"><span class="pre">_</span></code> (ad esempio <code class="docutils literal notranslate"><span class="pre">_Bar</span></code>), otteniamo <code class="docutils literal notranslate"><span class="pre">TestSuiteName__Bar_Test</span></code>, che non è valido.</p></li>
<li><p>Se <code class="docutils literal notranslate"><span class="pre">TestName</span></code> termina con un <code class="docutils literal notranslate"><span class="pre">_</span></code> (ad esempio <code class="docutils literal notranslate"><span class="pre">Bar_</span></code>), otteniamo <code class="docutils literal notranslate"><span class="pre">TestSuiteName_Bar__Test</span></code>, che non è valido.</p></li>
</ol>
<p>Quindi chiaramente <code class="docutils literal notranslate"><span class="pre">TestSuiteName</span></code> e <code class="docutils literal notranslate"><span class="pre">TestName</span></code> non possono iniziare o finire con <code class="docutils literal notranslate"><span class="pre">_</span></code> (In realtà, <code class="docutils literal notranslate"><span class="pre">TestSuiteName</span></code> può iniziare con <code class="docutils literal notranslate"><span class="pre">_</span></code>—purché il <code class="docutils literal notranslate"><span class="pre">_</span></code> non sia seguito da una lettera maiuscola. Ma la cosa sta diventando complicata. Quindi per semplicità diciamo che non può iniziare con <code class="docutils literal notranslate"><span class="pre">_</span></code>).</p>
<p>Potrebbe sembrare corretto che <code class="docutils literal notranslate"><span class="pre">TestSuiteName</span></code> e <code class="docutils literal notranslate"><span class="pre">TestName</span></code> contengano <code class="docutils literal notranslate"><span class="pre">_</span></code> nel mezzo. Tuttavia, c’è questo da considerare:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span><span class="p">(</span><span class="n">Time</span><span class="p">,</span><span class="w"> </span><span class="n">Flies_Like_An_Arrow</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">Time_Flies</span><span class="p">,</span><span class="w"> </span><span class="n">Like_An_Arrow</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Ora, i due <code class="docutils literal notranslate"><span class="pre">TEST</span></code> genereranno entrambi la stessa classe (<code class="docutils literal notranslate"><span class="pre">Time_Flies_Like_An_Arrow_Test</span></code>). Questo non è buono.</p>
<p>Quindi, per semplicità, chiediamo agli utenti di evitare <code class="docutils literal notranslate"><span class="pre">_</span></code> in <code class="docutils literal notranslate"><span class="pre">TestSuiteName</span></code> e in <code class="docutils literal notranslate"><span class="pre">TestName</span></code>. La regola è più vincolante del necessario, ma è semplice e facile da ricordare. Offre inoltre a GoogleTest un po” di margine di manovra nel caso in cui la sua implementazione debba cambiare in futuro.</p>
<p>Violando la regola, potrebbero non esserci conseguenze immediate, ma il test potrebbe (solo potrebbe) «rompersi» con un nuovo compilatore (o una nuova versione del compilatore utilizzato) o con una nuova versione di GoogleTest. Quindi è meglio seguire la regola.</p>
</section>
<section id="why-does-googletest-support-expect-eq-null-ptr-and-assert-eq-null-ptr-but-not-expect-ne-null-ptr-and-assert-ne-null-ptr">
<h3>Perché GoogleTest supporta <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ(NULL,</span> <span class="pre">ptr)</span></code> e <code class="docutils literal notranslate"><span class="pre">ASSERT_EQ(NULL,</span> <span class="pre">ptr)</span></code> ma non <code class="docutils literal notranslate"><span class="pre">EXPECT_NE(NULL,</span> <span class="pre">ptr)</span></code> e <code class="docutils literal notranslate"><span class="pre">ASSERT_NE(NULL,</span> <span class="pre">ptr)</span></code>?<a class="headerlink" href="#why-does-googletest-support-expect-eq-null-ptr-and-assert-eq-null-ptr-but-not-expect-ne-null-ptr-and-assert-ne-null-ptr" title="Link to this heading">¶</a></h3>
<p>Prima di tutto, si può usare <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> con ciascuna di queste macro, ad es. <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ(ptr,</span> <span class="pre">nullptr)</span></code>, <code class="docutils literal notranslate"><span class="pre">EXPECT_NE(ptr,</span> <span class="pre">nullptr)</span></code>, <code class="docutils literal notranslate"><span class="pre">ASSERT_EQ(ptr,</span> <span class="pre">nullptr)</span></code>, <code class="docutils literal notranslate"><span class="pre">ASSERT_NE(ptr,</span> <span class="pre">nullptr)</span></code>. Questa è la sintassi preferita nella guida stilistica perché <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> non presenta i problemi sul tipo che presenta <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p>A causa di alcune peculiarità del C++, sono necessari alcuni trucchi di metaprogrammazione non banali per supportare l’uso di <code class="docutils literal notranslate"><span class="pre">NULL</span></code> come argomento delle macro <code class="docutils literal notranslate"><span class="pre">EXPECT_XX()</span></code> e <code class="docutils literal notranslate"><span class="pre">ASSERT_XX()</span></code>. Pertanto lo facciamo solo dove è più necessario (altrimenti rendiamo l’implementazione di GoogleTest più difficile da mantenere e più soggetta a errori del necessario).</p>
<p>Storicamente, la macro <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ()</span></code> prendeva il valore <em>expected</em> come primo argomento e il valore <em>actual</em> come secondo, sebbene l’ordine degli argomenti ora sia scoraggiato. Era ragionevole che qualcuno volesse scrivere <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ(NULL,</span> <span class="pre">some_expression)</span></code>, e in effetti questo è stato richiesto più volte. Pertanto lo abbiamo implementato.</p>
<p>La necessità di <code class="docutils literal notranslate"><span class="pre">EXPECT_NE(NULL,</span> <span class="pre">ptr)</span></code> non era così pressante. Quando l’asserzione fallisce, si sa già che <code class="docutils literal notranslate"><span class="pre">ptr</span></code> deve essere <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, quindi non aggiunge alcuna informazione per stampare <code class="docutils literal notranslate"><span class="pre">ptr</span></code> in questo caso. Ciò significa che <code class="docutils literal notranslate"><span class="pre">EXPECT_TRUE(ptr</span> <span class="pre">!=</span> <span class="pre">NULL)</span></code> funziona altrettanto bene.</p>
<p>Se dovessimo supportare <code class="docutils literal notranslate"><span class="pre">EXPECT_NE(NULL,</span> <span class="pre">ptr)</span></code>, per coerenza dovremmo supportare anche <code class="docutils literal notranslate"><span class="pre">EXPECT_NE(ptr,</span> <span class="pre">NULL)</span></code>. Ciò significa utilizzare i trucchi della metaprogrammazione del template due volte nell’implementazione, rendendolo ancora più difficile da comprendere e mantenere. Riteniamo che il vantaggio non giustifichi il costo.</p>
<p>Infine, con la crescita della libreria di matcher gMock, stiamo incoraggiando le persone a utilizzare la sintassi unificata <code class="docutils literal notranslate"><span class="pre">EXPECT_THAT(value,</span> <span class="pre">matcher)</span></code> più spesso nei test. Un vantaggio significativo dell’approccio con i matcher è che questi possono essere facilmente combinati per formare nuovi matcher, mentre le macro <code class="docutils literal notranslate"><span class="pre">EXPECT_NE</span></code>, ecc, non possono essere facilmente combinate. Pertanto vogliamo investire di più nei matcher che nelle macro <code class="docutils literal notranslate"><span class="pre">EXPECT_XX()</span></code>.</p>
</section>
<section id="i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests">
<h3>Devo verificare che diverse implementazioni di un’interfaccia soddisfino alcuni requisiti comuni. Dovrei utilizzare test tipizzati o test con valori parametrizzati?<a class="headerlink" href="#i-need-to-test-that-different-implementations-of-an-interface-satisfy-some-common-requirements-should-i-use-typed-tests-or-value-parameterized-tests" title="Link to this heading">¶</a></h3>
<p>Per testare varie implementazioni della stessa interfaccia, è possibile eseguire test tipizzati o test con valori parametrizzati. È davvero personale decidere quale sia più conveniente, a seconda del caso particolare. Alcune linee guida approssimative:</p>
<ul class="simple">
<li><p>I test tipizzati possono essere più facili da scrivere se le istanze delle diverse implementazioni possono essere create allo stesso modo, modulo il tipo. Ad esempio, se tutte queste implementazioni hanno un costruttore pubblico di default (in modo che sia possibile scrivere <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">TypeParam</span></code>), o se le loro funzioni factory hanno la stessa forma (ad esempio <code class="docutils literal notranslate"><span class="pre">CreateInstance&lt;TypeParam&gt;()</span></code>).</p></li>
<li><p>I test con valori parametrizzati possono essere più facili da scrivere se sono necessari pattern di codice diversi per creare istanze di implementazioni diverse, ad es. <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Foo</span></code> contro <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Bar(5)</span></code>. Per compensare le differenze, è possibile scrivere wrapper di funzioni factory e passare questi puntatori a funzione ai test come parametri.</p></li>
<li><p>Quando un test tipizzato fallisce, l’output di default include il nome del tipo, che può aiutare a identificare rapidamente quale implementazione sia sbagliata. Per default, i test con valori parametrizzati mostrano solo il numero dell’iterazione non riuscita. Sarà necessario definire una funzione che restituisca il nome dell’iterazione e passarla come terzo parametro a INSTANTIATE_TEST_SUITE_P per avere un output più utile.</p></li>
<li><p>Quando si usano test tipizzati, si deve eseguire il test rispetto al tipo di interfaccia, non ai tipi concreti (in altre parole, <code class="docutils literal notranslate"><span class="pre">implicit_cast&lt;MyInterface*&gt;(my_concrete_impl)</span></code> deve funzionare, non basta che funzioni <code class="docutils literal notranslate"><span class="pre">my_concrete_impl</span></code>). È meno probabile che si commettano errori in quest’area quando si utilizzano test con valori parametrizzati.</p></li>
</ul>
<p>Speriamo di non aver aumentato la confusione. :-) Se possibile, suggeriamo di provare entrambi gli approcci. La pratica è un modo molto migliore per cogliere le sottili differenze tra i due strumenti. Una volta acquisita un’esperienza concreta, si potrà decidere molto più facilmente quale utilizzare.</p>
</section>
<section id="my-death-test-modifies-some-state-but-the-change-seems-lost-after-the-death-test-finishes-why">
<h3>Il mio «death test» modifica alcuni stati, ma il cambiamento sembra perso al termine del test. Perché?<a class="headerlink" href="#my-death-test-modifies-some-state-but-the-change-seems-lost-after-the-death-test-finishes-why" title="Link to this heading">¶</a></h3>
<p>I death test (<code class="docutils literal notranslate"><span class="pre">EXPECT_DEATH</span></code>, ecc.) vengono eseguiti in un sottoprocesso s.t. il crash previsto non kill-erà il programma di test (ovvero il processo genitore). Di conseguenza, eventuali effetti collaterali in memoria che avvengono sono osservabili nei rispettivi sottoprocessi, ma non nel processo genitore. Si possono pensare come se venissero eseguiti in un universo parallelo, più o meno.</p>
<p>In particolare, se si utilizza il mocking e l’enunciato del death test invoca alcuni metodi mock, il processo genitore penserà che le chiamate non siano mai avvenute. Pertanto, si potrebbero spostare le istruzioni <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> nella macro <code class="docutils literal notranslate"><span class="pre">EXPECT_DEATH</span></code>.</p>
</section>
<section id="expect-eq-htonl-blah-blah-blah-generates-weird-compiler-errors-in-opt-mode-is-this-a-googletest-bug">
<h3>EXPECT_EQ(htonl(blah), blah_blah) genera strani errori del compilatore in modalità opt. È un bug di GoogleTest?<a class="headerlink" href="#expect-eq-htonl-blah-blah-blah-generates-weird-compiler-errors-in-opt-mode-is-this-a-googletest-bug" title="Link to this heading">¶</a></h3>
<p>In realtà il bug è in <code class="docutils literal notranslate"><span class="pre">htonl()</span></code>.</p>
<p>Secondo <code class="docutils literal notranslate"><span class="pre">'man</span> <span class="pre">htonl'</span></code>, <code class="docutils literal notranslate"><span class="pre">htonl()</span></code> è una <em>funzione</em>, il che significa che è corretto utilizzare <code class="docutils literal notranslate"><span class="pre">htonl</span></code> come puntatore a funzione. Tuttavia, in modalità opt <code class="docutils literal notranslate"><span class="pre">htonl()</span></code> è definito come una <em>macro</em>, il che interrompe questo utilizzo.</p>
<p>Peggio ancora, la definizione della macro di <code class="docutils literal notranslate"><span class="pre">htonl()</span></code> utilizza un’estensione di <code class="docutils literal notranslate"><span class="pre">gcc</span></code> che <em>non</em> è C++ standard. Questa implementazione complicata presenta alcune limitazioni ad hoc. In particolare, impedisce di scrivere <code class="docutils literal notranslate"><span class="pre">Foo&lt;sizeof(htonl(x))&gt;()</span></code>, dove <code class="docutils literal notranslate"><span class="pre">Foo</span></code> è un template che ha un argomento intero.</p>
<p>L’implementazione di <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ(a,</span> <span class="pre">b)</span></code> usa <code class="docutils literal notranslate"><span class="pre">sizeof(...</span> <span class="pre">a</span> <span class="pre">...)</span></code> all’interno di un argomento template e quindi non viene compilato in modalità opt quando <code class="docutils literal notranslate"><span class="pre">a</span></code> contiene una chiamata a <code class="docutils literal notranslate"><span class="pre">htonl()</span></code>. È difficile fare in modo che <code class="docutils literal notranslate"><span class="pre">EXPECT_EQ</span></code> bypassi il bug <code class="docutils literal notranslate"><span class="pre">htonl()</span></code>, poiché la soluzione deve funzionare con diversi compilatori su varie piattaforme.</p>
</section>
<section id="the-compiler-complains-about-undefined-references-to-some-static-const-member-variables-but-i-did-define-them-in-the-class-body-what-s-wrong">
<h3>Il compilatore si lamenta di «riferimenti non definiti» ad alcune variabili membro const statiche, ma sono state definite nel corpo della classe. Cosa c’è che non va?<a class="headerlink" href="#the-compiler-complains-about-undefined-references-to-some-static-const-member-variables-but-i-did-define-them-in-the-class-body-what-s-wrong" title="Link to this heading">¶</a></h3>
<p>Se la classe ha un membro dati static:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kBar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>lo si deve definire anche <em>al di fuori</em> del corpo della classe in <code class="docutils literal notranslate"><span class="pre">foo.cc</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Foo</span><span class="o">::</span><span class="n">kBar</span><span class="p">;</span><span class="w">  </span><span class="c1">// No initializer here.</span>
</pre></div>
</div>
<p>Altrimenti il codice sarà <strong>C++ invalido</strong>, e potrebbe “rompersi” in modi imprevisti. In particolare, utilizzarlo nelle asserzioni di confronto di GoogleTest (<code class="docutils literal notranslate"><span class="pre">EXPECT_EQ</span></code>, ecc.) genererà un errore del linker «undefined reference». Il fatto che «funzionava» non significa che sia valido. Significa solo che si è stati fortunati. :-)</p>
<p>Se la dichiarazione del membro dati statico è <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> allora è implicitamente una definizione <code class="docutils literal notranslate"><span class="pre">inline</span></code> e non è necessaria una definizione separata in <code class="docutils literal notranslate"><span class="pre">foo.cc</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// foo.h</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kBar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">  </span><span class="c1">// Defines kBar, no need to do it in foo.cc.</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="can-i-derive-a-test-fixture-from-another">
<h3>Posso derivare una fixture da un’altra?<a class="headerlink" href="#can-i-derive-a-test-fixture-from-another" title="Link to this heading">¶</a></h3>
<p>Sì.</p>
<p>Ogni fixture ha una test suite corrispondente e con lo stesso nome. Ciò significa che solo una test suite può utilizzare una particolare fixture. A volte, tuttavia, più casi di test potrebbero voler utilizzare le stesse fixture o leggermente diverse. Ad esempio, si potrebbe vole essere sicuri che tutte le test suite di una libreria GUI non abbiano importanti «leak» di risorse di sistema come font e brush.</p>
<p>In GoogleTest, si condivide una fixture tra le test suite inserendo la logica condivisa in una fixture di base, poi derivando da quella base una fixture separata per ciascuna test suite che voglia utilizzare questa logica comune. Poi si usa <code class="docutils literal notranslate"><span class="pre">TEST_F()</span></code> per scrivere i test utilizzando ciascuna fixture derivata.</p>
<p>In genere, il codice è simile al seguente:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Defines a base test fixture.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// Derives a fixture FooTest from BaseTest.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">BaseTest</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">protected</span><span class="o">:</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">SetUp</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BaseTest</span><span class="o">::</span><span class="n">SetUp</span><span class="p">();</span><span class="w">  </span><span class="c1">// Sets up the base fixture first.</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="n">additional</span><span class="w"> </span><span class="n">set</span><span class="o">-</span><span class="n">up</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">TearDown</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="n">clean</span><span class="o">-</span><span class="n">up</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">FooTest</span><span class="w"> </span><span class="p">...</span>
<span class="w">    </span><span class="n">BaseTest</span><span class="o">::</span><span class="n">TearDown</span><span class="p">();</span><span class="w">  </span><span class="c1">// Remember to tear down the base fixture</span>
<span class="w">                           </span><span class="c1">// after cleaning up FooTest!</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="n">functions</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">variables</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">FooTest</span><span class="w"> </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// Tests that use the fixture FooTest.</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Baz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="p">...</span><span class="w"> </span><span class="n">additional</span><span class="w"> </span><span class="n">fixtures</span><span class="w"> </span><span class="n">derived</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">BaseTest</span><span class="w"> </span><span class="p">...</span>
</pre></div>
</div>
<p>Se necessario, è possibile continuare a derivare fixture da una fixture derivata. GoogleTest non ha limiti sulla profondità della gerarchia.</p>
<p>Per un esempio completo sull’uso delle test fixture derivate, vedere <a class="reference external" href="https://github.com/google/googletest/blob/main/googletest/samples/sample5_unittest.cc">sample5_unittest.cc</a>.</p>
</section>
<section id="my-compiler-complains-void-value-not-ignored-as-it-ought-to-be-what-does-this-mean">
<h3>Il mio compilatore dice «void value not ignored as it ought to be». Cosa significa?<a class="headerlink" href="#my-compiler-complains-void-value-not-ignored-as-it-ought-to-be-what-does-this-mean" title="Link to this heading">¶</a></h3>
<p>Probabilmente si sta utilizzando un <code class="docutils literal notranslate"><span class="pre">ASSERT_*()</span></code> in una funzione che non restituisce <code class="docutils literal notranslate"><span class="pre">void</span></code>. <code class="docutils literal notranslate"><span class="pre">ASSERT_*()</span></code> può essere utilizzato solo nelle funzioni <code class="docutils literal notranslate"><span class="pre">void</span></code>, poiché le eccezioni sono disabilitate dal nostro sistema di build. Consultare ulteriori dettagli <span class="xref myst">qui</span>.</p>
</section>
<section id="my-death-test-hangs-or-seg-faults-how-do-i-fix-it">
<h3>Il mio death test si blocca (o ci sono errori seg-fault). Come lo si ripara?<a class="headerlink" href="#my-death-test-hangs-or-seg-faults-how-do-i-fix-it" title="Link to this heading">¶</a></h3>
<p>In GoogleTest, i death test vengono eseguiti in un processo figlio e il modo in cui funzionano è delicato. Per scrivere dei death test si devono veramente capire come funzionano: vederei i dettagli nelle <a class="reference internal" href="#reference/assertions.md#death"><span class="xref myst">Asserzioni Death</span></a> nei Riferimenti sulle Asserzioni.</p>
<p>In particolare, ai death test non piace avere più thread nel processo genitore. Quindi la prima cosa che si può provare è eliminare la creazione di thread al di fuori di <code class="docutils literal notranslate"><span class="pre">EXPECT_DEATH()</span></code>. Ad esempio, si potrebbero utilizzare oggetti mock o fake invece di quelli reali nei test.</p>
<p>A volte questo è impossibile poiché alcune librerie da utilizzare potrebbero creare thread prima ancora che venga raggiunto il <code class="docutils literal notranslate"><span class="pre">main()</span></code>. In questo caso, si può provare a ridurre al minimo la possibilità di conflitti spostando quante più attività possibili all’interno di <code class="docutils literal notranslate"><span class="pre">EXPECT_DEATH()</span></code> (nel caso estremo, si può spostare tutto all’interno), o lasciandone poche cose. Inoltre, si può provare a impostare lo stile del death test su <code class="docutils literal notranslate"><span class="pre">&quot;threadsafe&quot;</span></code>, che è più sicuro ma più lento, e vedere se aiuta.</p>
<p>Se si usano i death test thread-safe, ricordarsi che eseguono nuovamente il programma di test dall’inizio nel processo figlio. Il programma deve poter funzionare fianco a fianco con se stesso e che sia deterministico.</p>
<p>Alla fine, questo si riduce a una buona programmazione concorrente. Non ci devono essere condizioni di race o deadlock nel programma. Spiacenti: nessuna soluzione miracolosa!</p>
</section>
<section id="should-i-use-the-constructor-destructor-of-the-test-fixture-or-setup-teardown-ctorvssetup">
<h3>Si usa il costruttore/distruttore della fixture o SetUp()/TearDown()? {#CtorVsSetUp}<a class="headerlink" href="#should-i-use-the-constructor-destructor-of-the-test-fixture-or-setup-teardown-ctorvssetup" title="Link to this heading">¶</a></h3>
<p>La prima cosa da ricordare è che that GoogleTest <strong>non</strong> riutilizza lo stesso oggetto test fixture in più test. Per ciascun <code class="docutils literal notranslate"><span class="pre">TEST_F</span></code>, GoogleTest creerà un <strong>nuovo</strong> oggetto fixture, chiamerà immediatamente <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code>, eseguirà il corpo del test, chiamerà <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> per poi eseguire il delete dell’oggetto fixture test.</p>
<p>Quando è necessario scrivere la logica di configurazione e ripulitura per ciascun test, è possibile scegliere tra utilizzare il costruttore/distruttore della fixture o <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code>/<code class="docutils literal notranslate"><span class="pre">TearDown()</span></code>. Il primo è solitamente preferito perché presenta i seguenti vantaggi:</p>
<ul class="simple">
<li><p>Inizializzando una variabile membro nel costruttore, abbiamo la possibilità di renderla <code class="docutils literal notranslate"><span class="pre">const</span></code>, il che aiuta a prevenire modifiche accidentali al suo valore e rende i test ovviamente più corretti.</p></li>
<li><p>Nel caso in cui abbiamo bisogno di sottoclassi della classe fixture, è garantito che il costruttore della sottoclasse chiamerà <em>prima</em> quello della classe base e il distruttore della sottoclasse è garantito che chiamerà il distruttore della classe base <em>dopo</em>. Con <code class="docutils literal notranslate"><span class="pre">SetUp()/TearDown()</span></code>, una sottoclasse potrebbe commettere l’errore di dimenticare di chiamare la classe base di <code class="docutils literal notranslate"><span class="pre">SetUp()/TearDown()</span></code> o di chiamarla nel momento sbagliato.</p></li>
</ul>
<p>Si potrebbe comunque usare <code class="docutils literal notranslate"><span class="pre">SetUp()/TearDown()</span></code> nei seguenti casi:</p>
<ul class="simple">
<li><p>Il C++ non consente chiamate di funzioni virtuali nei costruttori e nei distruttori. Si può chiamare un metodo dichiarato come virtuale, ma non utilizzerà il dispatch dinamico. Utilizzerà la definizione della classe il cui costruttore è attualmente in esecuzione. Questo perché chiamare un metodo virtuale prima che il costruttore della classe derivata abbia la possibilità di essere eseguito è molto pericoloso: il metodo virtuale potrebbe operare su dati non inizializzati. Pertanto, dovendo chiamare un metodo che verrà sovrascritto in una classe derivata, si deve usare <code class="docutils literal notranslate"><span class="pre">SetUp()/TearDown()</span></code>.</p></li>
<li><p>Nel corpo di un costruttore (o di un distruttore), non è possibile utilizzare le macro <code class="docutils literal notranslate"><span class="pre">ASSERT_xx</span></code>. Pertanto, se l’operazione di configurazione potrebbe causare un fallimento fatale del test che dovrebbe impedire l’esecuzione del test, è necessario utilizzare <code class="docutils literal notranslate"><span class="pre">abort</span></code> e abortire l’intero eseguibile del test, oppure utilizzare <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code> invece di un costruttore.</p></li>
<li><p>Se l’operazione di ripulitura (tear-down) può generare un’eccezione, si deve usare <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> invece del distruttore, poiché l’inserimento di un distruttore porta a un comportamento indefinito e solitamente «killerà» immediatamente il programma. Notare che molte librerie standard (come STL) potrebbero generare un’eccezione quando queste sono abilitate nel compilatore. Pertanto è preferibile <code class="docutils literal notranslate"><span class="pre">TearDown()</span></code> se si vogliono scrivere test portabili che funzionino con o senza eccezioni.</p></li>
<li><p>Il team di GoogleTest sta valutando la possibilità di lanciare eccezioni [throw] nelle macro di asserzione su piattaforme in cui sono abilitate le eccezioni (ad esempio Windows, Mac OS e Linux lato client), il che eliminerà la necessità per l’utente di propagare gli errori da una subroutine al suo chiamante. Pertanto, non si dovrebbero usare le asserzioni GoogleTest in un distruttore se il codice può essere eseguito su tali piattaforme.</p></li>
</ul>
</section>
<section id="the-compiler-complains-no-matching-function-to-call-when-i-use-assert-pred-how-do-i-fix-it">
<h3>Il compilatore dice «no matching function to call» quando si usa <code class="docutils literal notranslate"><span class="pre">ASSERT_PRED*</span></code>. Come lo si ripara?<a class="headerlink" href="#the-compiler-complains-no-matching-function-to-call-when-i-use-assert-pred-how-do-i-fix-it" title="Link to this heading">¶</a></h3>
<p>Vedere i dettagli per <a class="reference internal" href="#reference/assertions.md#EXPECT_PRED"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">EXPECT_PRED*</span></code></span></a> nei «Riferimenti sulle Asserzioni».</p>
</section>
<section id="my-compiler-complains-about-ignoring-return-value-when-i-call-run-all-tests-why">
<h3>Il compilatore dice «ignoring return value» quando si chiama RUN_ALL_TESTS(). Perché?<a class="headerlink" href="#my-compiler-complains-about-ignoring-return-value-when-i-call-run-all-tests-why" title="Link to this heading">¶</a></h3>
<p>Qualcuno ha ignorato il valore restituito da <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>. Cioè, invece di</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
</pre></div>
</div>
<p>scrivono</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
</pre></div>
</div>
<p>Questo è <strong>sbagliato e pericoloso</strong>. I servizi di test devono vedere il valore restituito di <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code> per determinare se un test è stato superato. Se la funzione <code class="docutils literal notranslate"><span class="pre">main()</span></code> lo ignora, il test verrà considerato riuscito anche se presenta un errore nell’asserzione di GoogleTest. Molto brutto.</p>
<p>Abbiamo deciso di risolvere questo problema (grazie a Michael Chastain per l’idea). Ora il codice non sarà più in grado di ignorare <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code> quando verrà compilato con <code class="docutils literal notranslate"><span class="pre">gcc</span></code>. Facendolo, si riceverà un errore del compilatore.</p>
<p>Se il compilatore si lamenta del fatto che viene ignorato il valore restituito di <code class="docutils literal notranslate"><span class="pre">RUN_ALL_TESTS()</span></code>, la soluzione è semplice: si deve utilizzare il valore come valore restituito da <code class="docutils literal notranslate"><span class="pre">main()</span></code>.</p>
<p>Ma come potremmo introdurre un cambiamento che renda non funzionanti i test esistenti? Bene, in questo caso il codice era già bacato, quindi non è stato guastato adesso. :-)</p>
</section>
<section id="my-compiler-complains-that-a-constructor-or-destructor-cannot-return-a-value-what-s-going-on">
<h3>Il compilatore dice che un costruttore (o un distruttore) non può restituire un valore. Cosa sta succedendo?<a class="headerlink" href="#my-compiler-complains-that-a-constructor-or-destructor-cannot-return-a-value-what-s-going-on" title="Link to this heading">¶</a></h3>
<p>A causa di una peculiarità del C++, per supportare la sintassi per lo streaming dei messaggi su un <code class="docutils literal notranslate"><span class="pre">ASSERT_*</span></code>, ad es.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Foo</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;blah blah&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>abbiamo dovuto rinunciare a utilizzare <code class="docutils literal notranslate"><span class="pre">ASSERT*</span></code> e <code class="docutils literal notranslate"><span class="pre">FAIL*</span></code> (ma non <code class="docutils literal notranslate"><span class="pre">EXPECT*</span></code> e <code class="docutils literal notranslate"><span class="pre">ADD_FAILURE*</span></code>) nei costruttori e nei distruttori. La soluzione alternativa è quella di spostare il contenuto del costruttore/distruttore in una funzione membro void privata o passare a <code class="docutils literal notranslate"><span class="pre">EXPECT_*()</span></code> se funziona. Questa <span class="xref myst">sezione</span> nella guida utente lo spiega.</p>
</section>
<section id="my-setup-function-is-not-called-why">
<h3>La funzione SetUp() non viene chiamata. Perché?<a class="headerlink" href="#my-setup-function-is-not-called-why" title="Link to this heading">¶</a></h3>
<p>Il C++ fa distinzione tra maiuscole e minuscole. È stato scritto <code class="docutils literal notranslate"><span class="pre">Setup()</span></code>?</p>
<p>Allo stesso modo, a volte le persone scrivono <code class="docutils literal notranslate"><span class="pre">SetUpTestSuite()</span></code> come <code class="docutils literal notranslate"><span class="pre">SetupTestSuite()</span></code> e si chiedono perché non venga mai chiamato.</p>
</section>
<section id="i-have-several-test-suites-which-share-the-same-test-fixture-logic-do-i-have-to-define-a-new-test-fixture-class-for-each-of-them-this-seems-pretty-tedious">
<h3>Abbiamo diverse test suite che condividono la stessa logica della fixture; si deve definire una nuova classe fixture per ognuna di esse? Sembra piuttosto noioso.<a class="headerlink" href="#i-have-several-test-suites-which-share-the-same-test-fixture-logic-do-i-have-to-define-a-new-test-fixture-class-for-each-of-them-this-seems-pretty-tedious" title="Link to this heading">¶</a></h3>
<p>Non è necessario. Invece di</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">BaseTest</span><span class="w"> </span><span class="p">{};</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Def</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BarTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">BaseTest</span><span class="w"> </span><span class="p">{};</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">BarTest</span><span class="p">,</span><span class="w"> </span><span class="n">Abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">BarTest</span><span class="p">,</span><span class="w"> </span><span class="n">Def</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>si può semplicemente avere un <code class="docutils literal notranslate"><span class="pre">typedef</span></code> delle fixture:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">BaseTest</span><span class="w"> </span><span class="n">FooTest</span><span class="p">;</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Def</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="k">typedef</span><span class="w"> </span><span class="n">BaseTest</span><span class="w"> </span><span class="n">BarTest</span><span class="p">;</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">BarTest</span><span class="p">,</span><span class="w"> </span><span class="n">Abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">BarTest</span><span class="p">,</span><span class="w"> </span><span class="n">Def</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="googletest-output-is-buried-in-a-whole-bunch-of-log-messages-what-do-i-do">
<h3>L’output di GoogleTest è sepolto in un sacco di messaggi di LOG. Cosa si deve fare?<a class="headerlink" href="#googletest-output-is-buried-in-a-whole-bunch-of-log-messages-what-do-i-do" title="Link to this heading">¶</a></h3>
<p>L’output di GoogleTest vuole essere un rapporto conciso e di facile comprensione. Se il test genera esso stesso un output testuale, si mescolerà con l’output di GoogleTest, rendendolo difficile da leggere. Tuttavia, esiste una soluzione semplice a questo problema.</p>
<p>Poiché i messaggi di <code class="docutils literal notranslate"><span class="pre">LOG</span></code> vanno a stderr, abbiamo deciso di lasciare che l’output di GoogleTest vada a stdout. In questo modo, si possono facilmente separare i due utilizzando il reindirizzamento. Per esempio:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>./my_test<span class="w"> </span>&gt;<span class="w"> </span>gtest_output.txt
</pre></div>
</div>
</section>
<section id="why-should-i-prefer-test-fixtures-over-global-variables">
<h3>Perché dovrei preferire le fixture alle variabili globali?<a class="headerlink" href="#why-should-i-prefer-test-fixtures-over-global-variables" title="Link to this heading">¶</a></h3>
<p>Ci sono diversi buoni motivi:</p>
<ol class="arabic simple">
<li><p>È probabile che il test debba modificare gli stati delle sue variabili globali. Ciò rende difficile evitare che gli effetti collaterali sfuggano a un test e contaminino gli altri, rendendo difficile il debug. Utilizzando le fixture, ogni test ha un nuovo set di variabili diverse (ma con gli stessi nomi). Pertanto, i test vengono mantenuti indipendenti l’uno dall’altro.</p></li>
<li><p>Le variabili globali inquinano il namespace globale.</p></li>
<li><p>Le fixture possono essere riutilizzate tramite sottoclassi, cosa che non può essere eseguita facilmente con le variabili globali. Ciò è utile se molte test suite hanno qualcosa in comune.</p></li>
</ol>
</section>
<section id="what-can-the-statement-argument-in-assert-death-be">
<h3>Quale può essere l’argomento dell’istruzione in ASSERT_DEATH()?<a class="headerlink" href="#what-can-the-statement-argument-in-assert-death-be" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ASSERT_DEATH(statement,</span> <span class="pre">matcher)</span></code> (o qualsiasi macro di asserzione death) può essere utilizzato ovunque sia valido <em><code class="docutils literal notranslate"><span class="pre">statement</span></code></em>. Quindi, in pratica <em><code class="docutils literal notranslate"><span class="pre">statement</span></code></em> può essere qualsiasi istruzione C++ che abbia senso nel contesto corrente. In particolare può fare riferimento a variabili globali e/o locali e può essere:</p>
<ul class="simple">
<li><p>una semplice chiamata di funzione (spesso accade),</p></li>
<li><p>un’espressione complessa, o</p></li>
<li><p>un’istruzione composta.</p></li>
</ul>
<p>Alcuni esempi sono mostrati qui:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// A death test can be a simple function call.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">FunctionCall</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ASSERT_DEATH</span><span class="p">(</span><span class="n">Xyz</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Xyz failed&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Or a complex expression that references variables and functions.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">ComplexExpression</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Condition</span><span class="p">();</span>
<span class="w">  </span><span class="n">ASSERT_DEATH</span><span class="p">((</span><span class="n">c</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">Func1</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">object2</span><span class="p">.</span><span class="n">Method</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">)),</span>
<span class="w">               </span><span class="s">&quot;(Func1|Method) failed&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Death assertions can be used anywhere in a function.  In</span>
<span class="c1">// particular, they can be inside a loop.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">InsideLoop</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Verifies that Foo(0), Foo(1), ..., and Foo(4) all die.</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">EXPECT_DEATH_M</span><span class="p">(</span><span class="n">Foo</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Foo has </span><span class="se">\\</span><span class="s">d+ errors&quot;</span><span class="p">,</span>
<span class="w">                   </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Message</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;where i is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A death assertion can contain a compound statement.</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">MyDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">CompoundStatement</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Verifies that at lease one of Bar(0), Bar(1), ..., and</span>
<span class="w">  </span><span class="c1">// Bar(4) dies.</span>
<span class="w">  </span><span class="n">ASSERT_DEATH</span><span class="p">({</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">Bar</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="s">&quot;Bar has </span><span class="se">\\</span><span class="s">d+ errors&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="i-have-a-fixture-class-footest-but-test-f-footest-bar-gives-me-error-no-matching-function-for-call-to-footest-footest-why">
<h3>Ho una classe fixture <code class="docutils literal notranslate"><span class="pre">FooTest</span></code>, ma <code class="docutils literal notranslate"><span class="pre">TEST_F(FooTest,</span> <span class="pre">Bar)</span></code> mi dà l’errore <code class="docutils literal notranslate"><span class="pre">&quot;no</span> <span class="pre">matching</span> <span class="pre">function</span> <span class="pre">for</span> <span class="pre">call</span> <span class="pre">to</span> <span class="pre">`FooTest::FooTest()'&quot;</span></code>. Perché?<a class="headerlink" href="#i-have-a-fixture-class-footest-but-test-f-footest-bar-gives-me-error-no-matching-function-for-call-to-footest-footest-why" title="Link to this heading">¶</a></h3>
<p>GoogleTest deve essere in grado di creare oggetti della classe fixture, quindi deve avere un costruttore di default. Normalmente il compilatore ne definisce uno. Tuttavia, ci sono casi in cui è necessario definirne uno manualmente:</p>
<ul class="simple">
<li><p>Se si dichiara esplicitamente un costruttore non di default per la classe <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> (<code class="docutils literal notranslate"><span class="pre">DISALLOW_EVIL_CONSTRUCTORS()</span></code> fa questo), allora si deve definire un costruttore di default, anche se vuoto.</p></li>
<li><p>Se <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> ha un membro dati const non statico, allora si deve definire il costruttore di default <em>e</em> inizializzare il membro const nell’elenco degli inizializzatori del costruttore. (Le prime versioni di <code class="docutils literal notranslate"><span class="pre">gcc</span></code> non obbligano a inizializzare il membro const. È un bug corretto in <code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">4</span></code>.)</p></li>
</ul>
</section>
<section id="why-does-googletest-require-the-entire-test-suite-instead-of-individual-tests-to-be-named-deathtest-when-it-uses-assert-death">
<h3>Perché GoogleTest richiede che l’intera test suite, anziché i singoli test, venga denominata <code class="docutils literal notranslate"><span class="pre">*DeathTest</span></code> quando usa <code class="docutils literal notranslate"><span class="pre">ASSERT_DEATH</span></code>?<a class="headerlink" href="#why-does-googletest-require-the-entire-test-suite-instead-of-individual-tests-to-be-named-deathtest-when-it-uses-assert-death" title="Link to this heading">¶</a></h3>
<p>GoogleTest non intercala test di diverse test suite. Cioè, esegue prima tutti i test in una test suite, poi esegue tutti i test nella test suite successiva e così via. GoogleTest fa questo perché deve impostare una test suite prima che venga eseguito il primo test al suo interno ed eseguirne il «tear down» successivamente. La suddivisione del test case richiederebbe più processi di set-up e tear-down, il che è inefficiente e rende la semantica impura.</p>
<p>Se dovessimo determinare l’ordine dei test in base al nome del test invece che al nome del test case, avremmo un problema con la seguente situazione:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">AbcDeathTest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Uvw</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">BarTest</span><span class="p">,</span><span class="w"> </span><span class="n">DefDeathTest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">BarTest</span><span class="p">,</span><span class="w"> </span><span class="n">Xyz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Poiché <code class="docutils literal notranslate"><span class="pre">FooTest.AbcDeathTest</span></code> deve essere eseguito prima di <code class="docutils literal notranslate"><span class="pre">BarTest.Xyz</span></code>, e non interlacciamo test di diverse test suite, dobbiamo eseguire tutti i test nel caso <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> prima di eseguire qualsiasi test nel caso <code class="docutils literal notranslate"><span class="pre">BarTest</span></code>. Ciò è in contraddizione con l’obbligo di eseguire <code class="docutils literal notranslate"><span class="pre">BarTest.DefDeathTest</span></code> prima di <code class="docutils literal notranslate"><span class="pre">FooTest.Uvw</span></code>.</p>
</section>
<section id="but-i-don-t-like-calling-my-entire-test-suite-deathtest-when-it-contains-both-death-tests-and-non-death-tests-what-do-i-do">
<h3>Ma non mi piace chiamare tutta la mia test suite <code class="docutils literal notranslate"><span class="pre">*DeathTest</span></code> quando contiene sia death test che non. Cosa si deve fare?<a class="headerlink" href="#but-i-don-t-like-calling-my-entire-test-suite-deathtest-when-it-contains-both-death-tests-and-non-death-tests-what-do-i-do" title="Link to this heading">¶</a></h3>
<p>Non è necessario, ma volendo, si può suddividere la test suite in <code class="docutils literal notranslate"><span class="pre">FooTest</span></code> e <code class="docutils literal notranslate"><span class="pre">FooDeathTest</span></code>, dove i nomi chiariscono che sono correlati:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FooTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Abc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooTest</span><span class="p">,</span><span class="w"> </span><span class="n">Def</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="k">using</span><span class="w"> </span><span class="n">FooDeathTest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FooTest</span><span class="p">;</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">Uvw</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">EXPECT_DEATH</span><span class="p">(...)</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">FooDeathTest</span><span class="p">,</span><span class="w"> </span><span class="n">Xyz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">ASSERT_DEATH</span><span class="p">(...)</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="googletest-prints-the-log-messages-in-a-death-test-s-child-process-only-when-the-test-fails-how-can-i-see-the-log-messages-when-the-death-test-succeeds">
<h3>GoogleTest stampa i messaggi di LOG nel processo figlio di un death test solo quando il test fallisce. Come posso vedere i messaggi di LOG quando il death test ha successo?<a class="headerlink" href="#googletest-prints-the-log-messages-in-a-death-test-s-child-process-only-when-the-test-fails-how-can-i-see-the-log-messages-when-the-death-test-succeeds" title="Link to this heading">¶</a></h3>
<p>Stampare i messaggi di LOG generati dall’istruzione all’interno di <code class="docutils literal notranslate"><span class="pre">EXPECT_DEATH()</span></code> rende più difficile la ricerca di problemi reali nel log del genitore. Pertanto GoogleTest li stampa solo quando il death test è fallito.</p>
<p>Se c’è davvero bisogno di vedere tali messaggi di LOG, una soluzione alternativa è quella di interrompere temporaneamente il death test (ad esempio modificando il pattern regex che dovrebbe corrispondere). Certo, questo è un trucco. Prenderemo in considerazione una soluzione più permanente dopo l’implementazione dei death test in stile fork-and-exec.</p>
</section>
<section id="the-compiler-complains-about-no-match-for-operator-when-i-use-an-assertion-what-gives">
<h3>Il compilatore dice <code class="docutils literal notranslate"><span class="pre">no</span> <span class="pre">match</span> <span class="pre">for</span> <span class="pre">'operator&lt;&lt;'</span></code> quando si usa un’asserzione. Cosa dà?<a class="headerlink" href="#the-compiler-complains-about-no-match-for-operator-when-i-use-an-assertion-what-gives" title="Link to this heading">¶</a></h3>
<p>Se si usa un tipo definito dall’utente <code class="docutils literal notranslate"><span class="pre">FooType</span></code> in un’asserzione, ci dev’essere una funzione <code class="docutils literal notranslate"><span class="pre">std::ostream&amp;</span> <span class="pre">operator&lt;&lt;(std::ostream&amp;,</span> <span class="pre">const</span> <span class="pre">FooType&amp;)</span></code> definita in modo tale da poter stampare un valore di <code class="docutils literal notranslate"><span class="pre">FooType</span></code>.</p>
<p>Inoltre, se <code class="docutils literal notranslate"><span class="pre">FooType</span></code> è dichiarato in un namespace, anche l’operatore <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> deve essere definito nello <em>stesso</em> namespace. Vedere <a class="reference external" href="https://abseil.io/tips/49">Tip of the Week #49</a> per i dettagli.</p>
</section>
<section id="how-do-i-suppress-the-memory-leak-messages-on-windows">
<h3>Come sopprimere i messaggi riguardo ai memory leak su Windows?<a class="headerlink" href="#how-do-i-suppress-the-memory-leak-messages-on-windows" title="Link to this heading">¶</a></h3>
<p>Poiché il singleton GoogleTest inizializzato staticamente richiede allocazioni nell’heap, il rilevatore di memory leak di Visual C++ segnalerà le perdite di memoria alla fine dell’esecuzione del programma. Il modo più semplice per evitare ciò è utilizzare le chiamate <code class="docutils literal notranslate"><span class="pre">_CrtMemCheckpoint</span></code> e <code class="docutils literal notranslate"><span class="pre">_CrtMemDumpAllObjectsSince</span></code> per non riportare alcun oggetto heap inizializzato staticamente. Consultare MSDN per ulteriori dettagli e routine aggiuntive di check/debug.</p>
</section>
<section id="how-can-my-code-detect-if-it-is-running-in-a-test">
<h3>Come può il mio codice rilevare se è in esecuzione in un test?<a class="headerlink" href="#how-can-my-code-detect-if-it-is-running-in-a-test" title="Link to this heading">¶</a></h3>
<p>Se si scrive codice che «annusa» se è in esecuzione in un test e fa cose diverse di conseguenza, si sta perdendo la logica «test-only» nel codice di produzione e non esiste un modo semplice per garantire che i percorsi del codice test-only non vengano eseguiti per errore in produzione. Tale intelligenza porta anche agli <a class="reference external" href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbugs</a>. Pertanto sconsigliamo vivamente questa pratica e GoogleTest non fornisce un modo per farlo.</p>
<p>In generale, il modo consigliato per far sì che il codice si comporti diversamente durante il test è la <a class="reference external" href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a>. È possibile iniettare funzionalità diverse dal codice di test e quello di produzione. Poiché il codice di produzione non si collega affatto alla logica for-test (l’attributo <a class="reference external" href="https://docs.bazel.build/versions/master/be/common-definitions.html#common.testonly"><code class="docutils literal notranslate"><span class="pre">testonly</span></code></a> per i target BUILD aiuta a garantirlo), non c’è pericolo di eseguirlo accidentalmente.</p>
<p>Tuttavia, se <em>davvero</em>, <em>davvero</em>, <em>davvero</em> non si ha scelta e se si segue la regola di terminare i nomi dei programmi di test con <code class="docutils literal notranslate"><span class="pre">_test</span></code>, si può usare il trucco <em>orribile</em> di sniffare il nome dell’eseguibile (<code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> in <code class="docutils literal notranslate"><span class="pre">main()</span></code>) per sapere se il codice è in fase di test.</p>
</section>
<section id="how-do-i-temporarily-disable-a-test">
<h3>Come disattivare temporaneamente un test?<a class="headerlink" href="#how-do-i-temporarily-disable-a-test" title="Link to this heading">¶</a></h3>
<p>Se si ha un test non funzionante che non si può correggere subito, si può aggiungere il prefisso <code class="docutils literal notranslate"><span class="pre">DISABLED_</span></code> al nome. Ciò lo escluderà dall’esecuzione. Questo è meglio che commentare il codice o usare <code class="docutils literal notranslate"><span class="pre">#if</span> <span class="pre">0</span></code>, poiché i test disabilitati vengono comunque compilati (e quindi non «marciranno»).</p>
<p>Per includere i test disabilitati nell’esecuzione del test, basta richiamare il programma di test con il flag <code class="docutils literal notranslate"><span class="pre">--gtest_also_run_disabled_tests</span></code>.</p>
</section>
<section id="is-it-ok-if-i-have-two-separate-test-foo-bar-test-methods-defined-in-different-namespaces">
<h3>Va bene se ho due metodi di test &lt;<code class="docutils literal notranslate"><span class="pre">TEST(Foo,</span> <span class="pre">Bar)</span></code> separati definiti in namespace diversi?<a class="headerlink" href="#is-it-ok-if-i-have-two-separate-test-foo-bar-test-methods-defined-in-different-namespaces" title="Link to this heading">¶</a></h3>
<p>Sì.</p>
<p>La regola è che <strong>tutti i metodi dei test nella stessa test suite devono utilizzare la stessa classe fixture</strong>. Ciò significa che quanto segue è <strong>consentito</strong> poiché entrambi i test utilizzano la stessa classe fixture (<code class="docutils literal notranslate"><span class="pre">::testing::Test</span></code>).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="p">{</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">CoolTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoSomething</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">SUCCEED</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace foo</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">bar</span><span class="w"> </span><span class="p">{</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">CoolTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoSomething</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">SUCCEED</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace bar</span>
</pre></div>
</div>
<p>Tuttavia, il codice seguente <strong>non è consentito</strong> e genererà un errore a runtime da GoogleTest poiché i metodi di test utilizzano classi di fixture diverse con lo stesso nome della test suite.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="p">{</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CoolTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{};</span><span class="w">  </span><span class="c1">// Fixture foo::CoolTest</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">CoolTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoSomething</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">SUCCEED</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace foo</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">bar</span><span class="w"> </span><span class="p">{</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CoolTest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span><span class="w"> </span><span class="p">{};</span><span class="w">  </span><span class="c1">// Fixture: bar::CoolTest</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">CoolTest</span><span class="p">,</span><span class="w"> </span><span class="n">DoSomething</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">SUCCEED</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// namespace bar</span>
</pre></div>
</div>
</section>
</section>
<span id="document-docs/gmock_faq"></span><section id="legacy-gmock-faq">
<h2>Domande frequenti su gMock Legacy<a class="headerlink" href="#legacy-gmock-faq" title="Link to this heading">¶</a></h2>
<section id="when-i-call-a-method-on-my-mock-object-the-method-for-the-real-object-is-invoked-instead-what-s-the-problem">
<h3>Quando chiamo un metodo sul mio oggetto mock, viene invece richiamato il metodo per l’oggetto reale. Qual è il problema?<a class="headerlink" href="#when-i-call-a-method-on-my-mock-object-the-method-for-the-real-object-is-invoked-instead-what-s-the-problem" title="Link to this heading">¶</a></h3>
<p>Affinché un metodo possa essere mock-ato, deve essere <em>virtual</em>, a meno che non si utilizzi la <span class="xref myst">high-perf dependency injection technique</span>.</p>
</section>
<section id="can-i-mock-a-variadic-function">
<h3>Posso mock-are una funzione variadica?<a class="headerlink" href="#can-i-mock-a-variadic-function" title="Link to this heading">¶</a></h3>
<p>Non è possibile mock -are una funzione variadica (ovvero una funzione che accetta argomenti con puntini di sospensione <code class="docutils literal notranslate"><span class="pre">...</span></code>) direttamente in gMock.</p>
<p>Il problema è che, in generale, non c’è <em>nessun modo</em> per un oggetto mock di sapere quanti argomenti vengono passati al metodo variadico e quali sono i tipi degli argomenti. Solo l”<em>autore della classe base</em> conosce il protocollo e non possiamo guardargli nella testa.</p>
<p>Pertanto, per simulare una funzione del genere, l”<em>utente</em> deve insegnare all’oggetto mock-ato come calcolare il numero di argomenti e i loro tipi. Un modo per farlo è fornire versioni sovraccaricate [overloaded] della funzione.</p>
<p>Gli argomenti con i puntini di sospensione sono ereditati dal C e non sono realmente una funzionalità del C++. Non sono sicuri da usare e non funzionano con argomenti che hanno costruttori o distruttori. Pertanto consigliamo di evitarli il più possibile in C++.</p>
</section>
<section id="msvc-gives-me-warning-c4301-or-c4373-when-i-define-a-mock-method-with-a-const-parameter-why">
<h3>MSVC mi dà un warning C4301 o C4373 quando definisco un metodo mock con un parametro const. Perché?<a class="headerlink" href="#msvc-gives-me-warning-c4301-or-c4373-when-i-define-a-mock-method-with-a-const-parameter-why" title="Link to this heading">¶</a></h3>
<p>Se lo compili utilizzando Microsoft Visual C++ 2005 SP1:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockFoo</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Si potrebbe ricevere il seguente warning:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>warning<span class="w"> </span>C4301:<span class="w"> </span><span class="s1">&#39;MockFoo::Bar&#39;</span>:<span class="w"> </span>overriding<span class="w"> </span>virtual<span class="w"> </span><span class="k">function</span><span class="w"> </span>only<span class="w"> </span>differs<span class="w"> </span>from<span class="w"> </span><span class="s1">&#39;Foo::Bar&#39;</span><span class="w"> </span>by<span class="w"> </span>const/volatile<span class="w"> </span>qualifier
</pre></div>
</div>
<p>Questo è un bug di MSVC. Lo stesso codice viene compilato bene con gcc, ad esempio. Se si usa Visual C++ 2008 SP1, si riceverà il warning:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>warning<span class="w"> </span>C4373:<span class="w"> </span><span class="s1">&#39;MockFoo::Bar&#39;</span>:<span class="w"> </span>virtual<span class="w"> </span><span class="k">function</span><span class="w"> </span>overrides<span class="w"> </span><span class="s1">&#39;Foo::Bar&#39;</span>,<span class="w"> </span>previous<span class="w"> </span>versions<span class="w"> </span>of<span class="w"> </span>the<span class="w"> </span>compiler<span class="w"> </span>did<span class="w"> </span>not<span class="w"> </span>override<span class="w"> </span>when<span class="w"> </span>parameters<span class="w"> </span>only<span class="w"> </span>differed<span class="w"> </span>by<span class="w"> </span>const/volatile<span class="w"> </span>qualifiers
</pre></div>
</div>
<p>In C++, se si <em>dichiara</em> una funzione con un parametro <code class="docutils literal notranslate"><span class="pre">const</span></code>, il modificatore <code class="docutils literal notranslate"><span class="pre">const</span></code> viene ignorato. Pertanto, la classe base <code class="docutils literal notranslate"><span class="pre">Foo</span></code> sopra è equivalente a:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// int or const int?  Makes no difference.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Infatti, si può <em>dichiarare</em> <code class="docutils literal notranslate"><span class="pre">Bar()</span></code> con un parametro <code class="docutils literal notranslate"><span class="pre">int</span></code> e definirlo con un parametro <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span></code>. Il compilatore li abbinerà comunque.</p>
<p>Poiché la creazione di un parametro <code class="docutils literal notranslate"><span class="pre">const</span></code> non ha significato nella dichiarazione del metodo, consigliamo di rimuoverlo sia in <code class="docutils literal notranslate"><span class="pre">Foo</span></code> che in <code class="docutils literal notranslate"><span class="pre">MockFoo</span></code>. Ciò dovrebbe risolvere il bug VC.</p>
<p>Si noti che qui stiamo parlando del modificatore <em>top-level</em> <code class="docutils literal notranslate"><span class="pre">const</span></code>. Se il parametro della funzione viene passato tramite puntatore o riferimento, dichiarare il puntato o il riferito come <code class="docutils literal notranslate"><span class="pre">const</span></code> ha ancora senso. Ad esempio, le due dichiarazioni seguenti <em>non</em> sono equivalenti:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Bar</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w">         </span><span class="c1">// Neither p nor *p is const.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Bar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">);</span><span class="w">  </span><span class="c1">// p is not const, but *p is.</span>
</pre></div>
</div>
</section>
<section id="i-can-t-figure-out-why-gmock-thinks-my-expectations-are-not-satisfied-what-should-i-do">
<h3>Non riesco a capire perché gMock pensi che le mie aspettative non siano soddisfatte. Cosa dovrei fare?<a class="headerlink" href="#i-can-t-figure-out-why-gmock-thinks-my-expectations-are-not-satisfied-what-should-i-do" title="Link to this heading">¶</a></h3>
<p>Potresti voler eseguire il test con <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=info</span></code>. Questo flag consente a gMock di stampare un trace per ogni chiamata di funzione mock che riceve. Studiando il trace, si otterranno informazioni sul motivo per cui le aspettative [expectation] impostate non vengono soddisfatte.</p>
<p>Se si vede il messaggio «The mock function has no default action set, and its return type has no default value set.», provare ad <span class="xref myst">aggiungere un’azione di default</span>. A causa di un problema noto, le chiamate impreviste ai mock senza azioni di default non stampano un confronto dettagliato tra gli argomenti effettivi e quelli previsti.</p>
</section>
<section id="my-program-crashed-and-scopedmocklog-spit-out-tons-of-messages-is-it-a-gmock-bug">
<h3>Il mio programma è crashato e <code class="docutils literal notranslate"><span class="pre">ScopedMockLog</span></code> ha inviato tonnellate di messaggi. È un bug di gMock?<a class="headerlink" href="#my-program-crashed-and-scopedmocklog-spit-out-tons-of-messages-is-it-a-gmock-bug" title="Link to this heading">¶</a></h3>
<p>gMock e <code class="docutils literal notranslate"><span class="pre">ScopedMockLog</span></code> probabilmente stanno facendo la cosa giusta in questo caso.</p>
<p>Quando un test va in crash, l’handler del segnale di errore tenterà di loggare molte informazioni (il trace dello stack e la mappa degli indirizzi, ad esempio). I messaggi sono complessi se sono presenti molti thread con stack profondi. Quando <code class="docutils literal notranslate"><span class="pre">ScopedMockLog</span></code> intercetta questi messaggi e rileva che non corrispondono ad alcuna aspettativa, stampa un errore per ciascuno di essi.</p>
<p>Si può imparare a ignorare gli errori oppure si possono riscrivere le aspettative per rendere il test più robusto, ad esempio aggiungendo qualcosa come:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">AnyNumber</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Not</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// Ignores any log not done by us.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">Not</span><span class="p">(</span><span class="n">EndsWith</span><span class="p">(</span><span class="s">&quot;/my_file.cc&quot;</span><span class="p">)),</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="n">AnyNumber</span><span class="p">());</span>
</pre></div>
</div>
</section>
<section id="how-can-i-assert-that-a-function-is-never-called">
<h3>Come posso asserire che una funzione non viene MAI chiamata?<a class="headerlink" href="#how-can-i-assert-that-a-function-is-never-called" title="Link to this heading">¶</a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">Times</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="i-have-a-failed-test-where-gmock-tells-me-twice-that-a-particular-expectation-is-not-satisfied-isn-t-this-redundant">
<h3>Ho un test fallito in cui gMock mi dice DUE VOLTE che una particolare expectation non è soddisfatta. Non è ridondante?<a class="headerlink" href="#i-have-a-failed-test-where-gmock-tells-me-twice-that-a-particular-expectation-is-not-satisfied-isn-t-this-redundant" title="Link to this heading">¶</a></h3>
<p>Quando gMock rileva un errore, stampa le informazioni rilevanti (gli argomenti della funzione mock, lo stato delle expectation rilevanti, ecc.) per aiutare l’utente a eseguire il debug. Se viene rilevato un altro errore, gMock farà lo stesso, inclusa la stampa dello stato delle expectation rilevanti.</p>
<p>A volte lo stato di una expectation non cambia tra due fallimenti e si vedrà la stessa descrizione dello stato due volte. Tuttavia <em>non</em> sono ridondanti, poiché si riferiscono a <em>diversi momenti nel tempo</em>. Il fatto che siano la stessa cosa <em>è</em> un’informazione interessante.</p>
</section>
<section id="i-get-a-heapcheck-failure-when-using-a-mock-object-but-using-a-real-object-is-fine-what-can-be-wrong">
<h3>Ho un errore sul check dell’heap quando utilizzo un oggetto mock, ma usando un oggetto reale va bene. Cosa può esserci di sbagliato?<a class="headerlink" href="#i-get-a-heapcheck-failure-when-using-a-mock-object-but-using-a-real-object-is-fine-what-can-be-wrong" title="Link to this heading">¶</a></h3>
<p>La classe (si spera un’interfaccia pura) che si sta mock-ando ha un distruttore virtuale?</p>
<p>Ogni volta che si deriva da una classe base, assicurarsi che il suo distruttore sia virtuale. Altrimenti Accadranno Cose Brutte. Si consideri il seguente codice:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">// Not virtual, but should be.</span>
<span class="w">  </span><span class="o">~</span><span class="n">Base</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Derived</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w"> </span><span class="k">private</span><span class="o">:</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">...</span>
<span class="w">  </span><span class="n">Base</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Derived</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// Surprise! ~Base() will be called, but ~Derived() will not</span>
<span class="w">                 </span><span class="c1">// - value_ is leaked.</span>
</pre></div>
</div>
<p>Cambiando <code class="docutils literal notranslate"><span class="pre">~Base()</span></code> in virtual, <code class="docutils literal notranslate"><span class="pre">~Derived()</span></code> verrà chiamato correttamente quando viene eseguito <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">p</span></code> e il checker dell’heap sarà soddisfatto.</p>
</section>
<section id="the-newer-expectations-override-older-ones-rule-makes-writing-expectations-awkward-why-does-gmock-do-that">
<h3>La regola «Le expectation più nuove sovrascrivono quelle più vecchie» complica la scrittura delle expectation. Perché gMock lo fa?<a class="headerlink" href="#the-newer-expectations-override-older-ones-rule-makes-writing-expectations-awkward-why-does-gmock-do-that" title="Link to this heading">¶</a></h3>
<p>Quando le persone si lamentano di questo, spesso si riferiscono a codici come:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// foo.Bar() should be called twice, return 1 the first time, and return</span>
<span class="w">  </span><span class="c1">// 2 the second time.  However, I have to write the expectations in the</span>
<span class="w">  </span><span class="c1">// reverse order.  This sucks big time!!!</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
</pre></div>
</div>
<p>Il problema è che non hanno scelto il modo <strong>migliore</strong> per esprimere l’intento del test.</p>
<p>Per default, non è necessario che le expectation corrispondano in <em>ogni</em> particolare ordine. Se si vuole che corrispondano in un certo ordine, si deve essere espliciti. Questa è la filosofia fondamentale di gMock (e di jMock): è facile sovra-specificare accidentalmente i test e noi vogliamo rendere più difficile farlo.</p>
<p>Esistono due modi migliori per scrivere le specifiche del test. Si potrebbero mettere le expectation in sequenza:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// foo.Bar() should be called twice, return 1 the first time, and return</span>
<span class="w">  </span><span class="c1">// 2 the second time.  Using a sequence, we can write the expectations</span>
<span class="w">  </span><span class="c1">// in their natural order.</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">InSequence</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">())</span>
<span class="w">        </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
<span class="w">    </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">())</span>
<span class="w">        </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>oppure si può mettere la sequenza di azioni nella stessa expectation:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Return</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="c1">// foo.Bar() should be called twice, return 1 the first time, and return</span>
<span class="w">  </span><span class="c1">// 2 the second time.</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">())</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">RetiresOnSaturation</span><span class="p">();</span>
</pre></div>
</div>
<p>Torniamo alle domande originali: perché gMock cerca le expectation (e le <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code>) da dietro in avanti? Perché ciò consente all’utente di impostare in anticipo il comportamento di un mock per il caso comune (ad esempio nel costruttore del mock o nella fase di impostazione della fixture) e di personalizzarlo con regole più specifiche in seguito. Se gMock effettua la ricerca dalla parte anteriore a quella posteriore, questo modello molto utile non sarà possibile.</p>
</section>
<section id="gmock-prints-a-warning-when-a-function-without-expect-call-is-called-even-if-i-have-set-its-behavior-using-on-call-would-it-be-reasonable-not-to-show-the-warning-in-this-case">
<h3>gMock stampa un warning quando viene chiamata una funzione senza EXPECT_CALL, anche se ho impostato il suo comportamento utilizzando ON_CALL. Sarebbe ragionevole non mostrare il warning in questo caso?<a class="headerlink" href="#gmock-prints-a-warning-when-a-function-without-expect-call-is-called-even-if-i-have-set-its-behavior-using-on-call-would-it-be-reasonable-not-to-show-the-warning-in-this-case" title="Link to this heading">¶</a></h3>
<p>Quando scegliamo tra l’essere puliti e l’essere al sicuro, tendiamo verso quest’ultimo. Quindi la risposta è che pensiamo sia meglio mostrare il warning.</p>
<p>Spesso le persone scrivono <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> nel costruttore dell’oggetto mock o in <code class="docutils literal notranslate"><span class="pre">SetUp()</span></code>, poiché il comportamento di default raramente cambia da test a test. Poi nel corpo del test si stabiliscono le expectation, che spesso sono diverse per ogni test. Avere un <code class="docutils literal notranslate"><span class="pre">ON_CALL</span></code> nella parte del set-up di un test non significa che le chiamate siano previste [expected]. Se non c’è <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL</span></code> e il metodo viene chiamato, probabilmente si tratta di un errore. Se lasciamo passare la chiamata senza notificare all’utente, i bug potrebbero insinuarsi inosservati.</p>
<p>Se invece si è sicuri che le chiamate siano andate bene si può scrivere</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillRepeatedly</span><span class="p">(...);</span>
</pre></div>
</div>
<p>invece di</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="p">...</span>
<span class="w">  </span><span class="n">ON_CALL</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillByDefault</span><span class="p">(...);</span>
</pre></div>
</div>
<p>Questo dice a gMock che ci si aspettano le chiamate e non dovrebbe essere stampato alcun warning.</p>
<p>Inoltre, si può controllare la verbosità specificando <code class="docutils literal notranslate"><span class="pre">--gmock_verbose=error</span></code>. Altri valori sono <code class="docutils literal notranslate"><span class="pre">info</span></code> e <code class="docutils literal notranslate"><span class="pre">warning</span></code>. Se si ritiene che l’output sia troppo prolisso durante il debug, si sceglie semplicemente un livello meno dettagliato di verbosità.</p>
</section>
<section id="how-can-i-delete-the-mock-function-s-argument-in-an-action">
<h3>Come si può eliminare l’argomento della funzione mock in un’azione?<a class="headerlink" href="#how-can-i-delete-the-mock-function-s-argument-in-an-action" title="Link to this heading">¶</a></h3>
<p>Se la funzione mock accetta un argomento puntatore e si vuole eliminare quell’argomento, si può utilizzare testing::DeleteArg<N>() per il delete dell’N-esimo argomento (partendo da zero):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Y</span><span class="o">&amp;</span><span class="w"> </span><span class="n">y</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo_</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">testing</span><span class="o">::</span><span class="n">DeleteArg</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">()));</span>
</pre></div>
</div>
</section>
<section id="how-can-i-perform-an-arbitrary-action-on-a-mock-function-s-argument">
<h3>Come posso eseguire un’azione arbitraria sull’argomento di una funzione mock?<a class="headerlink" href="#how-can-i-perform-an-arbitrary-action-on-a-mock-function-s-argument" title="Link to this heading">¶</a></h3>
<p>Se si deve eseguire qualche azione non supportata direttamente da gMock, ci si ricordi che si possono definire le proprie azioni utilizzando <a class="reference internal" href="#NewMonoActions"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">MakeAction()</span></code></span></a> o <a class="reference internal" href="#NewPolyActions"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">MakePolymorphicAction()</span></code></span></a>, oppure si può scrivere una funzione stub e invocarla utilizzando <a class="reference internal" href="#FunctionsAsActions"><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">Invoke()</span></code></span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">_</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Invoke</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">));</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">mock_foo_</span><span class="p">,</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="n">_</span><span class="p">))</span>
<span class="w">      </span><span class="p">.</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">(</span><span class="n">MyAction</span><span class="p">(...)));</span>
</pre></div>
</div>
</section>
<section id="my-code-calls-a-static-global-function-can-i-mock-it">
<h3>Il mio codice chiama una funzione statica/globale. Posso renderla mock?<a class="headerlink" href="#my-code-calls-a-static-global-function-can-i-mock-it" title="Link to this heading">¶</a></h3>
<p>Si può, ma si devono apportare alcune modifiche.</p>
<p>In generale, se si deve rendere mock una funzione statica, è segno che i moduli sono accoppiati troppo strettamente (e meno flessibili, meno riutilizzabili, meno testabili, ecc.). Probabilmente sarebbe meglio definire una piccola interfaccia e chiamare la funzione attraverso quell’interfaccia, che quindi può essere facilmente resa mock. Inizialmente C’è un po” di lavoro, ma di solito si ripaga rapidamente.</p>
<p>Questo <a class="reference external" href="https://testing.googleblog.com/2008/06/defeat-static-cling.html">post</a> del Google Testing Blog lo dice in modo eccellente. Consultarlo.</p>
</section>
<section id="my-mock-object-needs-to-do-complex-stuff-it-s-a-lot-of-pain-to-specify-the-actions-gmock-sucks">
<h3>Il mio oggetto mock deve fare cose complesse. È molto faticoso specificare le azioni. gMock fa schifo!<a class="headerlink" href="#my-mock-object-needs-to-do-complex-stuff-it-s-a-lot-of-pain-to-specify-the-actions-gmock-sucks" title="Link to this heading">¶</a></h3>
<p>So che non è una domanda, ma riceverai comunque una risposta gratuitamente. :-)</p>
<p>Con gMock puoi creare facilmente mock in C++. E le persone potrebbero essere tentate di usarli ovunque. A volte funzionano alla grande, a volte potresti trovarli, beh, difficili da usare. Quindi, cosa c’è che non va in quest’ultimo caso?</p>
<p>Quando si scrive un test senza utilizzare mock, si sollecita il codice e si afferma che restituisce il valore corretto o che il sistema è in uno stato previsto. Questo è talvolta chiamato «test basato sullo stato».</p>
<p>I mock sono ottimi per quello che alcuni chiamano test «basati sull’interazione»: invece di controllare lo stato del sistema alla fine, gli oggetti mock verificano che siano invocati nel modo giusto e segnalano un errore non appena si verifica, dando un controllo preciso sul contesto in cui si è verificato l’errore. Questo è spesso più efficace ed economico rispetto ai test state-based.</p>
<p>Se si eseguono test basati sullo stato e si utilizza un test doppione solo per simulare l’oggetto reale, probabilmente è meglio utilizzare un falso. Usare un mock in questo caso è faticoso, poiché non è un punto di forza per i mock eseguire azioni complesse. Se ci si trova in questo caso e si pensa che i mock facciano schifo, semplicemente non si sta usando lo strumento giusto per il problema. Oppure si sta cercando di risolvere il problema sbagliato. :-)</p>
</section>
<section id="i-got-a-warning-uninteresting-function-call-encountered-default-action-taken-should-i-panic">
<h3>Ho ricevuto un warning «Uninteresting function call encountered - default action taken..» Devo andare nel panico?<a class="headerlink" href="#i-got-a-warning-uninteresting-function-call-encountered-default-action-taken-should-i-panic" title="Link to this heading">¶</a></h3>
<p>Certamente NO! E” solo per tua informazione. :-)</p>
<p>Ciò che si intende è che si ha una funzione mock, non è stata impostata alcuna expectation su di essa (secondo la regola di gMock ciò significa che non si è interessati alle chiamate a questa funzione e quindi può essere chiamata un numero qualsiasi di volte), e viene chiamata. Va bene: non è stato detto che non è OK chiamare la funzione!</p>
<p>Cosa succederebbe se in realtà si intendesse impedire la chiamata di questa funzione, ma ci si dimenticasse di scrivere <code class="docutils literal notranslate"><span class="pre">EXPECT_CALL(foo,</span> <span class="pre">Bar()).Times(0)</span></code>? Anche se si può sostenere che è colpa dell’utente, gMock cerca di essere gentile e stampa una nota.</p>
<p>Quindi, quando si vede il messaggio e si crede che non dovrebbero esserci chiamate poco interessanti, si dovrebbe indagare su cosa sta succedendo. Per semplificarci la vita, gMock scarica l’analisi dello stack quando viene incontrata una chiamata poco interessante. Da ciò si può capire quale funzione mock è e come viene chiamata.</p>
</section>
<section id="i-want-to-define-a-custom-action-should-i-use-invoke-or-implement-the-actioninterface-interface">
<h3>Voglio definire un’azione personalizzata. Dovrei usare Invoke() o implementare l’interfaccia ActionInterface?<a class="headerlink" href="#i-want-to-define-a-custom-action-should-i-use-invoke-or-implement-the-actioninterface-interface" title="Link to this heading">¶</a></h3>
<p>Va bene in ogni caso: si scelga quello più conveniente per le proprie circostanze.</p>
<p>Di solito, se l’azione riguarda un particolare tipo di funzione, definirla utilizzando <code class="docutils literal notranslate"><span class="pre">Invoke()</span></code> dovrebbe essere più semplice; se l’azione può essere utilizzata in funzioni di diverso tipo (ad esempio si sta definendo <code class="docutils literal notranslate"><span class="pre">Return(*value*)</span></code>), <code class="docutils literal notranslate"><span class="pre">MakePolymorphicAction()</span></code> è più semplice. A volte si vuole un controllo preciso sui tipi delle funzioni in cui può essere utilizzata l’azione e implementare <code class="docutils literal notranslate"><span class="pre">ActionInterface</span></code> è la strada da percorrere in questo caso. Vedere l’implementazione di <code class="docutils literal notranslate"><span class="pre">Return()</span></code> in <code class="docutils literal notranslate"><span class="pre">gmock-actions.h</span></code> per un esempio.</p>
</section>
<section id="i-use-setargpointee-in-willonce-but-gcc-complains-about-conflicting-return-type-specified-what-does-it-mean">
<h3>Io uso SetArgPointee() in WillOnce(), ma gcc si lamenta di «conflicting return type specified». Cosa significa?<a class="headerlink" href="#i-use-setargpointee-in-willonce-but-gcc-complains-about-conflicting-return-type-specified-what-does-it-mean" title="Link to this heading">¶</a></h3>
<p>Hai ricevuto questo errore poiché gMock non ha idea di quale valore dovrebbe restituire quando viene chiamato il metodo mock. <code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> dice qual è l’effetto collaterale, ma non dice quale dovrebbe essere il valore restituito. È necessario che <code class="docutils literal notranslate"><span class="pre">DoAll()</span></code> concateni un <code class="docutils literal notranslate"><span class="pre">SetArgPointee()</span></code> con un <code class="docutils literal notranslate"><span class="pre">Return()</span></code> che fornisca un valore appropriato all’API mock-ata.</p>
<p>Vedere questa <span class="xref myst">ricetta</span> per maggiori dettagli e un esempio.</p>
</section>
<section id="i-have-a-huge-mock-class-and-microsoft-visual-c-runs-out-of-memory-when-compiling-it-what-can-i-do">
<h3>Ho un’enorme classe mock e Microsoft Visual C++ va in «out of memory» durante la compilazione. Cosa posso fare?<a class="headerlink" href="#i-have-a-huge-mock-class-and-microsoft-visual-c-runs-out-of-memory-when-compiling-it-what-can-i-do" title="Link to this heading">¶</a></h3>
<p>Abbiamo notato che quando viene utilizzato il flag del compilatore <code class="docutils literal notranslate"><span class="pre">/clr</span></code>, Visual C++ usa 5~6 volte più memoria durante la compilazione di una classe mock. Suggeriamo di evitare <code class="docutils literal notranslate"><span class="pre">/clr</span></code> durante la compilazione di mock C++ nativi.</p>
</section>
</section>
<span id="document-docs/samples"></span><section id="googletest-samples">
<h2>Esempi di Googletest<a class="headerlink" href="#googletest-samples" title="Link to this heading">¶</a></h2>
<p>Sarete certamente interessati a dare un’occhiata agli <a class="reference external" href="https://github.com/google/googletest/blob/main/googletest/samples">esempi di googletest</a>. La directory «samples» contiene una serie di esempi ben commentati che mostrano come utilizzare diverse funzioni di googletest.</p>
<ul class="simple">
<li><p>Sample #1 mostra i passaggi fondamentali per utilizzare googletest per testare le funzioni C++.</p></li>
<li><p>Sample #2 mostra una unit test più complessa per una classe con più funzioni membro.</p></li>
<li><p>Sample #3 usa una fixture.</p></li>
<li><p>Sample #4 insegna come utilizzare googletest e <code class="docutils literal notranslate"><span class="pre">googletest.h</span></code> insieme per ottenere il meglio da entrambe le librerie.</p></li>
<li><p>Sample #5 inserisce la logica di test condivisi in una fixture di base e la riutilizza in fixture derivate.</p></li>
<li><p>Sample #6 illustra i test con tipi parametrizzati.</p></li>
<li><p>Sample #7 insegna le basi dei test valori parametrizzati.</p></li>
<li><p>Sample #8 mostra l’utilizzo di <code class="docutils literal notranslate"><span class="pre">Combine()</span></code> in test con valori parametrizzati.</p></li>
<li><p>Sample #9 mostra l’utilizzo dell’API listener per modificare l’output della console di Google Test e l’utilizzo della relativa API di [reflection] (riflessione) per esaminare i risultati del test.</p></li>
<li><p>Sample #10 mostra l’uso dell’API del listener per implementare un controllo primitivo per i memory leak.</p></li>
</ul>
</section>
<span id="document-docs/pkgconfig"></span><section id="using-googletest-from-various-build-systems">
<h2>Utilizzo di GoogleTest da vari sistemi di build<a class="headerlink" href="#using-googletest-from-various-build-systems" title="Link to this heading">¶</a></h2>
<p>GoogleTest viene fornito con file pkg-config utilizzabili per determinare tutti i flag necessari per la compilazione e il link a GoogleTest (e a GoogleMock). Pkg-config è un semplice formato di testo standardizzato contenente</p>
<ul class="simple">
<li><p>Il path di includedir (-I)</p></li>
<li><p>le definizioni di macro necessarie (-D)</p></li>
<li><p>ulteriori flag richiesti (-pthread)</p></li>
<li><p>il path della libreria (-L)</p></li>
<li><p>la libreria da linkare (-l)</p></li>
</ul>
<p>Tutti i sistemi di build attuali supportano pkg-config in un modo o nell’altro. Per tutti gli esempi qui assumiamo che si voglia compilare l’esempio <code class="docutils literal notranslate"><span class="pre">samples/sample3_unittest.cc</span></code>.</p>
<section id="cmake">
<h3>CMake<a class="headerlink" href="#cmake" title="Link to this heading">¶</a></h3>
<p>L’uso di <code class="docutils literal notranslate"><span class="pre">pkg-config</span></code> in CMake è abbastanza semplice:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">find_package</span><span class="p">(</span><span class="s">PkgConfig</span><span class="p">)</span>
<span class="nb">pkg_search_module</span><span class="p">(</span><span class="s">GTEST</span><span class="w"> </span><span class="s">REQUIRED</span><span class="w"> </span><span class="s">gtest_main</span><span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span><span class="s">testapp</span><span class="p">)</span>
<span class="nb">target_sources</span><span class="p">(</span><span class="s">testapp</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="s">samples/sample3_unittest.cc</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">testapp</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="o">${</span><span class="nv">GTEST_LDFLAGS</span><span class="o">}</span><span class="p">)</span>
<span class="nb">target_compile_options</span><span class="p">(</span><span class="s">testapp</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="o">${</span><span class="nv">GTEST_CFLAGS</span><span class="o">}</span><span class="p">)</span>

<span class="nb">enable_testing</span><span class="p">()</span>
<span class="nb">add_test</span><span class="p">(</span><span class="s">first_and_only_test</span><span class="w"> </span><span class="s">testapp</span><span class="p">)</span>
</pre></div>
</div>
<p>In genere è consigliabile utilizzare <code class="docutils literal notranslate"><span class="pre">target_compile_options</span></code> + <code class="docutils literal notranslate"><span class="pre">_CFLAGS</span></code> su <code class="docutils literal notranslate"><span class="pre">target_include_directories</span></code> + <code class="docutils literal notranslate"><span class="pre">_INCLUDE_DIRS</span></code> poiché il primo include non solo i flag -I (GoogleTest potrebbe richiedere una macro che indichi agli header interni che tutte le librerie sono state compilate con il threading abilitato. Inoltre, GoogleTest potrebbe anche richiedere <code class="docutils literal notranslate"><span class="pre">-pthread</span></code> nella fase di compilazione e, di conseguenza, dividere la variabile <code class="docutils literal notranslate"><span class="pre">Cflags</span></code> di pkg-config in include dir e macro per <code class="docutils literal notranslate"><span class="pre">target_compile_definitions()</span></code> potrebbe ancora perderlo). La stessa raccomandazione vale per l’utilizzo di <code class="docutils literal notranslate"><span class="pre">_LDFLAGS</span></code> al posto del più comune <code class="docutils literal notranslate"><span class="pre">_LIBRARIES</span></code>, che scarta i flag <code class="docutils literal notranslate"><span class="pre">-L</span></code> e <code class="docutils literal notranslate"><span class="pre">-pthread</span></code>.</p>
</section>
<section id="help-pkg-config-can-t-find-googletest">
<h3>Aiuto! pkg-config non trova GoogleTest!<a class="headerlink" href="#help-pkg-config-can-t-find-googletest" title="Link to this heading">¶</a></h3>
<p>Supponiamo che si abbia un <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> sulla falsariga di quello in questo tutorial e si provi a eseguire <code class="docutils literal notranslate"><span class="pre">cmake</span></code>. È molto probabile che si verifichi un problema sulla falsariga di:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span> <span class="n">Checking</span> <span class="k">for</span> <span class="n">one</span> <span class="n">of</span> <span class="n">the</span> <span class="n">modules</span> <span class="s1">&#39;gtest_main&#39;</span>
<span class="n">CMake</span> <span class="n">Error</span> <span class="n">at</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">cmake</span><span class="o">/</span><span class="n">Modules</span><span class="o">/</span><span class="n">FindPkgConfig</span><span class="o">.</span><span class="n">cmake</span><span class="p">:</span><span class="mi">640</span> <span class="p">(</span><span class="n">message</span><span class="p">):</span>
  <span class="kc">None</span> <span class="n">of</span> <span class="n">the</span> <span class="n">required</span> <span class="s1">&#39;gtest_main&#39;</span> <span class="n">found</span>
</pre></div>
</div>
<p>Questi errori sono comuni se GoogleTest è stato installato da solo e non lo fa parte di una distribuzione o di un altro gestore di pacchetti. Se è così, si deve dire a pkg-config dove può trovare i file <code class="docutils literal notranslate"><span class="pre">.pc</span></code> contenenti le informazioni. Supponiamo che GoogleTest sia installato su <code class="docutils literal notranslate"><span class="pre">/usr/local</span></code>, è possibile che i file <code class="docutils literal notranslate"><span class="pre">.pc</span></code> siano installati in <code class="docutils literal notranslate"><span class="pre">/usr/local/lib64/pkgconfig</span></code>. Se si imposta</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">PKG_CONFIG_PATH</span><span class="o">=/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">pkgconfig</span>
</pre></div>
</div>
<p>pkg-config proverà anche a cercare in <code class="docutils literal notranslate"><span class="pre">PKG_CONFIG_PATH</span></code> per trovare <code class="docutils literal notranslate"><span class="pre">gtest_main.pc</span></code>.</p>
</section>
<section id="using-pkg-config-in-a-cross-compilation-setting">
<h3>Uso di pkg-config in una impostazione di cross-compilazione<a class="headerlink" href="#using-pkg-config-in-a-cross-compilation-setting" title="Link to this heading">¶</a></h3>
<p>Pkg-config è utilizzabile anche in un ambiente di cross-compilazione. Per farlo, supponiamo che il prefisso finale dell’installazione cross-compilata sia <code class="docutils literal notranslate"><span class="pre">/usr</span></code> e che il sysroot sia <code class="docutils literal notranslate"><span class="pre">/home/MYUSER/sysroot</span></code>. Configurare e installare GTest con</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mkdir</span> <span class="n">build</span> <span class="o">&amp;&amp;</span> <span class="n">cmake</span> <span class="o">-</span><span class="n">DCMAKE_INSTALL_PREFIX</span><span class="o">=/</span><span class="n">usr</span> <span class="o">..</span>
</pre></div>
</div>
<p>Installare in sysroot con <code class="docutils literal notranslate"><span class="pre">DESTDIR</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="o">-</span><span class="n">j</span> <span class="n">install</span> <span class="n">DESTDIR</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">MYUSER</span><span class="o">/</span><span class="n">sysroot</span>
</pre></div>
</div>
<p>Prima di continuare, si consiglia di definire <strong>sempre</strong> le seguenti due variabili per pkg-config in un’impostazione di cross-compilazione:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">PKG_CONFIG_ALLOW_SYSTEM_CFLAGS</span><span class="o">=</span><span class="n">yes</span>
<span class="n">export</span> <span class="n">PKG_CONFIG_ALLOW_SYSTEM_LIBS</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>altrimenti <code class="docutils literal notranslate"><span class="pre">pkg-config</span></code> filtrerà i flag <code class="docutils literal notranslate"><span class="pre">-I</span></code> e <code class="docutils literal notranslate"><span class="pre">-L</span></code> rispetto ai prefissi standard come <code class="docutils literal notranslate"><span class="pre">/usr</span></code> (vedere https://bugs.freedesktop.org/show_bug.cgi?id=28264#c3 per i motivi per cui di solito è necessario eseguire questa rimozione).</p>
<p>Guardando il file pkg-config generato, sarà simile a</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>libdir=/usr/lib64
includedir=/usr/include

Name: gtest
Description: GoogleTest (without main() function)
Version: 1.11.0
URL: https://github.com/google/googletest
Libs: -L${libdir} -lgtest -lpthread
Cflags: -I${includedir} -DGTEST_HAS_PTHREAD=1 -lpthread
</pre></div>
</div>
<p>Notare che sysroot non è incluso in <code class="docutils literal notranslate"><span class="pre">libdir</span></code> e in <code class="docutils literal notranslate"><span class="pre">includedir</span></code>! Provando ad eseguire <code class="docutils literal notranslate"><span class="pre">pkg-config</span></code> col <code class="docutils literal notranslate"><span class="pre">PKG_CONFIG_LIBDIR=/home/MYUSER/sysroot/usr/lib64/pkgconfig</span></code> corretto rispetto a questo file <code class="docutils literal notranslate"><span class="pre">.pc</span></code>, si otterrà</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pkg-config --cflags gtest
-DGTEST_HAS_PTHREAD=1 -lpthread -I/usr/include
$ pkg-config --libs gtest
-L/usr/lib64 -lgtest -lpthread
</pre></div>
</div>
<p>che è ovviamente sbagliato e punta alla radice di <code class="docutils literal notranslate"><span class="pre">CBUILD</span></code> e non di <code class="docutils literal notranslate"><span class="pre">CHOST</span></code>. Per usarlo in un’impostazione di cross-compilazione, dobbiamo dire a pkg-config di inserire l’attuale sysroot nelle variabili <code class="docutils literal notranslate"><span class="pre">-I</span></code> e <code class="docutils literal notranslate"><span class="pre">-L</span></code>. Diciamo ora a pkg-config il vero sysroot</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>export PKG_CONFIG_DIR=
export PKG_CONFIG_SYSROOT_DIR=/home/MYUSER/sysroot
export PKG_CONFIG_LIBDIR=${PKG_CONFIG_SYSROOT_DIR}/usr/lib64/pkgconfig
</pre></div>
</div>
<p>ed eseguendo nuovamente <code class="docutils literal notranslate"><span class="pre">pkg-config</span></code> otteniamo</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pkg-config --cflags gtest
-DGTEST_HAS_PTHREAD=1 -lpthread -I/home/MYUSER/sysroot/usr/include
$ pkg-config --libs gtest
-L/home/MYUSER/sysroot/usr/lib64 -lgtest -lpthread
</pre></div>
</div>
<p>che ora contiene il sysroot corretto. Per una guida più completa su come includere anche <code class="docutils literal notranslate"><span class="pre">${CHOST}</span></code> nelle chiamate di sistema della build, vedere l’eccellente tutorial di Diego
Elio Pettenò: <a class="reference external" href="https://autotools.io/pkgconfig/cross-compiling.html">https://autotools.io/pkgconfig/cross-compiling.html</a></p>
</section>
</section>
<span id="document-docs/community_created_documentation"></span><section id="community-created-documentation">
<h2>Documentazione Creata dalla Comunità<a class="headerlink" href="#community-created-documentation" title="Link to this heading">¶</a></h2>
<p>Di seguito è riportato un elenco, senza un ordine particolare, dei link alla documentazione creata dalla community di Googletest.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/ElectricRCAircraftGuy/eRCaGuy_dotfiles/blob/master/googletest/insights.md">Googlemock Insights</a>, di <a class="reference external" href="https://github.com/ElectricRCAircraftGuy">ElectricRCAircraftGuy</a></p></li>
</ul>
</section>
</div>
</section>
<section id="indices-and-tables">
<h1>Indice e tabelle<a class="headerlink" href="#indices-and-tables" title="Link to this heading">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Indice</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Indice dei moduli</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Cerca</span></a></p></li>
</ul>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">GoogleTest</a></h1>








<h3>Navigazione</h3>
<p class="caption" role="heading"><span class="caption-text">Contenuto:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/index">Guida Utente di GoogleTest</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-CONTRIBUTING">How to become a contributor and submit your own code</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-README">GoogleTest</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Piattaforme Supportate:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/platforms">Piattaforme Supportate</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/quickstart-bazel">Quickstart: Il Building con Bazel</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/quickstart-cmake">Quickstart: Il Building con CMake</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guide:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/primer">Guida di GoogleTest</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/advanced">Argomenti avanzati di GoogleTest</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/gmock_for_dummies">gMock per Principianti</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/gmock_cook_book">Ricettario di gMock</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/gmock_cheat_sheet">Cheat Sheet di gMock</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Riferimenti:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/primer">Guida di GoogleTest</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/faq">FAQ di GoogleTest</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/gmock_faq">Domande frequenti su gMock Legacy</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/samples">Esempi di Googletest</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/pkgconfig">Utilizzo di GoogleTest da vari sistemi di build</a></li>
<li class="toctree-l1"><a class="reference internal" href="#document-docs/community_created_documentation">Documentazione Creata dalla Comunità</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, GoogleTest Community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>