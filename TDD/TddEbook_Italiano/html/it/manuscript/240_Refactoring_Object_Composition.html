<!DOCTYPE html>

<html lang="it" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Composizione di Oggetti come Linguaggio &#8212; Documentazione TDD 2025 </title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=ad698211"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=45930005"></script>
    <link rel="index" title="Indice" href="../genindex.html" />
    <link rel="search" title="Cerca" href="../search.html" />
    <link rel="next" title="Gli Oggetti Valore" href="250_Value_Objects.html" />
    <link rel="prev" title="Le Classi" href="235_Classes.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="object-composition-as-a-language">
<h1>Composizione di Oggetti come Linguaggio<a class="headerlink" href="#object-composition-as-a-language" title="Link to this heading">¶</a></h1>
<p>Mentre la maggior parte dei capitoli precedenti parlava molto della visualizzazione della composizione degli oggetti come una rete, questo avrà una visione diversa -- quella di un linguaggio. Questi due punti di vista sono notevolmente simili e si completano a vicenda nel guidare la progettazione.</p>
<p>Potrebbe sorprendere il fatto che io stia paragonando la composizione degli oggetti a un linguaggio, ma, come spero si vedrà, ci sono molte somiglianze. Ci arriveremo passo dopo passo, il primo passo sarà dare una seconda occhiata alla <em>composition root</em>.</p>
<section id="more-readable-composition-root">
<h2>Una <em>composition root</em> più leggibile<a class="headerlink" href="#more-readable-composition-root" title="Link to this heading">¶</a></h2>
<p>Nel descrivere la composizione dell'oggetto e la <em>composition root</em> in particolare, ho promesso di tornare sull'argomento per rendere il codice di composizione più pulito e leggibile.</p>
<p>Prima di farlo, tuttavia, dobbiamo trovare una risposta a una domanda importante...</p>
<section id="why-bother">
<h3>Perché preoccuparsi?<a class="headerlink" href="#why-bother" title="Link to this heading">¶</a></h3>
<p>A questo punto si sarà stufi di come sottolineo l'importanza della componibilità. Lo faccio, però, perché credo che sia uno degli aspetti più importanti di classi ben progettate. Inoltre, ho detto che per raggiungere un'elevata componibilità di una classe, essa deve essere indipendente dal contesto. Per spiegare come raggiungere questa indipendenza, ho introdotto il principio di separare l'uso dell'oggetto dalla costruzione, relegando la parte di costruzione in luoghi specializzati nel codice. Ho anche detto che si può contribuire molto a questa qualità rendendo astratte le interfacce e i protocolli e facendo in modo che espongano il minor numero possibile di dettagli dell'implementazione.</p>
<p>Tutto ciò ha però il suo costo. La ricerca di un'elevata indipendenza dal contesto ci toglie la capacità di osservare una singola classe e determinarne il contesto semplicemente leggendone il codice. Questa classe conosce ben poco del contesto in cui opera. Ad esempio, qualche capitolo fa abbiamo trattato delle sessioni di dumping e ho mostrato che tale metodo di dump può essere implementato in questo modo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">RealSession</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">Session</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">DumpInto</span><span class="p">(</span><span class="n">Destination</span><span class="w"> </span><span class="n">destination</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">destination</span><span class="p">.</span><span class="n">AcceptOwner</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">owner</span><span class="p">);</span>
<span class="w">    </span><span class="n">destination</span><span class="p">.</span><span class="n">AcceptTarget</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">target</span><span class="p">);</span>
<span class="w">    </span><span class="n">destination</span><span class="p">.</span><span class="n">AcceptExpiryTime</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">expiryTime</span><span class="p">);</span>
<span class="w">    </span><span class="n">destination</span><span class="p">.</span><span class="n">Done</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Qui, la sessione sa che qualunque sia la destinazione, <code class="docutils literal notranslate"><span class="pre">Destination</span></code> accetta proprietario, i target e la scadenza e deve essere informata quando tutte le informazioni le vengono passate. Tuttavia, leggendo questo codice, non possiamo dire dove porta la destinazione, poiché <code class="docutils literal notranslate"><span class="pre">Destination</span></code> è un'interfaccia che astrae i dettagli.  È un ruolo che può essere svolto da un file, una connessione di rete, uno schermo della console o un widget della GUI. L'indipendenza dal contesto consente la componibilità.</p>
<p>D'altra parte, per quanto le classi e le interfacce indipendenti dal contesto siano importanti, lo è anche il comportamento dell'applicazione nel suo insieme. Non ho detto che l'obiettivo della componibilità è poter modificare più facilmente il comportamento dell'applicazione? Ma come possiamo decidere consapevolmente di modificare il comportamento dell'applicazione se non lo comprendiamo? E non oltre l’ultimo paragrafo abbiamo concluso che limitarsi a leggere una classe dopo l’altra non è sufficiente. Dobbiamo avere una visione di come queste classi lavorano insieme come un sistema. Allora, dov'è il contesto generale che definisce il comportamento dell'applicazione?</p>
<p>Il contesto è nel codice di composizione -- il codice che collega gli oggetti, passando veri collaboratori a ciascuno di essi e mostrando come le parti connesse formano un tutto.</p>
</section>
<section id="example">
<h3>Esempio<a class="headerlink" href="#example" title="Link to this heading">¶</a></h3>
<p>Presumo che ci si ricordi a malapena l'esempio degli allarmi che ho fornito in uno dei primi capitoli di questa parte del libro per spiegare il cambiamento del comportamento modificando la composizione dell'oggetto. Comunque, solo per ricordarlo, abbiamo terminato con un codice simile a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">SecureArea</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">DayNightSwitchedAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span><span class="w"> </span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">StorageBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">GuardsBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//call police</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Quindi avevamo tre edifici tutti dotati di allarmi. La caratteristica interessante di questo codice era che ci potevamo leggere le impostazioni dell'allarme, ad es. la seguente parte della composizione:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">DayNightSwitchedAlarm</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span><span class="w"> </span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">),</span>
</pre></div>
</div>
<p>significava che stavamo organizzando un edificio di uffici con un allarme che chiama il numero &quot;222-333-444&quot; quando viene attivato durante il giorno, ma ci sono sirene assordanti viene attivato di notte. Potremmo leggerlo direttamente dal codice di composizione, a patto di sapere cosa ha aggiunto ciascun oggetto al comportamento composito complessivo. Quindi, ancora una volta, la composizione delle parti descrive il comportamento dell’insieme. C'è, tuttavia, un'altra cosa da notare su questo pezzo di codice: descrive il comportamento senza dichiarare esplicitamente il suo flusso di controllo (<code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">else</span></code>, <code class="docutils literal notranslate"><span class="pre">for</span></code>, ecc.). Tale descrizione è spesso chiamata <em>dichiarativa</em> -- componendo oggetti, scriviamo <em>cosa</em> vogliamo ottenere senza scrivere <em>come</em> ottenerlo -- il flusso di controllo stesso è nascosto all'interno degli oggetti.</p>
<p>Riassumiamo queste due conclusioni con la seguente affermazione:</p>
<p><a class="reference internal" href="../_images/Info.png"><img alt="Info" class="align-left" src="../_images/Info.png" style="width: 30px;" /></a> Il codice di composizione è una descrizione dichiarativa del comportamento generale della nostra applicazione.</p>
<p>Wow, questa è una bella affermazione, vero? Ma, come abbiamo già notato, è vero. Esiste tuttavia un problema nel trattare il codice di composizione come una descrizione complessiva dell'applicazione: la leggibilità. Anche se la composizione <em>è</em> la descrizione del sistema, non si legge in modo naturale. Vogliamo vedere la descrizione del comportamento, ma la maggior parte di ciò che vediamo è: <code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">new</span></code>, <code class="docutils literal notranslate"><span class="pre">new</span></code>... C'è molto rumore sintattico coinvolto, specialmente nei sistemi reali, dove il codice di composizione è molto più lungo di questo piccolo esempio. Non possiamo fare qualcosa al riguardo?</p>
</section>
</section>
<section id="refactoring-for-readability">
<h2>Il refactoring per la leggibilità<a class="headerlink" href="#refactoring-for-readability" title="Link to this heading">¶</a></h2>
<p>La dichiaratività del codice di composizione va di pari passo con un approccio di definizione delle cosiddette <em>interfacce fluenti</em>. Una <em>interfaccia fluente</em> è un'API realizzata pensando alla leggibilità e alla lettura scorrevole. Di solito è dichiarativa e mirata a un dominio specifico, quindi un altro nome: <em>internal domain-specific languages</em> [<em>linguaggi interni specifici del dominio</em>], in breve: DSL.</p>
<p>Esistono alcuni semplici pattern per creare tali linguaggi specifici del dominio. Uno di questi che può essere applicato alla nostra situazione è chiamato <em>nested function</em><a class="footnote-reference brackets" href="#fowlerdsl" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, che, nel nostro contesto, significa racchiudere una chiamata a <code class="docutils literal notranslate"><span class="pre">new</span></code> con un metodo più descrittivo. Potrebbe risultare confuso, ma vedremo come funziona nella pratica tra un secondo. Lo faremo passo dopo passo, quindi ci sarà molto codice ripetuto, ma si spera che si possa osservare da vicino il processo di miglioramento della leggibilità del codice di composizione.</p>
<p>Ok, rivediamo il codice prima di apportare qualsiasi modifica:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">SecureArea</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">DayNightSwitchedAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span><span class="w"> </span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">StorageBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">GuardsBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//call police</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Notare che abbiamo diversi posti in cui creiamo <code class="docutils literal notranslate"><span class="pre">SilentAlarm</span></code>. Spostiamo la creazione di questi oggetti in un metodo separato:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="nf">Calls</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Questo passaggio può sembrare sciocco (dopo tutto, stiamo introducendo un metodo che racchiude una singola riga di codice), ma ha molto senso. Innanzitutto, ci permette di ridurre il rumore della sintassi -- quando dobbiamo creare un allarme silenzioso, non dobbiamo più dire <code class="docutils literal notranslate"><span class="pre">new</span></code>. Un altro vantaggio è che possiamo descrivere il ruolo che gioca un'istanza <code class="docutils literal notranslate"><span class="pre">SilentAlarm</span></code> nella nostra composizione (spiegherò più avanti perché lo stiamo facendo utilizzando la voce passiva).</p>
<p>Dopo aver sostituito ogni invocazione del costruttore <code class="docutils literal notranslate"><span class="pre">SilentAlarm</span></code> con una chiamata a questo metodo, otteniamo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">SecureArea</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">DayNightSwitchedAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">StorageBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">GuardsBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//police number</span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Successivamente, facciamo lo stesso con <code class="docutils literal notranslate"><span class="pre">LoudAlarm</span></code>, racchiudendo la sua creazione in un metodo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="nf">MakesLoudNoise</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>e il codice di composizione dopo aver applicato questo metodo assomiglia a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">SecureArea</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">DayNightSwitchedAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span><span class="w"> </span>
<span class="w">      </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">StorageBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">      </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">GuardsBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//police number</span>
<span class="w">      </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Si noti che abbiamo rimosso alcuni <code class="docutils literal notranslate"><span class="pre">new</span></code> in favore di qualcosa di più leggibile. Questo è esattamente ciò che intendevo con &quot;ridurre il rumore della sintassi&quot;.</p>
<p>Ora concentriamoci un po' su questa parte:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">GuardsBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//police number</span>
<span class="w">      </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
</pre></div>
</div>
<p>e proviamo ad applicare lo stesso trucco introducendo un metodo factory alla creazione di <code class="docutils literal notranslate"><span class="pre">HybridAlarm</span></code>. Ci viene sempre detto che i nomi delle classi dovrebbero essere sostantivi ed è per questo che <code class="docutils literal notranslate"><span class="pre">HybridAlarm</span></code> si chiama così. Ma non funziona bene come descrizione di ciò che fa il sistema. La sua vera funzione è quella di attivare entrambi gli allarmi quando viene attivato. Dobbiamo quindi trovare un nome migliore. Dovremmo chiamare il metodo <code class="docutils literal notranslate"><span class="pre">TriggersBothAlarms()</span></code>? No, è troppo rumore -- sappiamo già che stiamo attivando degli allarmi, quindi possiamo tralasciare la parte &quot;alarms&quot;. E &quot;triggers&quot;? Dice cosa fa l'allarme ibrido, il che potrebbe sembrare buono, ma quando guardiamo la composizione, <code class="docutils literal notranslate"><span class="pre">Calls()</span></code> e <code class="docutils literal notranslate"><span class="pre">MakesLoudNoise()</span></code> dicono già cosa viene fatto. <code class="docutils literal notranslate"><span class="pre">HybridAlarm</span></code> dice solo che entrambe le cose accadono contemporaneamente. Potremmo lasciare <code class="docutils literal notranslate"><span class="pre">Trigger</span></code> se cambiassimo i nomi degli altri metodi nella composizione in questo modo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">GuardsBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="n">TriggersBoth</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calling</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//police number</span>
<span class="w">      </span><span class="n">LoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
</pre></div>
</div>
<p>Ma ciò renderebbe fuori posto i nomi <code class="docutils literal notranslate"><span class="pre">Calling()</span></code> e <code class="docutils literal notranslate"><span class="pre">LoudNoise()</span></code> ovunque non siano annidati come argomenti di <code class="docutils literal notranslate"><span class="pre">TriggersBoth()</span></code>. Ad esempio, se volessimo realizzare un altro edificio che utilizzi solo un allarme sonoro, la composizione sarebbe simile a questa:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">OtherBuilding</span><span class="p">(</span><span class="n">LoudNoise</span><span class="p">());</span>
</pre></div>
</div>
<p>o se volessimo usare quello silenzioso:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">OtherBuilding</span><span class="p">(</span><span class="n">Calling</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Invece, proviamo a chiamare il metodo che racchiude la costruzione di <code class="docutils literal notranslate"><span class="pre">HybridAlarm</span></code> semplicemente <code class="docutils literal notranslate"><span class="pre">Both()</span></code> -- è semplice e comunica bene il ruolo svolto dagli allarmi ibridi -- dopo tutto, sono solo una sorta di operatori combinati, non allarmi reali. In questo modo, il nostro codice di composizione ora è:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">GuardsBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="n">Both</span><span class="p">(</span>
<span class="w">    </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//police number</span>
<span class="w">    </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>e, a proposito, il metodo <code class="docutils literal notranslate"><span class="pre">Both()</span></code> è definito come:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="nf">Both</span><span class="p">(</span><span class="n">Alarm</span><span class="w"> </span><span class="n">alarm1</span><span class="p">,</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="n">alarm2</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span><span class="n">alarm1</span><span class="p">,</span><span class="w"> </span><span class="n">alarm2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Da ricordare che <code class="docutils literal notranslate"><span class="pre">HybridAlarm</span></code> è stato utilizzato anche nella composizione dell'istanza <code class="docutils literal notranslate"><span class="pre">StorageBuilding</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">StorageBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">    </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">),</span>
</pre></div>
</div>
<p>che ora diventa:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">StorageBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="n">Both</span><span class="p">(</span>
<span class="w">    </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">),</span>
</pre></div>
</div>
<p>Ora la parte più difficile -- trovare un modo per rendere leggibile la seguente parte di codice:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">DayNightSwitchedAlarm</span><span class="p">(</span>
<span class="w">    </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span><span class="w"> </span>
<span class="w">    </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">),</span>
</pre></div>
</div>
<p>La difficoltà qui è che <code class="docutils literal notranslate"><span class="pre">DayNightSwitchedAlarm</span></code> accetta due allarmi che vengono utilizzati alternativamente. Dobbiamo inventare un termine che:</p>
<ol class="arabic simple">
<li><p>Dica che è un'alternativa.</p></li>
<li><p>Dica di che tipo di alternativa si tratta (cioè che una avviene di giorno e l'altra di notte).</p></li>
<li><p>Dica quale allarme è collegato a quale condizione (l'allarme silenzioso viene utilizzato durante il giorno e quello sonoro durante la notte).</p></li>
</ol>
<p>Se introduciamo un singolo nome, ad es. <code class="docutils literal notranslate"><span class="pre">FirstDuringDayAndSecondAtNight()</span></code>, sembrerà imbarazzante e perderemo il flusso. Uno sguardo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="n">FirstDuringDayAndSecondAtNight</span><span class="p">(</span>
<span class="w">    </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">    </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">),</span>
</pre></div>
</div>
<p>Semplicemente non suona bene... Dobbiamo trovare un altro approccio a questa situazione. Ci sono due approcci che possiamo considerare:</p>
<section id="approach-1-use-named-parameters">
<h3>Approccio 1: utilizzare i [<em>named parameter</em>]<a class="headerlink" href="#approach-1-use-named-parameters" title="Link to this heading">¶</a></h3>
<p>I [<em>named parameter</em>] sono una funzionalità di linguaggi come Python o C#. In breve, quando abbiamo un metodo come questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">DoSomething</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">second</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>possiamo chiamarlo con i nomi dei suoi argomenti dichiarati esplicitamente, in questo modo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">DoSomething</span><span class="p">(</span><span class="n">first</span><span class="p">:</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">:</span><span class="w"> </span><span class="mi">33</span><span class="p">);</span>
</pre></div>
</div>
<p>Possiamo utilizzare questa tecnica per rifattorizzare la creazione di <code class="docutils literal notranslate"><span class="pre">DayNightSwitchedAlarm</span></code> nel seguente metodo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="nf">DependingOnTimeOfDay</span><span class="p">(</span>
<span class="w">    </span><span class="n">Alarm</span><span class="w"> </span><span class="n">duringDay</span><span class="p">,</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="n">atNight</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">DayNightSwitchedAlarm</span><span class="p">(</span><span class="n">duringDay</span><span class="p">,</span><span class="w"> </span><span class="n">atNight</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span>
</pre></div>
</div>
<p>Questo ci permette di scrivere il codice di composizione in questo modo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="n">DependingOnTimeOfDay</span><span class="p">(</span>
<span class="w">    </span><span class="n">duringDay</span><span class="p">:</span><span class="w"> </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span><span class="w"> </span>
<span class="w">    </span><span class="n">atNight</span><span class="p">:</span><span class="w"> </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">),</span>
</pre></div>
</div>
<p>che è abbastanza leggibile. L'uso dei [<em>named parameter</em> ha questo piccolo vantaggio aggiuntivo che ci consente di passare gli argomenti in un ordine diverso in cui sono stati dichiarati, grazie ai loro nomi dichiarati esplicitamente. Ciò rende valide entrambe le seguenti invocazioni:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">//this is valid:</span>
<span class="n">DependingOnTimeOfDay</span><span class="p">(</span>
<span class="w">  </span><span class="n">duringDay</span><span class="p">:</span><span class="w"> </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span><span class="w"> </span>
<span class="w">  </span><span class="n">atNight</span><span class="p">:</span><span class="w"> </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="p">)</span>

<span class="c1">//arguments in different order,</span>
<span class="c1">//but this is valid as well:</span>
<span class="n">DependingOnTimeOfDay</span><span class="p">(</span>
<span class="w">  </span><span class="n">atNight</span><span class="p">:</span><span class="w"> </span><span class="n">MakesLoudNoise</span><span class="p">(),</span>
<span class="w">  </span><span class="n">duringDay</span><span class="p">:</span><span class="w"> </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">)</span><span class="w">  </span>
<span class="p">)</span>
</pre></div>
</div>
<p>Passiamo ora al secondo approccio.</p>
</section>
<section id="approach-2-use-method-chaining">
<h3>Approccio 2: utilizzare il concatenamento dei metodi<a class="headerlink" href="#approach-2-use-method-chaining" title="Link to this heading">¶</a></h3>
<p>Questo approccio è meglio traducibile in diversi linguaggi e può essere utilizzato ad es. in Java e in C++. Questa volta, prima di mostrarvi l'implementazione, diamo un'occhiata al risultato finale che vogliamo ottenere:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="n">DependingOnTimeOfDay</span>
<span class="w">    </span><span class="p">.</span><span class="n">DuringDay</span><span class="p">(</span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">AtNight</span><span class="p">(</span><span class="n">MakesLoudNoise</span><span class="p">())</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">),</span>
</pre></div>
</div>
<p>Quindi, è molto simile nella lettura, la differenza principale è che richiede più lavoro. Potrebbe non essere ovvio fin dall'inizio come funziona questo tipo di passaggio di parametri:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">DependingOnTimeOfDay</span>
<span class="w">  </span><span class="p">.</span><span class="n">DuringDay</span><span class="p">(...)</span>
<span class="w">  </span><span class="p">.</span><span class="n">AtNight</span><span class="p">(...)</span>
</pre></div>
</div>
<p>quindi decodifichiamolo. Innanzitutto, <code class="docutils literal notranslate"><span class="pre">DependingOnTimeOfDay</span></code>. Questa è solo una classe:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">DependingOnTimeOfDay</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>che ha un metodo statico chiamato <code class="docutils literal notranslate"><span class="pre">DuringDay()</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">//note: this method is static</span>
<span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span>
<span class="n">DependingOnTimeOfDay</span><span class="w"> </span><span class="nf">DuringDay</span><span class="p">(</span><span class="n">Alarm</span><span class="w"> </span><span class="n">alarm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">DependingOnTimeOfDay</span><span class="p">(</span><span class="n">alarm</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//The constructor is private:</span>
<span class="k">private</span><span class="w"> </span><span class="nf">DependingOnTimeOfDay</span><span class="p">(</span><span class="n">Alarm</span><span class="w"> </span><span class="n">dayAlarm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">_dayAlarm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dayAlarm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ora, questo metodo sembra strano, non è vero? È un metodo statico che restituisce un'istanza della classe che lo racchiude (non un vero allarme!). Inoltre, il costruttore privato memorizza l'allarme trasmesso per poterlo utilizzare in seguito... perché?</p>
<p>Il mistero si risolve quando guardiamo un altro metodo definito nella classe <code class="docutils literal notranslate"><span class="pre">DependingOnTimeOfDay</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">//note: this method is NOT static</span>
<span class="k">public</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="nf">AtNight</span><span class="p">(</span><span class="n">Alarm</span><span class="w"> </span><span class="n">nightAlarm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">DayNightSwitchedAlarm</span><span class="p">(</span><span class="n">_dayAlarm</span><span class="p">,</span><span class="w"> </span><span class="n">nightAlarm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Questo metodo non è statico e restituisce l'allarme che stavamo cercando di creare. Per fare ciò, utilizza il primo allarme passato attraverso il costruttore e il secondo passato come parametro. Quindi se dovessimo prendere questo costrutto:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">DependingOnTimeOfDay</span><span class="w"> </span><span class="c1">//class</span>
<span class="w">  </span><span class="p">.</span><span class="n">DuringDay</span><span class="p">(</span><span class="n">dayAlarm</span><span class="p">)</span><span class="w"> </span><span class="c1">//static method</span>
<span class="w">  </span><span class="p">.</span><span class="n">AtNight</span><span class="p">(</span><span class="n">nightAlarm</span><span class="p">)</span><span class="w"> </span><span class="c1">//non-static method</span>
</pre></div>
</div>
<p>e assegnare il risultato di ciascuna operazione a una variabile separata, sarebbe simile a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">DependingOnTimeOfDay</span><span class="w"> </span><span class="n">firstPart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DependingOnTimeOfDay</span><span class="p">.</span><span class="n">DuringDay</span><span class="p">(</span><span class="n">dayAlarm</span><span class="p">);</span>
<span class="n">Alarm</span><span class="w"> </span><span class="n">alarm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">firstPart</span><span class="p">.</span><span class="n">AtNight</span><span class="p">(</span><span class="n">nightAlarm</span><span class="p">);</span>
</pre></div>
</div>
<p>Ora possiamo semplicemente concatenare queste chiamate e ottenere il risultato che volevamo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">  </span><span class="n">DependingOnTimeOfDay</span>
<span class="w">    </span><span class="p">.</span><span class="n">DuringDay</span><span class="p">(</span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">.</span><span class="n">AtNight</span><span class="p">(</span><span class="n">MakesLoudNoise</span><span class="p">())</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">),</span>
</pre></div>
</div>
<p>Il vantaggio di questa soluzione è che non richiede un determinato linguaggio di programmazione per supportare i [<em>named parameter</em>]. Lo svantaggio è che l'ordine delle chiamate è rigorosamente definito. <code class="docutils literal notranslate"><span class="pre">DuringDay</span></code> restituisce un oggetto su cui viene invocato <code class="docutils literal notranslate"><span class="pre">AtNight</span></code>, quindi deve venire per primo.</p>
</section>
<section id="discussion-continued">
<h3>La discussione è continua<a class="headerlink" href="#discussion-continued" title="Link to this heading">¶</a></h3>
<p>Per ora presumo che abbiamo scelto l'approccio 1 perché è più semplice.</p>
<p>Il nostro codice di composizione finora è simile a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">SecureArea</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">OfficeBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="n">DependingOnTimeOfDay</span><span class="p">(</span>
<span class="w">      </span><span class="n">duringDay</span><span class="p">:</span><span class="w"> </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span><span class="w"> </span>
<span class="w">      </span><span class="n">atNight</span><span class="p">:</span><span class="w"> </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">StorageBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="n">Both</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">      </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">GuardsBuilding</span><span class="p">(</span>
<span class="w">    </span><span class="n">Both</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//police number</span>
<span class="w">      </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Ci sono ancora alcuni ritocchi finali che dobbiamo apportare. Prima di tutto, proviamo a estrarre questi numeri da comporre come <code class="docutils literal notranslate"><span class="pre">222-333-444</span></code> in costanti. Quando lo facciamo, quindi, ad esempio, questo codice:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Both</span><span class="p">(</span>
<span class="w">  </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;919&quot;</span><span class="p">),</span><span class="w"> </span><span class="c1">//police number</span>
<span class="w">  </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
</div>
<p>diventa</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Both</span><span class="p">(</span>
<span class="w">  </span><span class="n">Calls</span><span class="p">(</span><span class="n">Police</span><span class="p">),</span>
<span class="w">  </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
</div>
<p>E l'ultima cosa è nascondere la creazione delle seguenti classi: <code class="docutils literal notranslate"><span class="pre">SecureArea</span></code>, <code class="docutils literal notranslate"><span class="pre">OfficeBuilding</span></code>, <code class="docutils literal notranslate"><span class="pre">StorageBuilding</span></code>, <code class="docutils literal notranslate"><span class="pre">GuardsBuilding</span></code> e abbiamo questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">SecureAreaContaining</span><span class="p">(</span>
<span class="w">  </span><span class="n">OfficeBuildingWithAlarmThat</span><span class="p">(</span>
<span class="w">    </span><span class="n">DependingOnTimeOfDay</span><span class="p">(</span>
<span class="w">      </span><span class="n">duringDay</span><span class="p">:</span><span class="w"> </span><span class="n">Calls</span><span class="p">(</span><span class="n">Guards</span><span class="p">),</span>
<span class="w">      </span><span class="n">atNight</span><span class="p">:</span><span class="w"> </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="n">StorageBuildingWithAlarmThat</span><span class="p">(</span>
<span class="w">    </span><span class="n">Both</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="n">Guards</span><span class="p">),</span>
<span class="w">      </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">),</span>
<span class="w">  </span><span class="n">GuardsBuildingWithAlarmThat</span><span class="p">(</span>
<span class="w">    </span><span class="n">Both</span><span class="p">(</span>
<span class="w">      </span><span class="n">Calls</span><span class="p">(</span><span class="n">Police</span><span class="p">),</span>
<span class="w">      </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Ed eccola qui -- la descrizione reale e dichiarativa della nostra applicazione! La composizione si legge meglio di quando abbiamo iniziato, vero?</p>
</section>
</section>
<section id="composition-as-a-language">
<h2>La composizione come linguaggio<a class="headerlink" href="#composition-as-a-language" title="Link to this heading">¶</a></h2>
<p>Scritta in questo modo, la composizione degli oggetti ha un'altra proprietà importante -- è estensibile utilizzando gli stessi termini già usati (ovviamente possiamo anche aggiungerne di nuovi). Ad esempio, utilizzando i metodi che abbiamo inventato per rendere la composizione più leggibile, potremmo scrivere qualcosa del genere:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Both</span><span class="p">(</span>
<span class="w">  </span><span class="n">Calls</span><span class="p">(</span><span class="n">Police</span><span class="p">),</span>
<span class="w">  </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
</div>
<p>ma, usando gli stessi termini, possiamo anche scrivere questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Both</span><span class="p">(</span>
<span class="w">  </span><span class="n">Both</span><span class="p">(</span>
<span class="w">    </span><span class="n">Calls</span><span class="p">(</span><span class="n">Police</span><span class="p">),</span>
<span class="w">    </span><span class="n">Calls</span><span class="p">(</span><span class="n">Security</span><span class="p">)),</span>
<span class="w">  </span><span class="n">Both</span><span class="p">(</span>
<span class="w">    </span><span class="n">Calls</span><span class="p">(</span><span class="n">Boss</span><span class="p">),</span>
<span class="w">    </span><span class="n">MakesLoudNoise</span><span class="p">()))</span>
<span class="p">)</span>
</pre></div>
</div>
<p>per ottenere un comportamento diverso. Notare che abbiamo inventato qualcosa che ha queste proprietà:</p>
<ol class="arabic simple">
<li><p>Definisce una sorta di <em>vocabolario</em> -- nel nostro caso, le seguenti &quot;parole&quot; fanno parte del vocabolario: <code class="docutils literal notranslate"><span class="pre">Both</span></code>, <code class="docutils literal notranslate"><span class="pre">Calls</span></code>, <code class="docutils literal notranslate"><span class="pre">MakesLoudNoise</span></code>, <code class="docutils literal notranslate"><span class="pre">DependingOnTimeOfDay</span></code>, <code class="docutils literal notranslate"><span class="pre">atNight</span></code>, <code class="docutils literal notranslate"><span class="pre">duringDay</span></code>, <code class="docutils literal notranslate"><span class="pre">SecureAreaContaining</span></code>, <code class="docutils literal notranslate"><span class="pre">GuardsBuildingWithAlarmThat</span></code>, <code class="docutils literal notranslate"><span class="pre">OfficeBuildingWithAlarmThat</span></code>.</p></li>
<li><p>Permette di combinare le parole del vocabolario. Queste combinazioni hanno un significato, che si basa esclusivamente sul significato delle parole usate e sul modo in cui sono combinate. Ad esempio: <code class="docutils literal notranslate"><span class="pre">Both(Calls(Police),</span> <span class="pre">Calls(Guards))</span></code> ha il significato di &quot;chiama sia la polizia che le guardie quando attivato&quot; -- quindi, ci permette di combinare le parole in <em>frasi</em>.</p></li>
<li><p>Anche se siamo abbastanza liberali nel definire i comportamenti per gli allarmi, ci sono alcune regole su cosa può essere composto con cosa (ad esempio, non possiamo comporre l'edificio delle guardie con un ufficio, ma ognuno di essi può essere composto solo con gli allarmi). Pertanto, possiamo dire che le <em>frasi</em> che scriviamo devono obbedire a determinate regole che assomigliano molto a <em>una grammatica</em>.</p></li>
<li><p>Il vocabolario è <em>vincolato al dominio</em> degli allarmi. D'altra parte, <em>è più potente ed espressivo</em> come descrizione del dominio rispetto a una combinazione di istruzioni <code class="docutils literal notranslate"><span class="pre">if</span></code>, cicli <code class="docutils literal notranslate"><span class="pre">for</span></code>, assegnazioni di variabili e altri elementi di un linguaggio generico. È sintonizzato sulla descrizione delle regole di un dominio su un <em>livello di astrazione più elevato</em>.</p></li>
<li><p>Le frasi scritte definiscono il comportamento dell'applicazione -- quindi scrivendo frasi come questa continuiamo a scrivere software! Pertanto, ciò che facciamo combinando <em>parole</em> in <em>frasi</em> vincolate da una <em>grammatica</em> è ancora <em>programmazione</em>!</p></li>
</ol>
<p>Tutti questi punti suggeriscono che abbiamo creato un <em>Domain-Specific Language</em><a class="footnote-reference brackets" href="#fowlerdsl" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, che, tra l'altro, è un <em>linguaggio di livello superiore</em>, nel senso che descriviamo il nostro software a un livello di astrazione più elevato.</p>
</section>
<section id="the-significance-of-a-higher-level-language">
<h2>Il significato di un linguaggio di livello superiore<a class="headerlink" href="#the-significance-of-a-higher-level-language" title="Link to this heading">¶</a></h2>
<p>Quindi... perché abbiamo bisogno di un linguaggio di livello superiore per descrivere il comportamento della nostra applicazione? Dopotutto, espressioni, affermazioni, cicli e condizioni (e oggetti e polimorfismo) sono il nostro pane quotidiano. Perché inventare qualcosa che ci allontani da questo tipo di programmazione per indirizzarci verso qualcosa di &quot;domain-specific&quot;?</p>
<p>La mia risposta principale è: affrontare la complessità in modo più efficace.</p>
<p>Cos'è la complessità? Per il nostro scopo, possiamo definirla approssimativamente come il numero di decisioni diverse che la nostra applicazione deve prendere. Man mano che aggiungiamo nuove funzionalità, correggiamo errori o implementiamo requisiti non rispettati, la complessità del nostro software aumenta. Cosa possiamo fare quando diventa più grande di quanto possiamo gestire? Abbiamo le seguenti scelte:</p>
<ol class="arabic simple">
<li><p>Rimuovere alcune decisioni -- ovvero rimuovere funzionalità dalla nostra applicazione. È molto interessante quando <em>possiamo</em> farlo, ma ci sono momenti in cui ciò potrebbe essere inaccettabile dal punto di vista aziendale.</p></li>
<li><p>Ottimizzare le decisioni ridondanti -- si tratta di far sì che ogni decisione venga presa una sola volta nella base di codice. Ho già mostrato alcuni esempi di come il polimorfismo possa aiutare in questo.</p></li>
<li><p>Utilizzare componenti di terze parti o una libreria per farci gestire alcune delle decisioni -- mentre questo è abbastanza facile per il codice e le utilità dell'&quot;infrastruttura&quot;, è molto, molto difficile (impossibile?) trovare una libreria che ci descriva le &quot;regole del nostro dominio&quot;. Quindi, se queste regole sono la vera complessità (e spesso lo sono), rimaniamo ancora soli col nostro problema.</p></li>
<li><p>Nascondere le decisioni programmando a un livello di astrazione più elevato -- questo è ciò che abbiamo fatto finora in questo capitolo. Il vantaggio è che ci consente di ridurre la complessità del nostro dominio, creando blocchi più grandi da cui è possibile creare una descrizione del comportamento.</p></li>
</ol>
<p>Quindi, solo l’ultimo dei punti precedenti aiuta davvero a ridurre la complessità del dominio. È qui che rientra l’idea di linguaggi specifici del dominio (domain-specific languages). Se creiamo attentamente la composizione del nostro oggetto in un insieme di linguaggi specifici del dominio (uno è spesso troppo poco per tutto tranne che nei casi più semplici), un giorno potremmo scoprire che stiamo aggiungendo nuove funzionalità scrivendo nuove frasi in questi linguaggi in modo dichiarativo piuttosto che aggiungere un nuovo codice imperativo. Pertanto, se possediamo un buon linguaggio e una solida conoscenza del suo vocabolario e della grammatica, possiamo programmare a un livello di astrazione più elevato, più espressivo e meno complesso.</p>
<p>Questo è molto difficile da realizzare poiché richiede, tra le altre cose:</p>
<ol class="arabic simple">
<li><p>Una ferrea disciplina in un team di sviluppo.</p></li>
<li><p>Un senso dell'orientamento su come strutturare la composizione e dove condurre i progetti dei linguaggi mentre si evolvono.</p></li>
<li><p>Un refactoring spietato.</p></li>
<li><p>Una conoscenza minima della progettazione del linguaggio ed esperienza nel farlo.</p></li>
<li><p>Conoscenza di alcune tecniche (come quelle usate nel nostro esempio) che fanno sembrare i costrutti scritti in un linguaggio generico come un altro linguaggio.</p></li>
</ol>
<p>Naturalmente, non tutte le parti della composizione costituiscono un buon materiale per essere strutturate come un linguaggio. Nonostante queste difficoltà, penso che ne valga la pena. Programmare a un livello di astrazione più elevato con codice dichiarativo anziché imperativo è il luogo in cui ripongo la mia speranza di scrivere sistemi gestibili e comprensibili.</p>
</section>
<section id="some-advice">
<h2>Qualche consiglio<a class="headerlink" href="#some-advice" title="Link to this heading">¶</a></h2>
<p>Allora, si è ansiosi di provare questo approccio? Permettimi alcuni consigli:</p>
<section id="evolve-the-language-as-you-evolve-code">
<h3>Far evolvere il linguaggio man mano che evolve il codice<a class="headerlink" href="#evolve-the-language-as-you-evolve-code" title="Link to this heading">¶</a></h3>
<p>All'inizio di questo capitolo, abbiamo raggiunto il nostro linguaggio di livello superiore effettuando il refactoring della composizione di oggetti già esistente. Ciò non significa affatto che nei progetti reali dobbiamo aspettare che appaia molto codice di composizione e poi provare a racchiuderlo tutto. In effetti ho fatto proprio questo nell'esempio dell'allarme, ma questo era solo un esempio e il suo scopo era principalmente didattico.</p>
<p>In realtà, è meglio che il linguaggio evolva insieme alla composizione che descrive. Uno dei motivi è che ci sono molti feedback sulla componibilità del progetto ottenuti provando a metterci sopra un linguaggio. Come ho detto nel capitolo sulla responsabilità singola, se gli oggetti non sono comodamente componibili, probabilmente c'è qualcosa che non va nella distribuzione delle responsabilità tra di loro (per un confronto delle responsabilità erroneamente assegnate, immaginiamo un linguaggio generico che non abbia costrutti <code class="docutils literal notranslate"><span class="pre">if</span></code> e <code class="docutils literal notranslate"><span class="pre">for</span></code> separati ma solo una combinazione di essi chiamata <code class="docutils literal notranslate"><span class="pre">forif</span></code> :-)). Non perdersi questo feedback!</p>
<p>La seconda ragione è che anche se si può tranquillamente rifattorizzare tutto il codice perché si ha una specifica eseguibile che ci protegge dal commettere errori, sono semplicemente troppe decisioni da gestire contemporaneamente (in più ci vuole molto tempo e i colleghi continuano ad aggiungere nuovo codice, vero?). Un buon linguaggio cresce e matura in modo organico anziché essere creato in uno sforzo enorme. Alcune decisioni richiedono tempo e molta riflessione.</p>
</section>
<section id="composition-is-not-a-single-dsl-but-a-series-of-mini-dsls">
<h3>La composizione non è un singolo DSL, ma una serie di mini DSL<a class="footnote-reference brackets" href="#dddboundedcontext" id="id1" role="doc-noteref"><span class="fn-bracket">[</span><span class="fn-bracket">]</span></a><a class="headerlink" href="#composition-is-not-a-single-dsl-but-a-series-of-mini-dsls" title="Link to this heading">¶</a></h3>
<p>L'ho già brevemente notato. Anche se può essere forte la tentazione di inventare un unico DSL per descrivere l'intera applicazione, in pratica è difficilmente possibile, perché le nostre applicazioni hanno sottodomini diversi che spesso utilizzano insiemi di termini diversi. Piuttosto, conviene cercare tali sottodomini e creare per essi linguaggi più piccoli. L'esempio dell'allarme mostrato sopra sarebbe probabilmente solo una piccola parte della composizione reale. Non tutte le parti si presterebbero a modellarsi in questo modo, almeno non immediatamente. Ciò che inizia come una singola classe potrebbe, ad un certo punto, diventare un sottodominio con un proprio vocabolario. Dobbiamo prestare attenzione. Quindi, vogliamo ancora applicare alcune delle tecniche DSL anche a quelle parti della composizione che non possono essere facilmente trasformate in DSL e cercare un'occasione in cui possiamo farlo.</p>
<p>Come <a class="reference external" href="http://www.natpryce.com/articles/000783.html">dice Nat Pryce</a>, si tratta di:</p>
<blockquote>
<div><p>(...) esprimere chiaramente le dipendenze tra gli oggetti nel codice che li compone, in modo che la struttura del sistema possa essere facilmente rifattorizzata, ed eseguire aggressivamente il refactoring di quel codice per rimuovere la duplicazione ed esprimere l'intento, e quindi aumentare il livello di astrazione in cui possiamo programmare (...). L'obiettivo finale è avere bisogno di sempre meno codice per scrivere sempre più funzionalità man mano che il sistema cresce.</p>
</div></blockquote>
<p>Ad esempio, un mini-DSL per impostare la gestione degli aggiornamenti della configurazione di un'applicazione potrebbe assomigliare a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">return</span><span class="w"> </span><span class="nf">ConfigurationUpdates</span><span class="p">(</span>
<span class="w">  </span><span class="n">Of</span><span class="p">(</span><span class="n">log</span><span class="p">),</span>
<span class="w">  </span><span class="n">Of</span><span class="p">(</span><span class="n">localSettings</span><span class="p">),</span>
<span class="w">  </span><span class="n">OfResource</span><span class="p">(</span><span class="n">Departments</span><span class="p">()),</span>
<span class="w">  </span><span class="n">OfResource</span><span class="p">(</span><span class="n">Projects</span><span class="p">()));</span>
</pre></div>
</div>
<p>Leggere questo codice non dovrebbe essere difficile, soprattutto quando sappiamo cosa significa ogni termine nella frase. Questo codice restituisce un oggetto che gestisce gli aggiornamenti della configurazione di quattro cose: il log dell'applicazione, le impostazioni locali e due risorse (in questo sottodominio, risorse significa cose che possono essere aggiunte, cancellate e modificate). Queste due risorse sono: dipartimenti e progetti (ad esempio possiamo aggiungere un nuovo progetto o eliminarne uno esistente).</p>
<p>Si noti che i costrutti di questo linguaggio hanno senso solo in un contesto di creazione di gestori di aggiornamento della configurazione. Pertanto, dovrebbero essere limitati a questa parte della composizione. Altre parti che non hanno nulla a che fare con gli aggiornamenti della configurazione non dovrebbero aver bisogno di conoscere questi costrutti.</p>
</section>
<section id="do-not-use-an-extensive-amount-of-dsl-tricks">
<h3>Non utilizzare una quantità eccessiva di trucchi DSL<a class="headerlink" href="#do-not-use-an-extensive-amount-of-dsl-tricks" title="Link to this heading">¶</a></h3>
<p>Nella creazione di DSL interni, si possono usare molti trucchi, alcuni dei quali sono molto &quot;hacky&quot; e distorcono il linguaggio generale in molti modi per ottenere una sintassi &quot;fluente&quot;. C'è da ricordare che il codice di composizione deve essere mantenuto dal team. A meno che ogni membro del team non sia un esperto nella creazione di tali DSL, non esporre trucchi troppo sofisticati. Scegliere alcuni di quelli collaudati che sono semplici da usare e funzionano, come quelli che ho usato nell'esempio dell'allarme.</p>
<p>Martin Fowler<a class="footnote-reference brackets" href="#fowlerdsl" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> descrive molti trucchi per creare tali DSL e allo stesso tempo mette in guardia dall'usarne troppi nello stesso linguaggio.</p>
</section>
<section id="factory-method-nesting-is-your-best-friend">
<h3>Il [<em>Factory method nesting</em>] è il migliore<a class="headerlink" href="#factory-method-nesting-is-your-best-friend" title="Link to this heading">¶</a></h3>
<p>Una delle tecniche DSL, quella che ho utilizzato di più, è il [<em>factory method nesting</em>]. Fondamentalmente, significa avvolgere l'invocazione di un costruttore (o costruttori -- nessuno ha detto che ogni metodo factory debba racchiudere esattamente un <code class="docutils literal notranslate"><span class="pre">new</span></code>) con un metodo che abbia un nome più adatto al contesto in cui viene utilizzato (e che nasconde l'oscurità della parola chiave <code class="docutils literal notranslate"><span class="pre">new</span></code>). Questa tecnica è quello che rende questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">new</span><span class="w"> </span><span class="nf">HybridAlarm</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="nf">LoudAlarm</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
</div>
<p>e lo fa assomigliare a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Both</span><span class="p">(</span>
<span class="w">  </span><span class="n">Calls</span><span class="p">(</span><span class="s">&quot;222-333-444&quot;</span><span class="p">),</span>
<span class="w">  </span><span class="n">MakesLoudNoise</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Come si ricorderà, in questo caso, ogni metodo racchiude un costruttore, ad es. <code class="docutils literal notranslate"><span class="pre">Calls()</span></code> è definito come:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="nf">Calls</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Questa tecnica è ottima per descrivere qualsiasi tipo di struttura ad albero e simile a un grafo poiché ciascun metodo fornisce uno scopo naturale per i suoi argomenti:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Method1</span><span class="p">(</span><span class="w"> </span><span class="c1">//beginning of scope</span>
<span class="w">  </span><span class="n">NestedMethod1</span><span class="p">(),</span>
<span class="w">  </span><span class="n">NestedMethod2</span><span class="p">()</span>
<span class="p">);</span><span class="w">       </span><span class="c1">//end of scope</span>
</pre></div>
</div>
<p>Pertanto, è un adattamento naturale per la composizione di oggetti, che <em>è</em> una struttura a grafo.</p>
<p>Questo approccio sembra ottimo sulla carta, ma non è che tutto si adatti sempre. Ci sono due problemi con i metodi factory da affrontare.</p>
<section id="where-to-put-these-methods">
<h4>Dove mettere questi metodi?<a class="headerlink" href="#where-to-put-these-methods" title="Link to this heading">¶</a></h4>
<p>Nel caso normale, vogliamo essere in grado di invocare questi metodi senza alcun qualificatore prima di essi, cioè vogliamo chiamare <code class="docutils literal notranslate"><span class="pre">MakesLoudNoise()</span></code> invece di <code class="docutils literal notranslate"><span class="pre">alarmsFactory.MakesLoudNoise()</span></code> o di <code class="docutils literal notranslate"><span class="pre">this.MakesLoudNoise()</span></code> o altro.</p>
<p>Se sì, dove mettiamo tali metodi?</p>
<p>Sono disponibili due opzioni<a class="footnote-reference brackets" href="#staticimports" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>:</p>
<ol class="arabic simple">
<li><p>Inserire i metodi nella classe che esegue la composizione.</p></li>
<li><p>Mettere i metodi in una superclasse.</p></li>
</ol>
<p>Oltre a ciò, possiamo scegliere tra:</p>
<ol class="arabic simple">
<li><p>Rendere statici i metodi factory.</p></li>
<li><p>Rendere i metodi factory non statici.</p></li>
</ol>
<p>Innanzitutto, consideriamo il dilemma tra l'inserimento di una classe di composizione e l'avere una superclasse da cui ereditare. Questa scelta è determinata principalmente dalle esigenze del riutilizzo. I metodi che usiamo soltanto in una composizione e che non vogliamo riutilizzare è meglio che siano metodi privati nella classe di composizione. D'altra parte, i metodi che vogliamo riutilizzare (ad esempio in altre applicazioni o servizi appartenenti allo stesso sistema), è meglio inserirli in una superclasse da cui possiamo ereditare. Inoltre, è possibile una combinazione dei due approcci, in cui la superclasse contiene un metodo più generale mentre la classe di composizione lo racchiude con un altro metodo che adatta la creazione al contesto corrente. A proposito, ricordare che in molti linguaggi possiamo ereditare solo da una singola classe -- quindi mettere i metodi per ogni linguaggio in una superclasse separata ci costringe a distribuire il codice di composizione su più classi, ciascuna eredita il proprio insieme di metodi e restituisce uno o più oggetti. Questo non è affatto male -- al contrario, è qualcosa che vorremmo avere perché ci permette di far evolvere una lingua e le frasi scritte in tale lingua in un contesto isolato.</p>
<p>La seconda scelta tra statico e non statico è quella di avere accesso ai campi dell'istanza -- i metodi dell'istanza hanno questo accesso, mentre i metodi statici no. Pertanto, se quanto segue è un metodo di istanza di una classe chiamata <code class="docutils literal notranslate"><span class="pre">AlarmComposition</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">AlarmComposition</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//...</span>
<span class="w">  </span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="nf">Calls</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">number</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span><span class="n">number</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>e si deve passare una dipendenza aggiuntiva a <code class="docutils literal notranslate"><span class="pre">SilentAlarm</span></code> che non si vuole mostrare nel codice di composizione principale, si è liberi di cambiare il metodo <code class="docutils literal notranslate"><span class="pre">Calls</span></code> in:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">Alarm</span><span class="w"> </span><span class="nf">Calls</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">SilentAlarm</span><span class="p">(</span>
<span class="w">    </span><span class="n">number</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">_hiddenDependency</span><span class="p">)</span><span class="w"> </span><span class="c1">//field</span>
<span class="p">}</span>
</pre></div>
</div>
<p>e questa nuova dipendenza può essere passata a <code class="docutils literal notranslate"><span class="pre">AlarmComposition</span></code> tramite il suo costruttore:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="nf">AlarmComposition</span><span class="p">(</span>
<span class="w">  </span><span class="n">HiddenDependency</span><span class="w"> </span><span class="n">hiddenDependency</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">_hiddenDependency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hiddenDependency</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span>
</pre></div>
</div>
<p>In questo modo posso nasconderlo dal codice di composizione principale. Questa è la libertà che non ho con i metodi statici.</p>
</section>
<section id="use-implicit-collections-instead-of-explicit-ones">
<h4>Utilizzare collection implicite anziché esplicite<a class="headerlink" href="#use-implicit-collections-instead-of-explicit-ones" title="Link to this heading">¶</a></h4>
<p>a maggior parte dei linguaggi object-oriented supporta il passaggio di elenchi variabili di argomenti (ad esempio in C# ciò si ottiene con la parola chiave <code class="docutils literal notranslate"><span class="pre">params</span></code>, mentre Java ha l'operatore <code class="docutils literal notranslate"><span class="pre">...</span></code>). Questo è utile nella composizione, perché spesso vogliamo essere in grado di passare un numero arbitrario di oggetti in alcuni posti. Ancora una volta, tornando a questa composizione:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">return</span><span class="w"> </span><span class="nf">ConfigurationUpdates</span><span class="p">(</span>
<span class="w">  </span><span class="n">Of</span><span class="p">(</span><span class="n">log</span><span class="p">),</span>
<span class="w">  </span><span class="n">Of</span><span class="p">(</span><span class="n">localSettings</span><span class="p">),</span>
<span class="w">  </span><span class="n">OfResource</span><span class="p">(</span><span class="n">Departments</span><span class="p">()),</span>
<span class="w">  </span><span class="n">OfResource</span><span class="p">(</span><span class="n">Projects</span><span class="p">()));</span>
</pre></div>
</div>
<p>il metodo <code class="docutils literal notranslate"><span class="pre">ConfigurationUpdates()</span></code> tilizza un elenco di argomenti variabili:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">ConfigurationUpdates</span><span class="w"> </span><span class="nf">ConfigurationUpdates</span><span class="p">(</span>
<span class="w">  </span><span class="k">params</span><span class="w"> </span><span class="n">ConfigurationUpdate</span><span class="p">[]</span><span class="w"> </span><span class="n">updates</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">MyAppConfigurationUpdates</span><span class="p">(</span><span class="n">updates</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notare che potremmo, ovviamente, passare l'array di istanze <code class="docutils literal notranslate"><span class="pre">ConfigurationUpdate</span></code> utilizzando la definizione esplicita: <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">ConfigurationUpdate[]</span> <span class="pre">{...}</span></code>, ma ciò ostacolerebbe notevolmente la leggibilità e il flusso di questa composizione. Guardate voi stessi:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">return</span><span class="w"> </span><span class="nf">ConfigurationUpdates</span><span class="p">(</span>
<span class="w">  </span><span class="k">new</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//explicit definition brings noise</span>
<span class="w">    </span><span class="n">Of</span><span class="p">(</span><span class="n">log</span><span class="p">),</span>
<span class="w">    </span><span class="n">Of</span><span class="p">(</span><span class="n">localSettings</span><span class="p">),</span>
<span class="w">    </span><span class="n">OfResource</span><span class="p">(</span><span class="n">Departments</span><span class="p">()),</span>
<span class="w">    </span><span class="n">OfResource</span><span class="p">(</span><span class="n">Projects</span><span class="p">())</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Non tanto bello, eh? Questo è il motivo per cui ci piace la possibilità di passare elenchi di argomenti variabili poiché migliora la leggibilità.</p>
</section>
<section id="a-single-method-can-create-more-than-one-object">
<h4>Un singolo metodo può creare più di un oggetto<a class="headerlink" href="#a-single-method-can-create-more-than-one-object" title="Link to this heading">¶</a></h4>
<p>Nessuno ha detto che ogni metodo factory debba creare uno e un solo oggetto. Ad esempio, si dia un'altra occhiata a questo metodo per creare aggiornamenti della configurazione:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">ConfigurationUpdates</span><span class="w"> </span><span class="nf">ConfigurationUpdates</span><span class="p">(</span>
<span class="w">  </span><span class="k">params</span><span class="w"> </span><span class="n">ConfigurationUpdate</span><span class="p">[]</span><span class="w"> </span><span class="n">updates</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">MyAppConfigurationUpdates</span><span class="p">(</span><span class="n">updates</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ora, supponiamo di dover tracciare ogni invocazione sull'istanza della classe <code class="docutils literal notranslate"><span class="pre">ConfigurationUpdates</span></code> e di voler ottenere questo risultato racchiudendo l'istanza <code class="docutils literal notranslate"><span class="pre">MyAppConfigurationUpdates</span></code> con un proxy di tracing (un oggetto che passa le chiamate a un oggetto reale che racchiude, ma scrive alcuni messaggi di trace prima e dopo). A questo scopo possiamo riutilizzare il metodo che già abbiamo, semplicemente aggiungendovi la creazione di oggetti aggiuntivi:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">ConfigurationUpdates</span><span class="w"> </span><span class="nf">ConfigurationUpdates</span><span class="p">(</span>
<span class="w">  </span><span class="k">params</span><span class="w"> </span><span class="n">ConfigurationUpdate</span><span class="p">[]</span><span class="w"> </span><span class="n">updates</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//now two objects created instead of one:</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">TracedConfigurationUpdates</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">MyAppConfigurationUpdates</span><span class="p">(</span><span class="n">updates</span><span class="p">)</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notare che <code class="docutils literal notranslate"><span class="pre">TracedConfigurationUpdates</span></code> non è importante dal punto di vista della composizione -- si tratta di puro codice infrastrutturale, non di una nuova regola di dominio. Per questo motivo, potrebbe essere una buona idea nasconderlo all'interno del metodo factory.</p>
</section>
</section>
</section>
<section id="summary">
<h2>Riepilogo<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>In questo capitolo ho cercato di trasmettere una visione della composizione di oggetti come un linguaggio, con un proprio vocabolario, una propria grammatica, con parole chiave e argomenti. Possiamo comporre le parole del vocabolario in frasi diverse per creare nuovi comportamenti a un livello di astrazione più elevato.</p>
<p>Quest'area della progettazione orientata agli oggetti è qualcosa con cui sto ancora sperimentando, cercando di mettermi al passo con ciò che condividono altri autori su questo argomento. Pertanto, non lo parlo così fluentemente come in altri argomenti trattati in questo libro. Aspettatevi che questo capitolo cresca (magari in più capitoli) o che venga chiarito in futuro. Per ora, se si ritiene di aver bisogno di maggiori informazioni, dare un'occhiata al video di Steve Freeman e Nat Pryce intitolato <a class="reference external" href="https://vimeo.com/105785565">&quot;Building on SOLID foundations&quot;</a>.</p>
</section>
</section>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fowlerdsl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id2">2</a>,<a role="doc-backlink" href="#id4">3</a>)</span>
<p>M. Fowler, Domain-Specific Languages, Addison-Wesley 2010.</p>
</aside>
<aside class="footnote brackets" id="dddboundedcontext" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>Un lettore ha notato che le idee in questa sezione sono notevolmente simili alla nozione di &quot;<em>Bounded Contexts</em>&quot; in un libro: E. Evans, Domain-Driven Design: Tackling Complexity in the Heart of Software, Prentice Hall 2003.</p>
</aside>
<aside class="footnote brackets" id="staticimports" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">3</a><span class="fn-bracket">]</span></span>
<p>In alcuni linguaggi esiste una terza via: Java ci consente di utilizzare importazioni statiche che fanno parte anche di C# a partire dalla versione 6.0. Il C++ ha sempre supportato le funzioni, quindi non è un argomento lì.</p>
</aside>
</aside>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">TDD</a></h1>








<h3>Navigazione</h3>
<p class="caption" role="heading"><span class="caption-text">Contenuti:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Cover.html">Titolo</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Premessa</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html">Premessa</a></li>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html#dedications">Dediche</a></li>
<li class="toctree-l1"><a class="reference internal" href="015_Thanks.html">Grazie!</a></li>
<li class="toctree-l1"><a class="reference internal" href="017_CodeExamples.html">I codici di esempio</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 1:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="020_Part1Marker.html">Parte 1: Solo le nozioni di base</a></li>
<li class="toctree-l1"><a class="reference internal" href="030_Motivations.html">Motivazione: il primo passo per imparare il TDD</a></li>
<li class="toctree-l1"><a class="reference internal" href="040_Three_Essential_Tools.html"><span class="xref myst">Gli strumenti essenziali</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="050_Its_Not_a_Test.html">Non è (solo) un test</a></li>
<li class="toctree-l1"><a class="reference internal" href="060_Statement_First_Programming.html">La programmazione Statement-first</a></li>
<li class="toctree-l1"><a class="reference internal" href="070_Practicing_What_We_Already_Learned.html">Mettere in pratica ciò che abbiamo già imparato</a></li>
<li class="toctree-l1"><a class="reference internal" href="080_Sorting_out_the_bits.html">Facciamo un po' d'ordine</a></li>
<li class="toctree-l1"><a class="reference internal" href="090_How_to_start.html">Come iniziare?</a></li>
<li class="toctree-l1"><a class="reference internal" href="100_Analysis_In_TDD.html">In che modo il TDD riguarda l'analisi e cosa significa &quot;GIVEN-WHEN-THEN&quot;?</a></li>
<li class="toctree-l1"><a class="reference internal" href="110_What_is_the_scope_of_a_Statement_in_TDD.html">Qual è lo scopo di uno Statement a livello di unità in TDD?</a></li>
<li class="toctree-l1"><a class="reference internal" href="120_Constrained_Non_Determinism.html">Sviluppare uno stile TDD e Non-Determinismo Vincolato</a></li>
<li class="toctree-l1"><a class="reference internal" href="130_Boundaries.html">Specificare i confini e le condizioni funzionali</a></li>
<li class="toctree-l1"><a class="reference internal" href="140_Triangulation.html">Guidare l'implementazione dalle Specifiche</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 2:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="150_Part2Marker.html">Parte 2: Il Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="160_Composable_Design.html">La Componibilità degli Oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="170_TellDoNotAsk.html"><span class="xref myst">Raccontare, non chiedere</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="180_Web_of_objects_explained.html">La necessità degli oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="190_Why_do_we_need_composability.html">Perché abbiamo bisogno della componibilità?</a></li>
<li class="toctree-l1"><a class="reference internal" href="200_What_does_it_mean_to_compose_objects.html">Reti, messaggi e protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="210_How_are_objects_composed.html">Comporre una rete di oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="211_When_are_objects_composed.html">Quando vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="212_How_are_the_connections_made.html">Come fa un mittente ad ottenere un riferimento a un destinatario (cioè come vengono stabilite le connessioni)?</a></li>
<li class="toctree-l1"><a class="reference internal" href="213_Where_are_objects_composed.html">Dove vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="220_Designing_for_composabiity_interfaces.html">Interfacce</a></li>
<li class="toctree-l1"><a class="reference internal" href="230_Designing_for_composabiity_protocols.html">Protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="235_Classes.html">Le Classi</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Composizione di Oggetti come Linguaggio</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#more-readable-composition-root">Una <em>composition root</em> più leggibile</a></li>
<li class="toctree-l2"><a class="reference internal" href="#refactoring-for-readability">Il refactoring per la leggibilità</a></li>
<li class="toctree-l2"><a class="reference internal" href="#composition-as-a-language">La composizione come linguaggio</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-significance-of-a-higher-level-language">Il significato di un linguaggio di livello superiore</a></li>
<li class="toctree-l2"><a class="reference internal" href="#some-advice">Qualche consiglio</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Riepilogo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="250_Value_Objects.html">Gli <em>Oggetti Valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="255_Value_Objects_properties.html">Anatomia del <em>oggetto valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="257_Value%20objects_general_topics.html">Aspetti del design degli <em>oggetti valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html">Oggetti di Trasferimento Dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-behavior">Disaccoppiamento mediante l'astrazione del comportamento</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-data">Disaccoppiamento mediante l'astrazione dei dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#use-both">Usare entrambi</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#dto-as-data-centric-decoupling-mechanism">DTO come meccanismo di disaccoppiamento incentrato sui dati</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 3:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="260_Part3Marker.html">Parte 3: TDD nel Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="270_Mock_Objects.html">Oggetti Mock come strumento di test</a></li>
<li class="toctree-l1"><a class="reference internal" href="280_Start_with_a_failing_test_mocks.html">Test-first  [<em>Testare prima</em>] utilizzando oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="290_NeedDrivenDevelopment.html">Il test-driving ai confini di input</a></li>
<li class="toctree-l1"><a class="reference internal" href="300_NeedDrivenRetrospective1.html">Il test-driving ai confini di input -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="310_Test_Driving_Factories.html">Creazione di oggetti &quot;test-driving&quot;</a></li>
<li class="toctree-l1"><a class="reference internal" href="320_Test_Driving_Factories_retrospective.html">Creazione di oggetti &quot;test-driving&quot; -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="330_Test-Driving_Command.html">Logica dell'applicazione test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="340_Test-Driving_Value_object.html"><em>Oggetti valore</em> nel test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="350_Web_of_objects_boundaries.html">Raggiungere la rete dei confini degli oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="360_Internals.html">Cosa c'è dentro l'oggetto?</a></li>
<li class="toctree-l1"><a class="reference internal" href="370_Design_smells.html">Odori del design visibile nella Specifica</a></li>
<li class="toctree-l1"><a class="reference internal" href="End.html">QUESTO È TUTTO QUELLO CHE HO PER ORA. QUELLO CHE SEGUE È MATERIALE GREZZO, NON ORDINATO, NON ANCORA PRONTO PER ESSERE CONSUMATO COME PARTE DI QUESTO TUTORIAL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 5:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html">Mock di oggetti come strumento di progettazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#guidance-of-test-smells">Guidaa ai test smells [<em>puzzolenti</em>]</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#revisiting-topics-from-chapter-1">Rivedere gli argomenti del capitolo 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#maintainable-mock-based-statements">Statement manutenibili basate su mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#refactoring-mock-code">Refactoring del codice mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-4-application-architecture">Parte 4: Architettura dell'applicazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#on-stable-architectural-boundaries">Sui confini stabili/architetturali</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#ports-and-adapters">[Port] e adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-application">Cosa entra in applicazione?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-ports">Cosa va nei [port]?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-5-tdd-on-application-architecture-level">Parte 5: TDD a livello di architettura applicativa</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#designing-automation-layer">Progettazione del layer di automazione</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 9:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="990_Further_reading.html"><span class="xref myst">Ulteriori Letture</span></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="235_Classes.html" title="capitolo precedente">Le Classi</a></li>
      <li>Next: <a href="250_Value_Objects.html" title="capitolo successivo">Gli <em>Oggetti Valore</em></a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Ricerca veloce</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Vai" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Grzegorz GaÅ‚Ä™zowski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/manuscript/240_Refactoring_Object_Composition.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>