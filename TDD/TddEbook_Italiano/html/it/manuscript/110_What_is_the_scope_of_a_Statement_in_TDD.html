<!DOCTYPE html>

<html lang="it" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Qual è lo scopo di uno Statement a livello di unità in TDD? &#8212; Documentazione TDD 2025 </title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=ad698211"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=45930005"></script>
    <link rel="index" title="Indice" href="../genindex.html" />
    <link rel="search" title="Cerca" href="../search.html" />
    <link rel="next" title="Sviluppare uno stile TDD e Non-Determinismo Vincolato" href="120_Constrained_Non_Determinism.html" />
    <link rel="prev" title="In che modo il TDD riguarda l&#39;analisi e cosa significa &#34;GIVEN-WHEN-THEN&#34;?" href="100_Analysis_In_TDD.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="what-is-the-scope-of-a-unit-level-statement-in-tdd">
<h1>Qual è lo scopo di uno Statement a livello di unità in TDD?<a class="headerlink" href="#what-is-the-scope-of-a-unit-level-statement-in-tdd" title="Link to this heading">¶</a></h1>
<p>Nei capitoli precedenti ho descritto come i test formino una sorta di Specifica eseguibile composta da molti Statement. Se è così, allora è necessario sollevare alcune domande fondamentali riguardanti questi Statement, ad esempio:</p>
<ol class="arabic simple">
<li><p>Cosa c'è in un singolo Statement?</p></li>
<li><p>Come faccio a sapere che devo scrivere un altro Statement invece di espandere quello esistente?</p></li>
<li><p>Quando vedo uno Statement, come faccio a sapere se è troppo grande, troppo piccolo o appena sufficiente?</p></li>
</ol>
<p>Questo può essere riassunto in una domanda più generale: quale dovrebbe essere lo &quot;scope&quot; di un singolo Statement?</p>
<section id="scope-and-level">
<h2>Scope e livello<a class="headerlink" href="#scope-and-level" title="Link to this heading">¶</a></h2>
<p>Il software che scriviamo può essere visualizzato in termini di struttura e funzionalità. La funzionalità riguarda le caratteristiche -- cose che un software fa e non fa, date determinate circostanze. La struttura è il modo in cui questa funzionalità è organizzata e divisa tra molti sotto-elementi, ad es. sottosistemi, servizi, componenti, classi, metodi, ecc.</p>
<p>Un elemento strutturale può facilmente gestire diverse funzionalità (da solo o in collaborazione con altri elementi). Ad esempio, molte liste implementano il recupero degli elementi aggiunti nonché qualche tipo di ricerca o ordinamento. D'altra parte, una singola funzionalità può facilmente estendersi a diversi elementi strutturali (ad esempio, il pagamento di un prodotto in un negozio online probabilmente si estenderà ad almeno diverse classi e probabilmente toccherà un database).</p>
<p>Pertanto, quando decidiamo cosa dovrebbe contenere un singolo Statement, dobbiamo considerare sia la struttura che la funzionalità e prendere le seguenti decisioni:</p>
<ul class="simple">
<li><p>struttura -- specifichiamo cosa dovrebbe fare una classe, o cosa dovrebbe fare l'intero componente, o forse uno Statement dovrebbe riguardare l'intero sistema? Mi riferirò a tale decisione strutturale come &quot;livello&quot;.</p></li>
<li><p>funzionalità -- un singolo Statement dovrebbe specificare tutto ciò che fa l'elemento strutturale, o forse solo una parte di esso? Se solo una parte, quale parte e quanto dovrebbe essere grande? Mi riferirò a tale decisione funzionale come &quot;<em>scope</em> funzionale&quot;.</p></li>
</ul>
<p>Le nostre domande dall’inizio del capitolo possono essere riformulate come:</p>
<ol class="arabic simple">
<li><p>A quale livello specifichiamo il nostro software?</p></li>
<li><p>Quale dovrebbe essere lo scope funzionale di un singolo Statement?</p></li>
</ol>
</section>
<section id="on-what-level-do-we-specify-our-software">
<h2>A quale livello specifichiamo il nostro software?<a class="headerlink" href="#on-what-level-do-we-specify-our-software" title="Link to this heading">¶</a></h2>
<p>La risposta alla prima domanda è relativamente semplice -- specifichiamo su più livelli. Quanti livelli ci sono e quali ci interessano dipende molto dal tipo specifico di applicazione che scriviamo e dal paradigma di programmazione (ad esempio nella programmazione funzionale pura, non abbiamo classi).</p>
<p>In questo capitolo (e in quello successivo), mi concentrerò principalmente sul livello di classe (lo chiamerò livello di unità, poiché una classe è un'unità di comportamento), ovvero ogni Statement è scritto rispetto a un'API pubblica di una specifica classe<a class="footnote-reference brackets" href="#unclebobdisagrees" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>Ciò significa che possiamo utilizzare solo una singola classe nel nostro Statement eseguibile? Diamo un'occhiata ad un esempio di uno Statement ben scritto e proviamo a rispondere a questa domanda:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span>
<span class="n">ShouldThrowValidationExceptionWithFatalErrorLevelWhenValidatedStringIsEmpty</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">validation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Validation</span><span class="p">();</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">exceptionThrown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="o">&lt;</span><span class="n">CustomException</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">validation</span><span class="p">.</span><span class="n">ApplyTo</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">)</span>
<span class="w">  </span><span class="p">);</span>

<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">True</span><span class="p">(</span><span class="n">exceptionThrown</span><span class="p">.</span><span class="n">IsFatalError</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ok, allora vediamo... quante classi reali partecipano a questo Statement? Tre: una stringa, un'eccezione e la validazione. Quindi, anche se si tratta di una dichiarazione scritta per l'API pubblica della classe <code class="docutils literal notranslate"><span class="pre">Validation</span></code>, l'API stessa richiede l'utilizzo di oggetti di classi aggiuntive.</p>
</section>
<section id="what-should-be-the-functional-scope-of-a-single-statement">
<h2>Quale dovrebbe essere lo scope funzionale di un singolo Statement?<a class="headerlink" href="#what-should-be-the-functional-scope-of-a-single-statement" title="Link to this heading">¶</a></h2>
<p>La risposta breve a questa domanda è <em>comportamento</em>. Mettendolo insieme alla sezione precedente, possiamo dire che ogni Statement a livello di unità specifica un singolo comportamento di una classe scritto rispetto all'API pubblica di quella classe. Mi piace come <a class="reference external" href="https://lizkeogh.com/2012/05/30/showcasing-the-language-of-bdd/">Liz Keogh</a> affermi che uno Statement a livello di unità mostra un esempio di come una classe sia preziosa per i suoi utilizzatori. Inoltre, <a class="reference external" href="http://www.sustainabletdd.com/">Amir Kolsky e Scott Bain</a> affermano che ogni Statement dovrebbe &quot;introdurre una distinzione comportamentale non esistente prima&quot;.</p>
<p>Cos’è esattamente un comportamento? Se questo libro è stato letto dall'inizio, probabilmente saranno state viste molte affermazioni che specificano i comportamenti. Lasciate che ve ne mostri un altro, però.</p>
<p>Consideriamo un esempio di una classe che rappresenta una condizione per decidere se un tipo di coda è piena o meno. Un singolo comportamento che possiamo specificare è che la condizione è soddisfatta quando viene avvisato tre volte di qualcosa aggiunto su una coda (quindi da un punto di vista più ampio, è un osservatore (observer) della coda):</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="n">ShouldBeMetWhenNotifiedThreeTimesOfItemQueued</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FullQueueCondition</span><span class="p">();</span>
<span class="w">  </span><span class="n">condition</span><span class="p">.</span><span class="n">NotifyItemQueued</span><span class="p">();</span>
<span class="w">  </span><span class="n">condition</span><span class="p">.</span><span class="n">NotifyItemQueued</span><span class="p">();</span>
<span class="w">  </span><span class="n">condition</span><span class="p">.</span><span class="n">NotifyItemQueued</span><span class="p">();</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">isMet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">condition</span><span class="p">.</span><span class="n">IsMet</span><span class="p">();</span>

<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">True</span><span class="p">(</span><span class="n">isMet</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>La prima cosa da notare è che vengono chiamati due metodi sull'oggetto <code class="docutils literal notranslate"><span class="pre">condition</span></code>: <code class="docutils literal notranslate"><span class="pre">NotifyItemQueued()</span></code> (tre volte) e <code class="docutils literal notranslate"><span class="pre">IsMet()</span></code> (una volta). Considero questo esempio educativo perché ho visto persone fraintendere il livello unitario (unit level) come &quot;specificare un singolo metodo&quot;. Certo, di solito c'è un singolo metodo che attiva il comportamento (in questo caso è <code class="docutils literal notranslate"><span class="pre">isMet()</span></code>, inserito nella sezione <code class="docutils literal notranslate"><span class="pre">//WHEN</span></code>), ma a volte sono necessarie più chiamate per impostare le precondizioni per un determinato comportamento (da qui le tre chiamate <code class="docutils literal notranslate"><span class="pre">Queued()</span></code> inserite nella sezione <code class="docutils literal notranslate"><span class="pre">//GIVEN</span></code>).</p>
<p>La seconda cosa da notare è che lo Statement dice solo cosa succede quando l'oggetto <code class="docutils literal notranslate"><span class="pre">condition</span></code> viene notificato tre volte -- questo è il comportamento specificato. Che dire dello scenario in cui la <code class="docutils literal notranslate"><span class="pre">condition</span></code> viene notificata solo due volte e, quando richiesto in seguito, dovrebbe dire che non è soddisfatta? Questo è un comportamento separato e dovrebbe essere descritto da uno Statement separato. L’ideale a cui tendiamo è caratterizzato da tre regole formulate da Amir Kolsky e citate da Ken Pugh nel suo libro <em>Lean-Agile Acceptance Test-Driven Development</em>:</p>
<ol class="arabic simple">
<li><p>Uno Statement dovrebbe diventare falso per un motivo ben definito.</p></li>
<li><p>Nessun altro Statement dovrebbe risultare falso per lo stesso motivo.</p></li>
<li><p>Uno Statement non dovrebbe risultare falso per nessun altro motivo.</p></li>
</ol>
<p>Sebbene sia impossibile ottenerlo in senso letterale (ad esempio, tutti gli Statement che specificano i comportamenti <code class="docutils literal notranslate"><span class="pre">FullQueueCondition</span></code> devono chiamare un costruttore, quindi quando inserisco un <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">new</span> <span class="pre">Exception()</span></code>, tutti gli Statement diventeranno falsi), however, tuttavia, vogliamo mantenerci il più vicino possibile a questo obiettivo. In questo modo, ogni Statement introdurrà quella &quot;distinzione comportamentale&quot; di cui ho parlato prima, ovvero mostrerà un nuovo modo in cui la classe può essere preziosa per i suoi utilizzatori.</p>
<p>La maggior parte delle volte specifico i comportamenti utilizzando la struttura mentale &quot;GIVEN-WHEN-THEN&quot;. Un comportamento viene attivato (<code class="docutils literal notranslate"><span class="pre">WHEN</span></code>) in un certo tipo di contesto (<code class="docutils literal notranslate"><span class="pre">GIVEN</span></code>) e c'è sempre qualche tipo di risultato (<code class="docutils literal notranslate"><span class="pre">THEN</span></code>) di quel comportamento.</p>
</section>
<section id="failing-to-adhere-to-the-three-rules">
<h2>Non rispettare le tre regole<a class="headerlink" href="#failing-to-adhere-to-the-three-rules" title="Link to this heading">¶</a></h2>
<p>Le tre regole che ho citato derivano dall’esperienza. Vediamo cosa succede se non ne seguiamo una di esse.</p>
<p>Il nostro prossimo esempio riguarda una sorta di regola sulla dimensione del buffer. A questa regola viene chiesto se il buffer può gestire una stringa della lunghezza specificata e risponde &quot;yes&quot; se questa stringa è lunga al massimo tre elementi. Chi ha scritto uno Statement per questa classe a deciso di violare le regole di cui abbiamo parlato e ha scritto qualcosa del genere:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="n">ShouldReportItCanHandleStringWithLengthOf3ButNotOf4AndNotNullString</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">bufferSizeRule</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BufferSizeRule</span><span class="p">();</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">resultForLengthOf3</span><span class="w"> </span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">bufferSizeRule</span><span class="p">.</span><span class="n">CanHandle</span><span class="p">(</span><span class="n">Any</span><span class="p">.</span><span class="n">StringOfLength</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">True</span><span class="p">(</span><span class="n">resultForLengthOf3</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//WHEN - again?</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">resultForLengthOf4</span><span class="w"> </span>
<span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">bufferSizeRule</span><span class="p">.</span><span class="n">CanHandle</span><span class="p">(</span><span class="n">Any</span><span class="p">.</span><span class="n">StringOfLength</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="w">  </span><span class="c1">//THEN - again?</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">False</span><span class="p">(</span><span class="n">resultForLengthOf4</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//WHEN - again??</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">resultForNull</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bufferSizeRule</span><span class="p">.</span><span class="n">CanHandle</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
<span class="w">  </span><span class="c1">//THEN - again??</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">False</span><span class="p">(</span><span class="n">resultForNull</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notare che specifica tre comportamenti:</p>
<ol class="arabic simple">
<li><p>Accettazione di una stringa di dimensione consentita.</p></li>
<li><p>Rifiuto di gestire una stringa di dimensione superiore al limite consentito.</p></li>
<li><p>Un caso speciale di stringa nulla.</p></li>
</ol>
<p>In quanto tale, lo Statement infrange le regole: 1 (Uno Statement dovrebbe diventare falso per un motivo ben definito) e 3 (Uno Statement non dovrebbe diventare falso per nessun altro motivo). In effetti, ci sono tre ragioni che possono rendere falso il nostro Statement.</p>
<p>Ci sono diversi motivi per evitare di scrivere Statement come questo. Alcune sono:</p>
<ol class="arabic simple">
<li><p>La maggior parte dei framework xUnit interrompe l'esecuzione di uno Statement al primo errore di asserzione. Se la prima asserzione fallisce nello Statement precedente, non sapremo se il resto dei comportamenti funziona bene finché non risolviamo il primo.</p></li>
<li><p>La leggibilità tende a peggiorare così come il valore della documentazione delle nostre Specifiche (i nomi di tali Statements tendono ad essere tutt'altro che utili).</p></li>
<li><p>L'isolamento del fallimento è peggiore -- quando uno Statement diventa falso, preferiremmo sapere esattamente quale comportamento è stato sbagliato. Gli Statement come quello sopra non ci danno questo vantaggio.</p></li>
<li><p>Nel corso di un singolo Statement, di solito lavoriamo con lo stesso oggetto. Quando attiviamo più comportamenti su di esso, non possiamo essere sicuri di come l'attivazione di un comportamento influenzi i comportamenti successivi. Se abbiamo ad es. quattro comportamenti in un singolo Statement, non possiamo essere sicuri di come i tre precedenti influenzino l'ultimo. Nell'esempio sopra, potremmo farla franca, poiché l'oggetto specificato ha restituito il suo risultato basandosi solo sull'input di un metodo specifico (cioè non conteneva alcuno stato mutabile). Immaginate, tuttavia, cosa potrebbe accadere se innescassimo più comportamenti su un unica lista. Saremmo sicuri che non contenga alcun elemento rimasto dopo aver aggiunto alcuni elementi, cancellato alcuni, ordinato l'elenco e cancellato ancora di più?</p></li>
</ol>
</section>
<section id="how-many-assertions-do-i-need">
<h2>Di quante asserzioni ho bisogno?<a class="headerlink" href="#how-many-assertions-do-i-need" title="Link to this heading">¶</a></h2>
<p>Una singola asserzione per definizione controlla una singola condizione specificata. Se un singolo Statement riguarda un singolo comportamento, che dire delle asserzioni? &quot;Comportamento singolo&quot; significa che posso avere solo una singola asserzione per Statement? Questo è stato soprattutto il caso degli Statement già visti in questo libro, ma non di tutti.</p>
<p>A dire il vero, c'è una risposta semplice a questa domanda -- una regola che dice: &quot;avere una sola asserzione per test&quot;. Ciò che è importante ricordare è che si applica alle &quot;asserzioni logiche&quot;, come ha indicato Robert C. Martin<a class="footnote-reference brackets" href="#cleancode" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<p>Prima di andare oltre, vorrei introdurre una distinzione. Una &quot;asserzione fisica&quot; è una singola chiamata <code class="docutils literal notranslate"><span class="pre">AssertXXXXX()</span></code>. Una &quot;asserzione logica&quot; è una o più asserzioni fisiche che insieme specificano una condizione logica. Per illustrare ulteriormente questa distinzione, vorrei darvi due esempi di asserzioni logiche.</p>
<section id="logical-assertion-example-1">
<h3>Asserzione logica -- esempio #1<a class="headerlink" href="#logical-assertion-example-1" title="Link to this heading">¶</a></h3>
<p>Un buon esempio potrebbe essere un'asserzione che specifica che tutti gli elementi in una lista sono unici (ovvero l'elenco non contiene duplicati). XUnit.net non ha tale asserzione per default, ma possiamo immaginare di aver scritto qualcosa del genere e di averlo chiamato <code class="docutils literal notranslate"><span class="pre">AssertHasUniqueItems()</span></code>. Ecco del codice che utilizza questa asserzione:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">//some hypothetical code for getting the list:</span>
<span class="kt">var</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetList</span><span class="p">();</span>

<span class="c1">//invoking the assertion:</span>
<span class="n">AssertHasUniqueItems</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
</pre></div>
</div>
<p>Notare che si tratta di una singola asserzione logica, che specifica una condizione ben definita. Se diamo un'occhiata all'implementazione, tuttavia, troveremo il seguente codice:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">AssertHasUniqueItems</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">Count</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list</span><span class="p">.</span><span class="n">Count</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">j</span><span class="p">)</span>
<span class="w">      </span><span class="p">{</span>
<span class="w">        </span><span class="n">Assert</span><span class="p">.</span><span class="n">NotEqual</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Che esegue già diverse asserzioni fisiche. Se conoscessimo il numero esatto di elementi nella collection, potremmo anche utilizzare tre asserzioni <code class="docutils literal notranslate"><span class="pre">Assert.NotEqual()</span></code> invece di <code class="docutils literal notranslate"><span class="pre">AssertHasUniqueItems()</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">//some hypothetical code for getting the collection:</span>
<span class="kt">var</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetLastThreeElements</span><span class="p">();</span>

<span class="c1">//invoking the assertions:</span>
<span class="n">Assert</span><span class="p">.</span><span class="n">NotEqual</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">Assert</span><span class="p">.</span><span class="n">NotEqual</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="n">Assert</span><span class="p">.</span><span class="n">NotEqual</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">list</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</pre></div>
</div>
<p>È ancora una sola asserzione? Fisicamente no, ma logicamente -- sì. C'è ancora una cosa logica che queste asserzioni specificano e cioè l'unicità degli elementi nella lista.</p>
</section>
<section id="logical-assertion-example-2">
<h3>Asserzione logica -- esempio #2<a class="headerlink" href="#logical-assertion-example-2" title="Link to this heading">¶</a></h3>
<p>Un altro esempio di asserzione logica è quella che specifica le eccezioni: <code class="docutils literal notranslate"><span class="pre">Assert.Throws()</span></code>. Ne abbiamo già incontrato uno simile in questo capitolo. Ecco di nuovo il codice:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span>
<span class="n">ShouldThrowValidationExceptionWithFatalErrorLevelWhenValidatedStringIsEmpty</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">validation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Validation</span><span class="p">();</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">exceptionThrown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Assert</span><span class="p">.</span><span class="n">Throws</span><span class="o">&lt;</span><span class="n">CustomException</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">validation</span><span class="p">.</span><span class="n">ApplyTo</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">)</span><span class="w"> </span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">True</span><span class="p">(</span><span class="n">exceptionThrown</span><span class="p">.</span><span class="n">IsFatalError</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notare che in questo caso ci sono due asserzioni fisiche (<code class="docutils literal notranslate"><span class="pre">Assert.Throws()</span></code> e <code class="docutils literal notranslate"><span class="pre">Assert.True()</span></code>), ma un solo intento -- specificare l'eccezione che deve essere sollevata. Possiamo anche estrarre queste due asserzioni fisiche in una sola con un nome significativo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span>
<span class="n">ShouldThrowValidationExceptionWithFatalErrorLevelWhenValidatedStringIsEmpty</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">validation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Validation</span><span class="p">();</span>

<span class="w">  </span><span class="c1">//WHEN - THEN</span>
<span class="w">  </span><span class="n">AssertFatalErrorIsThrownWhen</span><span class="p">(</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">validation</span><span class="p">.</span><span class="n">ApplyTo</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">)</span><span class="w"> </span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Quindi ogni volta che abbiamo diverse asserzioni fisiche che possono essere (o sono) estratte in un unico metodo di asserzione con un nome significativo, le considero un'unica asserzione logica. C'è sempre un'area grigia in quello che può essere considerato un &quot;nome significativo&quot; (ma concordiamo sul fatto che <code class="docutils literal notranslate"><span class="pre">AssertAllConditionsAreMet()</span></code> non è un nome significativo, ok?). La regola generale è che questo nome dovrebbe esprimere il nostro intento in modo migliore e più chiaro rispetto al mucchio di asserzioni che nasconde. Guardando nuovamente l'esempio di <code class="docutils literal notranslate"><span class="pre">AssertHasUniqueItems()</span></code> questa asserzione esprime meglio il nostro intento rispetto a un insieme di tre <code class="docutils literal notranslate"><span class="pre">Assert.NotEqual()</span></code>.</p>
</section>
</section>
<section id="summary">
<h2>Riepilogo<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>In questo capitolo abbiamo cercato di scoprire quanto dovrebbe contenere un singolo Statement. Abbiamo esaminato le nozioni di livello e <em>scope</em> funzionale per arrivare alla conclusione che uno Statement a dovrebbe coprire un singolo comportamento. Abbiamo supportato questa affermazione con le tre regole di Amir Kolsky e abbiamo esaminato un esempio di cosa potrebbe accadere quando non ne seguiamo una. Infine, abbiamo discusso come la nozione di &quot;singolo Statement per comportamento&quot; sia correlata a &quot;singola asserzione per Statement&quot;.</p>
</section>
</section>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="unclebobdisagrees" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Alcuni, tuttavia, non sono d'accordo con la scrittura di Statement a livello di classe - vedere https://blog.cleancoder.com/uncle-bob/2017/03/03/TDD-Harms-Architecture.html o https://vimeo.com/68375232</p>
</aside>
<aside class="footnote brackets" id="cleancode" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Le serie di &quot;Clean Code&quot;, episodio 19 (https://cleancoders.com/episode/clean-code-episode-19-p1/show), Robert C. Martin, 2013</p>
</aside>
</aside>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">TDD</a></h1>








<h3>Navigazione</h3>
<p class="caption" role="heading"><span class="caption-text">Contenuti:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Cover.html">Titolo</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Premessa</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html">Premessa</a></li>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html#dedications">Dediche</a></li>
<li class="toctree-l1"><a class="reference internal" href="015_Thanks.html">Grazie!</a></li>
<li class="toctree-l1"><a class="reference internal" href="017_CodeExamples.html">I codici di esempio</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 1:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="020_Part1Marker.html">Parte 1: Solo le nozioni di base</a></li>
<li class="toctree-l1"><a class="reference internal" href="030_Motivations.html">Motivazione: il primo passo per imparare il TDD</a></li>
<li class="toctree-l1"><a class="reference internal" href="040_Three_Essential_Tools.html"><span class="xref myst">Gli strumenti essenziali</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="050_Its_Not_a_Test.html">Non è (solo) un test</a></li>
<li class="toctree-l1"><a class="reference internal" href="060_Statement_First_Programming.html">La programmazione Statement-first</a></li>
<li class="toctree-l1"><a class="reference internal" href="070_Practicing_What_We_Already_Learned.html">Mettere in pratica ciò che abbiamo già imparato</a></li>
<li class="toctree-l1"><a class="reference internal" href="080_Sorting_out_the_bits.html">Facciamo un po' d'ordine</a></li>
<li class="toctree-l1"><a class="reference internal" href="090_How_to_start.html">Come iniziare?</a></li>
<li class="toctree-l1"><a class="reference internal" href="100_Analysis_In_TDD.html">In che modo il TDD riguarda l'analisi e cosa significa &quot;GIVEN-WHEN-THEN&quot;?</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Qual è lo scopo di uno Statement a livello di unità in TDD?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#scope-and-level">Scope e livello</a></li>
<li class="toctree-l2"><a class="reference internal" href="#on-what-level-do-we-specify-our-software">A quale livello specifichiamo il nostro software?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#what-should-be-the-functional-scope-of-a-single-statement">Quale dovrebbe essere lo scope funzionale di un singolo Statement?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#failing-to-adhere-to-the-three-rules">Non rispettare le tre regole</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-many-assertions-do-i-need">Di quante asserzioni ho bisogno?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Riepilogo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="120_Constrained_Non_Determinism.html">Sviluppare uno stile TDD e Non-Determinismo Vincolato</a></li>
<li class="toctree-l1"><a class="reference internal" href="130_Boundaries.html">Specificare i confini e le condizioni funzionali</a></li>
<li class="toctree-l1"><a class="reference internal" href="140_Triangulation.html">Guidare l'implementazione dalle Specifiche</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 2:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="150_Part2Marker.html">Parte 2: Il Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="160_Composable_Design.html">La Componibilità degli Oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="170_TellDoNotAsk.html"><span class="xref myst">Raccontare, non chiedere</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="180_Web_of_objects_explained.html">La necessità degli oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="190_Why_do_we_need_composability.html">Perché abbiamo bisogno della componibilità?</a></li>
<li class="toctree-l1"><a class="reference internal" href="200_What_does_it_mean_to_compose_objects.html">Reti, messaggi e protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="210_How_are_objects_composed.html">Comporre una rete di oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="211_When_are_objects_composed.html">Quando vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="212_How_are_the_connections_made.html">Come fa un mittente ad ottenere un riferimento a un destinatario (cioè come vengono stabilite le connessioni)?</a></li>
<li class="toctree-l1"><a class="reference internal" href="213_Where_are_objects_composed.html">Dove vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="220_Designing_for_composabiity_interfaces.html">Interfacce</a></li>
<li class="toctree-l1"><a class="reference internal" href="230_Designing_for_composabiity_protocols.html">Protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="235_Classes.html">Le Classi</a></li>
<li class="toctree-l1"><a class="reference internal" href="240_Refactoring_Object_Composition.html">Composizione di Oggetti come Linguaggio</a></li>
<li class="toctree-l1"><a class="reference internal" href="250_Value_Objects.html">Gli <em>Oggetti Valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="255_Value_Objects_properties.html">Anatomia del <em>oggetto valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="257_Value%20objects_general_topics.html">Aspetti del design degli <em>oggetti valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html">Oggetti di Trasferimento Dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-behavior">Disaccoppiamento mediante l'astrazione del comportamento</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-data">Disaccoppiamento mediante l'astrazione dei dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#use-both">Usare entrambi</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#dto-as-data-centric-decoupling-mechanism">DTO come meccanismo di disaccoppiamento incentrato sui dati</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 3:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="260_Part3Marker.html">Parte 3: TDD nel Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="270_Mock_Objects.html">Oggetti Mock come strumento di test</a></li>
<li class="toctree-l1"><a class="reference internal" href="280_Start_with_a_failing_test_mocks.html">Test-first  [<em>Testare prima</em>] utilizzando oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="290_NeedDrivenDevelopment.html">Il test-driving ai confini di input</a></li>
<li class="toctree-l1"><a class="reference internal" href="300_NeedDrivenRetrospective1.html">Il test-driving ai confini di input -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="310_Test_Driving_Factories.html">Creazione di oggetti &quot;test-driving&quot;</a></li>
<li class="toctree-l1"><a class="reference internal" href="320_Test_Driving_Factories_retrospective.html">Creazione di oggetti &quot;test-driving&quot; -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="330_Test-Driving_Command.html">Logica dell'applicazione test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="340_Test-Driving_Value_object.html"><em>Oggetti valore</em> nel test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="350_Web_of_objects_boundaries.html">Raggiungere la rete dei confini degli oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="360_Internals.html">Cosa c'è dentro l'oggetto?</a></li>
<li class="toctree-l1"><a class="reference internal" href="370_Design_smells.html">Odori del design visibile nella Specifica</a></li>
<li class="toctree-l1"><a class="reference internal" href="End.html">QUESTO È TUTTO QUELLO CHE HO PER ORA. QUELLO CHE SEGUE È MATERIALE GREZZO, NON ORDINATO, NON ANCORA PRONTO PER ESSERE CONSUMATO COME PARTE DI QUESTO TUTORIAL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 5:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html">Mock di oggetti come strumento di progettazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#guidance-of-test-smells">Guidaa ai test smells [<em>puzzolenti</em>]</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#revisiting-topics-from-chapter-1">Rivedere gli argomenti del capitolo 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#maintainable-mock-based-statements">Statement manutenibili basate su mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#refactoring-mock-code">Refactoring del codice mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-4-application-architecture">Parte 4: Architettura dell'applicazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#on-stable-architectural-boundaries">Sui confini stabili/architetturali</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#ports-and-adapters">[Port] e adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-application">Cosa entra in applicazione?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-ports">Cosa va nei [port]?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-5-tdd-on-application-architecture-level">Parte 5: TDD a livello di architettura applicativa</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#designing-automation-layer">Progettazione del layer di automazione</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 9:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="990_Further_reading.html"><span class="xref myst">Ulteriori Letture</span></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="100_Analysis_In_TDD.html" title="capitolo precedente">In che modo il TDD riguarda l'analisi e cosa significa &quot;GIVEN-WHEN-THEN&quot;?</a></li>
      <li>Next: <a href="120_Constrained_Non_Determinism.html" title="capitolo successivo">Sviluppare uno stile TDD e Non-Determinismo Vincolato</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Ricerca veloce</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Vai" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Grzegorz GaÅ‚Ä™zowski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/manuscript/110_What_is_the_scope_of_a_Statement_in_TDD.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>