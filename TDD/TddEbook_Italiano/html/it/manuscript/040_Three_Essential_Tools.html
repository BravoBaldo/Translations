<!DOCTYPE html>

<html lang="it" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Gli strumenti essenziali &#8212; Documentazione TDD 2025 </title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=ad698211"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=45930005"></script>
    <link rel="index" title="Indice" href="../genindex.html" />
    <link rel="search" title="Cerca" href="../search.html" />
    <link rel="next" title="Non è (solo) un test" href="050_Its_Not_a_Test.html" />
    <link rel="prev" title="Motivazione: il primo passo per imparare il TDD" href="030_Motivations.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="the-essential-tools-chapter-essential-tools">
<h1><a class="reference internal" href="#chapter-essential-tools"><span class="xref myst">Gli strumenti essenziali</span></a><a class="headerlink" href="#the-essential-tools-chapter-essential-tools" title="Link to this heading">¶</a></h1>
<p>Avete mai visto Karate Kid, sia la vecchia versione che quella nuova? La cosa che hanno in comune è che quando il ragazzo &quot;[kid]&quot; inizia a imparare il karate (o il kung-fu) dal suo maestro, gli viene assegnato un compito basilare e ripetitivo (come togliersi una giacca e indossarla di nuovo), senza sapere ancora dove lo avrebbe portato. Oppure nel primo film di Rocky (sì, quello con Sylvester Stallone), in cui Rocky insegue un pollo per migliorare la sua agilità.</p>
<p>Quando ho provato a imparare a suonare la chitarra ho trovato due consigli sul web: il primo era quello di iniziare padroneggiando un singolo brano difficile. Il secondo era suonare con una sola corda, imparare a farla suonare in modi diversi e provare a suonare alcune melodie a orecchio solo con questa corda. Devo dire che il secondo consiglio ha funzionato meglio?</p>
<p>Onestamente, potrei tuffarmi direttamente nelle tecniche fondamentali del TDD, ma sento che sarebbe come salire su un ring contro un avversario molto forte: molto probabilmente si abbandonerebbe prima di acquisire le abilità necessarie. Quindi, invece di spiegare come vincere una gara, in questo capitolo daremo un'occhiata a quali automobili scintillanti guideremo.</p>
<p>In altre parole, offrirò un breve tour dei tre strumenti che utilizzeremo in questo libro.</p>
<p>In questo capitolo semplificherò eccessivamente alcune cose solo per iniziare a lavorare senza entrare ancora nella filosofia del TDD (si pensi alle lezioni di fisica alle elementari). Nessuna paura :-), mi rifarò nei prossimi capitoli!</p>
<section id="test-framework">
<h2>Framework di test<a class="headerlink" href="#test-framework" title="Link to this heading">¶</a></h2>
<p>Il primo tool che utilizzeremo è un framework. Un framework di test ci consente di specificare ed eseguire i test.</p>
<p>Supponiamo per questa introduzione di avere un'applicazione che accetta due numeri dalla riga di comando, li moltiplica e stampa il risultato sulla console. Il codice è piuttosto semplice:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">  </span><span class="k">try</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">firstNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Int32</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">secondNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Int32</span><span class="p">.</span><span class="n">Parse</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">      </span><span class="k">new</span><span class="w"> </span><span class="nf">Multiplication</span><span class="p">(</span><span class="n">firstNumber</span><span class="p">,</span><span class="w"> </span><span class="n">secondNumber</span><span class="p">).</span><span class="n">Perform</span><span class="p">();</span>

<span class="w">    </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Result is: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">catch</span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Multiplication failed because of: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span>
</pre></div>
</div>
<p>Supponiamo ora di voler verificare se questa applicazione produce risultati corretti. Il modo più ovvio sarebbe quello di invocarlo manualmente dalla riga di comando con alcuni argomenti esemplificativi, poi controllare l'output sulla console e confrontarlo con quello che ci aspettavamo di vedere. Tale sessione di test potrebbe assomigliare a questa:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>C:\MultiplicationApp\MultiplicationApp.exe 3 7
21
C:\MultiplicationApp\
</pre></div>
</div>
<p>Come si vede, l'applicazione produce un risultato pari a 21 per la moltiplicazione di 3 per 7. Questo è corretto, quindi presumiamo che l'applicazione abbia superato il test.</p>
<p>E se l'applicazione eseguisse anche addizioni, sottrazioni, divisioni, calcoli, ecc.? Quante volte dovremmo richiamare manualmente l'applicazione per verificare che ogni operazione funzioni correttamente? Non sarebbe una perdita di tempo? Ma ..un momento.., siamo programmatori, giusto? Quindi possiamo scrivere programmi che eseguano i test per noi! Ad esempio, ecco il codice sorgente di un programma che utilizza la classe Multiplication, ma in un modo leggermente diverso rispetto all'applicazione originale:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">multiplication</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Multiplication</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="w">  </span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiplication</span><span class="p">.</span><span class="n">Perform</span><span class="p">();</span>
<span class="w">  </span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">21</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">Exception</span><span class="p">(</span><span class="s">&quot;Failed! Expected: 21 but was: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sembra semplice, vero? Ora, utilizziamo questo codice come base per costruire un framework di test molto primitivo, solo per mostrare le parti di cui sono costituiti tali framework. Come avanzamento in questa direzione, possiamo estrarre la verifica di <code class="docutils literal notranslate"><span class="pre">result</span></code> in un metodo riutilizzabile: dopo tutto, aggiungeremo la divisione in un secondo, giusto? Quindi ecco qui:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">multiplication</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Multiplication</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="w">  </span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiplication</span><span class="p">.</span><span class="n">Perform</span><span class="p">();</span>
<span class="w">  </span>
<span class="w">  </span><span class="n">AssertTwoIntegersAreEqual</span><span class="p">(</span><span class="n">expected</span><span class="p">:</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="n">actual</span><span class="p">:</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//extracted code:</span>
<span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">AssertTwoIntegersAreEqual</span><span class="p">(</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">actual</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">expected</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">Exception</span><span class="p">(</span>
<span class="w">      </span><span class="s">&quot;Failed! Expected: &quot;</span><span class="w"> </span>
<span class="w">        </span><span class="o">+</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; but was: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">actual</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notare che ho iniziato il nome di questo metodo estratto con &quot;Assert&quot;: torneremo presto sulla nomenclatura, per ora presupponiamo solo che questo sia un buon nome per un metodo che verifica che un risultato corrisponda alle nostre aspettative. Facciamo un ultimo giro ed estraiamo il test stesso in modo che il suo codice sia in un metodo separato. A questo metodo si può assegnare un nome che descriva lo scopo del test:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Multiplication_ShouldResultInAMultiplicationOfTwoPassedNumbers</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="nf">Multiplication_ShouldResultInAMultiplicationOfTwoPassedNumbers</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//Assuming...</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">multiplication</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Multiplication</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//when this happens:</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiplication</span><span class="p">.</span><span class="n">Perform</span><span class="p">();</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//then the result should be...</span>
<span class="w">  </span><span class="n">AssertTwoIntegersAreEqual</span><span class="p">(</span><span class="n">expected</span><span class="p">:</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="n">actual</span><span class="p">:</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">AssertTwoIntegersAreEqual</span><span class="p">(</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">actual</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">expected</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">Exception</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;Failed! Expected: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">expected</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; but was: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">actual</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>E abbiamo finito. Ora, se abbiamo bisogno di un altro test, ad es. per la divisione, possiamo semplicemente aggiungere una nuova chiamata al metodo <code class="docutils literal notranslate"><span class="pre">Main()</span></code> e implementarla. All'interno di questo nuovo test, possiamo riutilizzare il metodo <code class="docutils literal notranslate"><span class="pre">AssertTwoIntegersAreEqual()</span></code>, poiché il controllo della divisione riguarderebbe anche il confronto di due valori interi.</p>
<p>Come si vede, possiamo facilmente scrivere controlli automatizzati come questo, utilizzando i nostri metodi primitivi. Tuttavia, questo approccio presenta alcuni svantaggi:</p>
<ol class="arabic simple">
<li><p>Ogni volta che aggiungiamo un nuovo test, dobbiamo aggiornare il metodo <code class="docutils literal notranslate"><span class="pre">Main()</span></code> con una chiamata al nuovo test. Se dimentichiamo di aggiungere tale chiamata, il test non verrà mai eseguito. All'inizio non è un grosso problema, ma non appena avremo dozzine di test, un'omissione diventerà difficile da notare.</p></li>
<li><p>Si immagini che il sistema sia costituito da più di un'applicazione: si avrebbero dei problemi nel tentare di raccogliere risultati riassuntivi per tutte le applicazioni di cui è composto il sistema.</p></li>
<li><p>Presto si dovranno scrivere molti altri metodi simili ad <code class="docutils literal notranslate"><span class="pre">AssertTwoIntegersAreEqual()</span></code> -- quello che già abbiamo confronta due numeri interi per verificarne l'uguaglianza, ma cosa succederebbe se volessimo verificare una condizione diversa, ad es. che un numero intero sia maggiore di un altro? E se volessimo verificare l'uguaglianza non per gli interi, ma per i caratteri, le stringhe, i numeri in virgola mobile, ecc.? E se volessimo verificare alcune condizioni sulle collezioni, ad es. che una collezione sia ordinata o che tutti gli elementi della collezione siano unici?</p></li>
<li><p>Se un test fallisce, sarebbe difficile passare dall'output della riga di comando alla riga corrispondente del sorgente nell'IDE. Non sarebbe più semplice se si potesse cliccare sul messaggio di errore per poi andare immediatamente al codice in cui si è verificato l'errore?</p></li>
</ol>
<p>Per questi e altri motivi sono stati creati framework di test automatizzati avanzati come CppUnit (per C++), JUnit (per Java) o NUnit (C#). Tali framework sono in linea di principio basate proprio sull’idea che ho abbozzato sopra, inoltre compensano le carenze del nostro approccio primitivo. Derivano la loro struttura e funzionalità da SUnit di Smalltalk e sono collettivamente indicati come framework di test della <strong>famiglia xUnit</strong>.</p>
<p>Ad essere onesti, non vedo l'ora di mostrare come appare il test che abbiamo appena scritto quando viene utilizzato un framework di test. Ma prima, ricapitoliamo ciò che abbiamo nel nostro approccio diretto alla scrittura di test automatizzati e introduciamo una terminologia che ci aiuterà a capire come i framework di automazione dei test risolvono i nostri problemi:</p>
<ol class="arabic simple">
<li><p>Il metodo <code class="docutils literal notranslate"><span class="pre">Main()</span></code> funge da <strong>Test List</strong> -- un posto in cui si decide quali test eseguire.</p></li>
<li><p>Il metodo <code class="docutils literal notranslate"><span class="pre">Multiplication_ShouldResultInAMultiplicationOfTwoPassedNumbers()</span></code> è un <strong>Test Method</strong>.</p></li>
<li><p>Il metodo <code class="docutils literal notranslate"><span class="pre">AssertTwoIntegersAreEqual()</span></code> è una <strong>Assertion</strong> -- una condizione che, se non soddisfatta, termina un test con un fallimento.</p></li>
</ol>
<p>Con nostra gioia, questi tre elementi sono presenti anche quando utilizziamo un framework di test. Inoltre, sono molto più avanzati di quelli che abbiamo. Per illustrare ciò, ecco (finalmente!) lo stesso test che abbiamo scritto sopra, utilizzando ora il framework di test <a class="reference external" href="https://xunit.net/">xUnit.Net</a>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="n">Multiplication_ShouldResultInAMultiplicationOfTwoPassedNumbers</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//Assuming...</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">multiplication</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Multiplication</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//when this happens:</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiplication</span><span class="p">.</span><span class="n">Perform</span><span class="p">();</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//then the result should be...</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">Equal</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Guardando l'esempio, possiamo vedere che il metodo di test stesso è l'unica cosa rimasta: i due metodi (l'elenco di test e l'asserzione) che avevamo in precedenza ora non ci sono più. Beh, a dire il vero, non sono letteralmente spariti: è solo che il framework di test offre sostituti di gran lunga migliori, quindi li abbiamo utilizzati al loro posto. Ribadiamo i tre elementi della versione precedente del test che avevo promesso sarebbero stati presenti dopo la transizione al framework di test:</p>
<ol class="arabic simple">
<li><p>La <strong>Test List</strong> viene ora creato automaticamente dal framework da tutti i metodi contrassegnati con un attributo <code class="docutils literal notranslate"><span class="pre">[Fact]</span></code>. Non è più necessario mantenere uno o più elenchi centrali, quindi il metodo <code class="docutils literal notranslate"><span class="pre">Main()</span></code> non esiste più.</p></li>
<li><p>Il <strong>Test Method</strong> è presente e sembra quasi lo stesso di prima.</p></li>
<li><p>La <strong>Assertion</strong> assume la forma di una chiamata al metodo statico <code class="docutils literal notranslate"><span class="pre">Assert.Equal()</span></code> -- il framework xUnit.NET è fornito in bundle con un'ampia gamma di metodi di asserzione, quindi ne ho usato uno. Naturalmente, nessuno impedisce di scrivere la propria asserzione se i metodi di asserzione nativi non offrono ciò che serve.</p></li>
</ol>
<p>Uff, spero di aver reso la transizione abbastanza indolore. Ora l'ultima cosa da aggiungere: poiché nell'ultimo esempio non esiste più il metodo <code class="docutils literal notranslate"><span class="pre">Main()</span></code>, ci si chiederà, sicuramente, come eseguiamo questi test, giusto? Ok, l'ultimo grande segreto svelato: utilizziamo un'applicazione esterna per questo (ci riferiremo ad essa utilizzando il termine <strong>Test Runner</strong>) -- gli diciamo quali assembly eseguire e poi li carica, li esegue, riporta i risultati, ecc. Un Test Runner può assumere varie forme, ad es. può essere un'applicazione console, un'applicazione GUI o un plug-in per un IDE. Ecco un esempio di un test runner fornito da un plug-in per l'IDE di Visual Studio chiamato Resharper:</p>
<p><img alt="Il test runner Resharper [docked] come finestra in Visual Studio 2015 IDE" src="../_images/Resharper_Test_Runner.PNG" /></p>
</section>
<section id="mocking-framework">
<h2>Framework per il Mocking<a class="headerlink" href="#mocking-framework" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="../_images/Exclamation.png"><img alt="Exclamation" class="align-left" src="../_images/Exclamation.png" style="width: 30px;" /></a> Questa introduzione è scritta per coloro che non sono esperti nell'uso dei mock. Anche se accetto il fatto che il concetto potrebbe essere troppo difficile da comprendere. Se, leggendo questa sezione, ci si sente persi, la si salti. Non ci occuperemo degli oggetti mock fino alla parte 2, dove offro una descrizione più ricca e accurata del concetto.</p>
<p>Quando vogliamo testare una classe che dipende da altre classi, potremmo pensare che sia una buona idea includere anche quelle classi nel test. Questo però non ci permette di testare un singolo oggetto o un piccolo gruppo di oggetti, dove potremmo verificare che solo una piccola parte dell'applicazione funzioni correttamente. Per fortuna, se facciamo in modo che le nostre classi dipendano da interfacce anziché da altre classi, possiamo facilmente implementare tali interfacce con speciali classi &quot;fake&quot; che possono essere realizzate in modo da semplificare i nostri test. Ad esempio, gli oggetti di tali classi possono contenere valori di ritorno preprogrammati per alcuni metodi. Possono anche registrare i metodi che vengono invocati e consentire al test di verificare se la comunicazione tra il nostro oggetto in test e le sue dipendenze sia corretta.</p>
<p>Al giorno d'oggi, possiamo fare affidamento su tool per generare un'implementazione &quot;fake&quot; di una determinata interfaccia e consentirci di utilizzare tale implementazione al posto di un oggetto reale nei test. Ciò avviene in modo diverso, a seconda della linguaggio. A volte, le implementazioni dell'interfaccia possono essere generate a runtime (come in Java o in C#), a volte dobbiamo fare più affidamento sulla generazione in fase di compilazione (ad esempio in C++).</p>
<p>Restringendo il campo al C#, un framework di mocking è proprio questo, un meccanismo che ci consente di creare oggetti (chiamati &quot;oggetti mock&quot; o semplicemente &quot;mock&quot;), che aderiscono a una determinata interfaccia, in fase di esecuzione. Funziona così: il tipo di interfaccia che vogliamo implementare viene solitamente passato a un metodo speciale che restituisce un oggetto mock basato su quell'interfaccia (vedremo un esempio tra qualche secondo). A parte la creazione di oggetti mock, tale framework fornisce un'API per configurare i mock su come comportarsi quando vengono chiamati determinati metodi e ci consente di controllare quali chiamate hanno ricevuto. Questa è una funzionalità molto potente, perché possiamo simulare o verificare condizioni che sarebbero difficili da ottenere o osservare utilizzando solo il codice di produzione. I framework di mocking non sono vecchi quanto quelli di test, quindi non sono stati utilizzati in TDD sin dall'inizio.</p>
<p>Darò un rapido esempio di un framework di mocking in azione ora e rimanderò ulteriori spiegazioni del loro scopo ai capitoli successivi, poiché la descrizione completa dei mock e il loro posto in TDD non è così facile da trasmettere.</p>
<p>Supponiamo di avere una classe che consenta di effettuare ordini e poi di inserire questi ordini in un database (utilizzando un'implementazione di un'interfaccia chiamata <code class="docutils literal notranslate"><span class="pre">OrderDatabase</span></code>). Inoltre, gestisce qualsiasi eccezione che possa verificarsi, scrivendola in un log. La classe in sé non fa nulla di importante, ma proviamo a immaginare che si tratti di una logica di un dominio serio. Ecco il codice per questa classe:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">OrderProcessing</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">OrderDatabase</span><span class="w"> </span><span class="n">_orderDatabase</span><span class="p">;</span><span class="w"> </span><span class="c1">//OrderDatabase is an interface</span>
<span class="w">  </span><span class="n">Log</span><span class="w"> </span><span class="n">_log</span><span class="p">;</span>

<span class="w">  </span><span class="c1">//we get the database object  from outside the class:</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">OrderProcessing</span><span class="p">(</span>
<span class="w">    </span><span class="n">OrderDatabase</span><span class="w"> </span><span class="n">database</span><span class="p">,</span>
<span class="w">    </span><span class="n">Log</span><span class="w"> </span><span class="n">log</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">_orderDatabase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">database</span><span class="p">;</span>
<span class="w">    </span><span class="n">_log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">log</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//other code...</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Place</span><span class="p">(</span><span class="n">Order</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">_orderDatabase</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">_log</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;Could not insert an order. Reason: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//other code...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ora, immaginiamo di doverlo testare: come lo facciamo? Vedo già scuotere la testa e dire: &quot;Creiamo semplicemente una connessione al database, invochiamo il metodo <code class="docutils literal notranslate"><span class="pre">Place()</span></code> e vediamo se il record viene aggiunto correttamente nel database&quot;. Se lo facessimo, il primo test sarebbe simile a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="n">ShouldInsertNewOrderToDatabaseWhenOrderIsPlaced</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderDatabase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MySqlOrderDatabase</span><span class="p">();</span><span class="w"> </span><span class="c1">//uses real database</span>
<span class="w">  </span><span class="n">orderDatabase</span><span class="p">.</span><span class="n">Connect</span><span class="p">();</span>
<span class="w">  </span><span class="n">orderDatabase</span><span class="p">.</span><span class="n">Clean</span><span class="p">();</span><span class="w"> </span><span class="c1">//clean up after potential previous tests</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderProcessing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderProcessing</span><span class="p">(</span><span class="n">orderDatabase</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileLog</span><span class="p">());</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Order</span><span class="p">(</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Grzesiek&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">surname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Galezowski&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">product</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Agile Acceptance Testing&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">date</span><span class="p">:</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">,</span>
<span class="w">    </span><span class="n">quantity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="n">orderProcessing</span><span class="p">.</span><span class="n">Place</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">allOrders</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orderDatabase</span><span class="p">.</span><span class="n">SelectAllOrders</span><span class="p">();</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="n">allOrders</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All'inizio del test, apriamo una connessione al database e puliamo tutti gli ordini esistenti al suo interno (ne parleremo a breve), quindi creiamo un oggetto ordine, lo inseriamo nel database ed interroghiamo il database per tutti gli ordini in esso contenuti. Alla fine affermiamo che l'ordine che abbiamo provato a inserire è tra tutti gli ordini presenti nel database.</p>
<p>Perché puliamo il database all'inizio del test? C'è da ricordarsi che un database fornisce spazio di archiviazione permanente. Se non lo ripuliamo prima di eseguire la logica di questo test, il database potrebbe già contenere l'elemento che stiamo tentando di aggiungere, ad es. dalle precedenti esecuzioni di questo test. Il database potrebbe non consentirci di aggiungere nuovamente lo stesso elemento e il test fallirebbe. Ahia! Fa così male, perché volevamo che i nostri test dimostrassero che qualcosa funziona, ma sembra che possa fallire anche quando la logica è codificata correttamente. A cosa servirebbe un test del genere se non potesse dirci in modo affidabile se la logica implementata è corretta o meno? Pertanto, per garantire che lo stato dell'archiviazione persistente sia lo stesso ogni volta che eseguiamo questo test, puliamo il database prima di ogni esecuzione.</p>
<p>Ora che il test è pronto, abbiamo ottenuto ciò che volevamo? Sarei titubante nel rispondere &quot;sì&quot;. Ci sono diverse ragioni per questo:</p>
<ol class="arabic simple">
<li><p>Molto probabilmente il test sarà lento perché l'accesso al database è relativamente lento. Non è raro avere più di mille test in una suite e non voglio aspettare mezz'ora per i risultati ogni volta che li eseguo. Cosa fare?</p></li>
<li><p>Tutti coloro che desiderano eseguire questo test dovranno impostare un ambiente speciale, ad es. un database locale sul proprio computer. E se la loro configurazione fosse leggermente diversa dalla nostra? Cosa succede se lo schema diventa obsoleto: tutti riusciranno a notarlo e ad aggiornare di conseguenza lo schema dei propri database locali? Dovremmo eseguire nuovamente il nostro script di creazione del database solo per assicurarci di avere lo schema più recente disponibile su cui eseguire i test?</p></li>
<li><p>Potrebbe non esserci alcuna implementazione del motore di database per il sistema operativo in esecuzione sulla nostra macchina di sviluppo se il nostro target è una piattaforma esotica o mobile.</p></li>
<li><p>Notare che il test che abbiamo scritto è solo uno di due. Dobbiamo ancora scriverne un altro per lo scenario in cui l'inserimento di un ordine termina con un'eccezione. Come configuriamo il database in uno stato in cui genera un'eccezione? È possibile, ma richiede uno sforzo significativo (ad esempio eliminare una tabella e ricrearla dopo il test, per utilizzarla da altri test che potrebbero aver bisogno che venga eseguita correttamente), il che potrebbe portare alcuni alla conclusione che non vale affatto la pena scrivere tali test.</p></li>
</ol>
<p>Ora proviamo ad affrontare questo problema in modo diverso. Supponiamo che <code class="docutils literal notranslate"><span class="pre">MySqlOrderDatabase</span></code> che esegue una query su un database reale sia già testato (questo perché non voglio ancora entrare in una discussione sul test delle query di database: ci arriveremo nei prossimi capitoli) e che l'unica cosa che dobbiamo testare è la classe <code class="docutils literal notranslate"><span class="pre">OrderProcessing</span></code> (ricordate, qui stiamo cercando di immaginare che ci sia davvero una logica di dominio seria codificata). In questa situazione possiamo lasciare <code class="docutils literal notranslate"><span class="pre">MySqlOrderDatabase</span></code> fuori dal test e creare invece un'altra falsa implementazione di <code class="docutils literal notranslate"><span class="pre">OrderDatabase</span></code> che si comporta come se fosse una connessione a un database ma non scrive su un database reale: memorizza solo i record inseriti in un elenco in memoria. Il codice per una connessione falsa potrebbe assomigliare a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">FakeOrderDatabase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">OrderDatabase</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">Order</span><span class="w"> </span><span class="n">_receivedArgument</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="n">Order</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">_receivedArgument</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">order</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SelectAllOrders</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">_receivedOrder</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notare che il database fake degli ordini è un'istanza di una classe personalizzata che implementa la stessa interfaccia di <code class="docutils literal notranslate"><span class="pre">MySqlOrderDatabase</span></code>. Pertanto, se ci proviamo, possiamo fare in modo che il codice testato utilizzi il nostro fake senza saperlo.</p>
<p>Sostituiamo la reale implementazione del database degli ordini con l'istanza fake nel test:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="n">ShouldInsertNewOrderToDatabaseWhenOrderIsPlaced</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderDatabase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FakeOrderDatabase</span><span class="p">();</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderProcessing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderProcessing</span><span class="p">(</span><span class="n">orderDatabase</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileLog</span><span class="p">());</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Order</span><span class="p">(</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Grzesiek&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">surname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Galezowski&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">product</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Agile Acceptance Testing&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">date</span><span class="p">:</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">,</span>
<span class="w">    </span><span class="n">quantity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="n">orderProcessing</span><span class="p">.</span><span class="n">Place</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">allOrders</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orderDatabase</span><span class="p">.</span><span class="n">SelectAllOrders</span><span class="p">();</span>
<span class="w">  </span><span class="n">Assert</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="n">allOrders</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notare che non puliamo l'oggetto del database fake come abbiamo fatto con il database reale poiché creiamo un nuovo oggetto ogni volta che viene eseguito il test e i risultati vengono archiviati in una posizione di memoria diversa per ogni istanza. Inoltre il test sarà molto più veloce ora perché non accederemo più al database. Inoltre, ora possiamo scrivere facilmente un test per il caso di errore. Come? Basta creare un'altra classe fake, implementata in questo modo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ExplodingOrderDatabase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">OrderDatabase</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="n">Order</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">Exception</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SelectAllOrders</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ok, fin qui tutto bene, ma ora abbiamo due classi di oggetti fake da mantenere (e probabilmente ne avremo bisogno ancora di più). Qualsiasi metodo aggiunto all'interfaccia <code class="docutils literal notranslate"><span class="pre">OrderDatabase</span></code> deve essere aggiunto anche a ciascuna di queste classi fake. Possiamo risparmiare parte della codifica rendendo i nostri mock un po' più generici in modo che il loro comportamento possa essere configurato utilizzando le espressioni lambda:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ConfigurableOrderDatabase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">OrderDatabase</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">Action</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="w"> </span><span class="n">doWhenInsertCalled</span><span class="p">;</span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">Func</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">doWhenSelectAllOrdersCalled</span><span class="p">;</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Insert</span><span class="p">(</span><span class="n">Order</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">doWhenInsertCalled</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SelectAllOrders</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nf">doWhenSelectAllOrdersCalled</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ora non dobbiamo creare classi aggiuntive per nuovi scenari, ma la nostra sintassi diventa scomoda. Ecco come configuriamo il database fake degli ordini per scrivere e restituire l'ordine inserito:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConfigurableOrderDatabase</span><span class="p">();</span>
<span class="n">Order</span><span class="w"> </span><span class="n">gotOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
<span class="n">db</span><span class="p">.</span><span class="n">doWhenInsertCalled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">gotOrder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">o</span><span class="p">;};</span>
<span class="n">db</span><span class="p">.</span><span class="n">doWhenSelectAllOrdersCalled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">gotOrder</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>E se vogliamo che sollevi un'eccezione quando viene inserito qualcosa:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConfigurableOrderDatabase</span><span class="p">();</span>
<span class="n">db</span><span class="p">.</span><span class="n">doWhenInsertCalled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Exception</span><span class="p">();};</span>
</pre></div>
</div>
<p>Per fortuna, alcuni programmatori intelligenti hanno creato librerie che forniscono ulteriore automazione in tali scenari. Una di queste librerie è <a class="reference external" href="http://nsubstitute.github.io/"><strong>NSubstitute</strong></a>. Fornisce un'API sotto forma di metodi di estensione di C#, motivo per cui all'inizio potrebbe sembrare un po' magico, soprattutto se non si ha familiarità col C#. Niente paura, ci si abituerà.</p>
<p>Utilizzando NSubstitute, il nostro primo test può essere riscritto come:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="n">ShouldInsertNewOrderToDatabaseWhenOrderisPlaced</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderDatabase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Substitute</span><span class="p">.</span><span class="n">For</span><span class="o">&lt;</span><span class="n">OrderDatabase</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderProcessing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderProcessing</span><span class="p">(</span><span class="n">orderDatabase</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileLog</span><span class="p">());</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Order</span><span class="p">(</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Grzesiek&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">surname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Galezowski&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">product</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Agile Acceptance Testing&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">date</span><span class="p">:</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">,</span>
<span class="w">    </span><span class="n">quantity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="n">orderProcessing</span><span class="p">.</span><span class="n">Place</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="n">orderDatabase</span><span class="p">.</span><span class="n">Received</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">Insert</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notare che non abbiamo più bisogno del metodo <code class="docutils literal notranslate"><span class="pre">SelectAllOrders()</span></code> sull'interfaccia di connessione al database. Era lì solo per rendere più semplice la scrittura del test: nessun codice di produzione lo utilizzava. Possiamo eliminare il metodo ed eliminare altri problemi di manutenzione. Invece della chiamata a <code class="docutils literal notranslate"><span class="pre">SelectAllOrders()</span></code>, i mock creati da NSubstitute registrano tutte le chiamate ricevute e ci permettono di usare su di esse un metodo speciale chiamato <code class="docutils literal notranslate"><span class="pre">Received()</span></code> (l'ultima riga di questo test), che in realtà è un'asserzione camuffata che controlla se il metodo <code class="docutils literal notranslate"><span class="pre">Insert()</span></code> è stato chiamato con l'oggetto order come parametro.</p>
<p>Questa spiegazione degli oggetti mock è molto superficiale e il suo scopo è solo quello di iniziare a lavorare. Torneremo ai mock più tardi poiché qui abbiamo solo scalfito la superficie.</p>
</section>
<section id="anonymous-values-generator">
<h2>Generatore di valori anonimi<a class="headerlink" href="#anonymous-values-generator" title="Link to this heading">¶</a></h2>
<p>Osservando i dati del test nella sezione precedente vediamo che molti valori sono specificati letteralmente, ad es. nel seguente codice:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Order</span><span class="p">(</span>
<span class="w">  </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Grzesiek&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="n">surname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Galezowski&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="n">product</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Agile Acceptance Testing&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="n">date</span><span class="p">:</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">,</span>
<span class="w">  </span><span class="n">quantity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>name, surname, product, date e quantity sono molto specifici. Ciò potrebbe suggerire che i valori esatti siano importanti dal punto di vista del comportamento che stiamo testando. D'altra parte, quando guardiamo di nuovo il codice testato:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Place</span><span class="p">(</span><span class="n">Order</span><span class="w"> </span><span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">try</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">orderDatabase</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">catch</span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">log</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;Could not insert an order. Reason: &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>possiamo notare che questi valori non vengono utilizzati da nessuna parte: la classe testata non li utilizza né li controlla in alcun modo. Questi valori sono importanti dal punto di vista del database, ma abbiamo già escluso il database vero e proprio. Non disturba il fatto che riempiamo l'oggetto ordine con così tanti valori che sono irrilevanti per la logica del test stesso e che ingombrano la struttura del test con dettagli inutili? Per rimuovere questa confusione, introduciamo un metodo con un nome descrittivo per creare l'ordine e nascondere i dettagli che non ci servono al lettore del test:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="n">ShouldInsertNewOrderToDatabase</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderDatabase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Substitute</span><span class="p">.</span><span class="n">For</span><span class="o">&lt;</span><span class="n">OrderDatabase</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderProcessing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderProcessing</span><span class="p">(</span><span class="n">orderDatabase</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileLog</span><span class="p">());</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AnonymousOrder</span><span class="p">();</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="n">orderProcessing</span><span class="p">.</span><span class="n">Place</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="n">orderDatabase</span><span class="p">.</span><span class="n">Received</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">Insert</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span><span class="w"> </span><span class="n">Order</span><span class="w"> </span><span class="nf">AnonymousOrder</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">Order</span><span class="p">(</span>
<span class="w">    </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Grzesiek&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">surname</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Galezowski&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">product</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Agile Acceptance Testing&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">date</span><span class="p">:</span><span class="w"> </span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">,</span>
<span class="w">    </span><span class="n">quantity</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Adesso va meglio. Non solo abbiamo abbreviato il test, ma abbiamo anche fornito al lettore un suggerimento sul fatto che i valori effettivi utilizzati per creare un ordine non contano dal punto di vista della logica testata dell'elaborazione degli ordini. Da qui il nome <code class="docutils literal notranslate"><span class="pre">AnonymousOrder()</span></code>.</p>
<p>A proposito, non sarebbe bello se non dovessimo fornire noi stessi gli oggetti anonimi, ma potessimo fare affidamento su un'altra libreria per generarli per noi? Sorpresa, sorpresa, ce n'è una! Si chiama <a class="reference external" href="https://github.com/AutoFixture/AutoFixture"><strong>Autofixture</strong></a>. È un esempio del cosiddetto generatore di valori anonimi (anche se al suo creatore piace dire che è anche un'implementazione del pattern Test Data Builder, ma evitiamo questa discussione qui).</p>
<p>Dopo aver modificato il nostro test per utilizzare AutoFixture, arriviamo a quanto segue:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">private</span><span class="w"> </span><span class="n">Fixture</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Fixture</span><span class="p">();</span>

<span class="na">[Fact]</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span>
<span class="n">ShouldInsertNewOrderToDatabase</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//GIVEN</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderDatabase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Substitute</span><span class="p">.</span><span class="n">For</span><span class="o">&lt;</span><span class="n">OrderDatabase</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">orderProcessing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">OrderProcessing</span><span class="p">(</span><span class="n">orderDatabase</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileLog</span><span class="p">());</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="c1">//WHEN</span>
<span class="w">  </span><span class="n">orderProcessing</span><span class="p">.</span><span class="n">Place</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>

<span class="w">  </span><span class="c1">//THEN</span>
<span class="w">  </span><span class="n">orderDatabase</span><span class="p">.</span><span class="n">Received</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">Insert</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In questo test, utilizziamo un'istanza di una classe <code class="docutils literal notranslate"><span class="pre">Fixture</span></code> (che fa parte di AutoFixture) per crearci dei valori anonimi tramite un metodo chiamato <code class="docutils literal notranslate"><span class="pre">Create()</span></code>. Questo ci consente di rimuovere il metodo <code class="docutils literal notranslate"><span class="pre">AnonymousOrder()</span></code>, rendendo così più breve la configurazione del nostro test.</p>
<p>Bello, eh? AutoFixture ha molte funzionalità avanzate, ma per semplificare le cose mi piace nasconderne l'utilizzo dietro una classe statica chiamata <code class="docutils literal notranslate"><span class="pre">Any</span></code>. L'implementazione più semplice di tale classe sarebbe simile a questa:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Any</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Fixture</span><span class="p">();</span>
<span class="w">  </span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">Instance</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">any</span><span class="p">.</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Nei prossimi capitoli vedremo molti metodi diversi dal tipo <code class="docutils literal notranslate"><span class="pre">Any</span></code>, oltre alla spiegazione completa della filosofia che sta dietro ad esso. Più usi questa classe, più cresce con altri metodi per creare oggetti personalizzati.</p>
</section>
<section id="summary">
<h2>Riepilogo<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>Questo capitolo ha introdotto i tre tool che utilizzeremo in questo libro che, una volta assimilati, renderanno più fluido il flusso di sviluppo basato sui test. Se questo capitolo non giustifica abbastanza il loro utilizzo, non c'è da preoccuparsi: approfondiremo la filosofia che sta dietro ad essi nei prossimi capitoli. Per ora, voglio solo che si acquisisca familiarità con gli strumenti stessi e la loro sintassi. Proseguiamo col download di questi tool, avviandoli, provando a scriverci qualcosa di semplice. Non è necessario che si capisca ancora il loro scopo completo, basta fare pratica :-).</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">TDD</a></h1>








<h3>Navigazione</h3>
<p class="caption" role="heading"><span class="caption-text">Contenuti:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Cover.html">Titolo</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Premessa</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html">Premessa</a></li>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html#dedications">Dediche</a></li>
<li class="toctree-l1"><a class="reference internal" href="015_Thanks.html">Grazie!</a></li>
<li class="toctree-l1"><a class="reference internal" href="017_CodeExamples.html">I codici di esempio</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 1:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="020_Part1Marker.html">Parte 1: Solo le nozioni di base</a></li>
<li class="toctree-l1"><a class="reference internal" href="030_Motivations.html">Motivazione: il primo passo per imparare il TDD</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><span class="xref myst">Gli strumenti essenziali</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#test-framework">Framework di test</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mocking-framework">Framework per il Mocking</a></li>
<li class="toctree-l2"><a class="reference internal" href="#anonymous-values-generator">Generatore di valori anonimi</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Riepilogo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="050_Its_Not_a_Test.html">Non è (solo) un test</a></li>
<li class="toctree-l1"><a class="reference internal" href="060_Statement_First_Programming.html">La programmazione Statement-first</a></li>
<li class="toctree-l1"><a class="reference internal" href="070_Practicing_What_We_Already_Learned.html">Mettere in pratica ciò che abbiamo già imparato</a></li>
<li class="toctree-l1"><a class="reference internal" href="080_Sorting_out_the_bits.html">Facciamo un po' d'ordine</a></li>
<li class="toctree-l1"><a class="reference internal" href="090_How_to_start.html">Come iniziare?</a></li>
<li class="toctree-l1"><a class="reference internal" href="100_Analysis_In_TDD.html">In che modo il TDD riguarda l'analisi e cosa significa &quot;GIVEN-WHEN-THEN&quot;?</a></li>
<li class="toctree-l1"><a class="reference internal" href="110_What_is_the_scope_of_a_Statement_in_TDD.html">Qual è lo scopo di uno Statement a livello di unità in TDD?</a></li>
<li class="toctree-l1"><a class="reference internal" href="120_Constrained_Non_Determinism.html">Sviluppare uno stile TDD e Non-Determinismo Vincolato</a></li>
<li class="toctree-l1"><a class="reference internal" href="130_Boundaries.html">Specificare i confini e le condizioni funzionali</a></li>
<li class="toctree-l1"><a class="reference internal" href="140_Triangulation.html">Guidare l'implementazione dalle Specifiche</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 2:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="150_Part2Marker.html">Parte 2: Il Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="160_Composable_Design.html">La Componibilità degli Oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="170_TellDoNotAsk.html"><span class="xref myst">Raccontare, non chiedere</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="180_Web_of_objects_explained.html">La necessità degli oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="190_Why_do_we_need_composability.html">Perché abbiamo bisogno della componibilità?</a></li>
<li class="toctree-l1"><a class="reference internal" href="200_What_does_it_mean_to_compose_objects.html">Reti, messaggi e protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="210_How_are_objects_composed.html">Comporre una rete di oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="211_When_are_objects_composed.html">Quando vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="212_How_are_the_connections_made.html">Come fa un mittente ad ottenere un riferimento a un destinatario (cioè come vengono stabilite le connessioni)?</a></li>
<li class="toctree-l1"><a class="reference internal" href="213_Where_are_objects_composed.html">Dove vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="220_Designing_for_composabiity_interfaces.html">Interfacce</a></li>
<li class="toctree-l1"><a class="reference internal" href="230_Designing_for_composabiity_protocols.html">Protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="235_Classes.html">Le Classi</a></li>
<li class="toctree-l1"><a class="reference internal" href="240_Refactoring_Object_Composition.html">Composizione di Oggetti come Linguaggio</a></li>
<li class="toctree-l1"><a class="reference internal" href="250_Value_Objects.html">Gli <em>Oggetti Valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="255_Value_Objects_properties.html">Anatomia del <em>oggetto valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="257_Value%20objects_general_topics.html">Aspetti del design degli <em>oggetti valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html">Oggetti di Trasferimento Dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-behavior">Disaccoppiamento mediante l'astrazione del comportamento</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-data">Disaccoppiamento mediante l'astrazione dei dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#use-both">Usare entrambi</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#dto-as-data-centric-decoupling-mechanism">DTO come meccanismo di disaccoppiamento incentrato sui dati</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 3:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="260_Part3Marker.html">Parte 3: TDD nel Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="270_Mock_Objects.html">Oggetti Mock come strumento di test</a></li>
<li class="toctree-l1"><a class="reference internal" href="280_Start_with_a_failing_test_mocks.html">Test-first  [<em>Testare prima</em>] utilizzando oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="290_NeedDrivenDevelopment.html">Il test-driving ai confini di input</a></li>
<li class="toctree-l1"><a class="reference internal" href="300_NeedDrivenRetrospective1.html">Il test-driving ai confini di input -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="310_Test_Driving_Factories.html">Creazione di oggetti &quot;test-driving&quot;</a></li>
<li class="toctree-l1"><a class="reference internal" href="320_Test_Driving_Factories_retrospective.html">Creazione di oggetti &quot;test-driving&quot; -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="330_Test-Driving_Command.html">Logica dell'applicazione test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="340_Test-Driving_Value_object.html"><em>Oggetti valore</em> nel test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="350_Web_of_objects_boundaries.html">Raggiungere la rete dei confini degli oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="360_Internals.html">Cosa c'è dentro l'oggetto?</a></li>
<li class="toctree-l1"><a class="reference internal" href="370_Design_smells.html">Odori del design visibile nella Specifica</a></li>
<li class="toctree-l1"><a class="reference internal" href="End.html">QUESTO È TUTTO QUELLO CHE HO PER ORA. QUELLO CHE SEGUE È MATERIALE GREZZO, NON ORDINATO, NON ANCORA PRONTO PER ESSERE CONSUMATO COME PARTE DI QUESTO TUTORIAL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 5:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html">Mock di oggetti come strumento di progettazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#guidance-of-test-smells">Guidaa ai test smells [<em>puzzolenti</em>]</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#revisiting-topics-from-chapter-1">Rivedere gli argomenti del capitolo 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#maintainable-mock-based-statements">Statement manutenibili basate su mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#refactoring-mock-code">Refactoring del codice mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-4-application-architecture">Parte 4: Architettura dell'applicazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#on-stable-architectural-boundaries">Sui confini stabili/architetturali</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#ports-and-adapters">[Port] e adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-application">Cosa entra in applicazione?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-ports">Cosa va nei [port]?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-5-tdd-on-application-architecture-level">Parte 5: TDD a livello di architettura applicativa</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#designing-automation-layer">Progettazione del layer di automazione</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 9:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="990_Further_reading.html"><span class="xref myst">Ulteriori Letture</span></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="030_Motivations.html" title="capitolo precedente">Motivazione: il primo passo per imparare il TDD</a></li>
      <li>Next: <a href="050_Its_Not_a_Test.html" title="capitolo successivo">Non è (solo) un test</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Ricerca veloce</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Vai" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Grzegorz GaÅ‚Ä™zowski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/manuscript/040_Three_Essential_Tools.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>