<!DOCTYPE html>

<html lang="it" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Le Classi &#8212; Documentazione TDD 2025 </title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=ad698211"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=45930005"></script>
    <link rel="index" title="Indice" href="../genindex.html" />
    <link rel="search" title="Cerca" href="../search.html" />
    <link rel="next" title="Composizione di Oggetti come Linguaggio" href="240_Refactoring_Object_Composition.html" />
    <link rel="prev" title="Protocolli" href="230_Designing_for_composabiity_protocols.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="classes">
<h1>Le Classi<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h1>
<p>Abbiamo già trattato interfacce e protocolli. Nella nostra ricerca della componibilità, dobbiamo considerare anche le classi. Classi:</p>
<ul class="simple">
<li><p>implementare le interfacce (ovvero recitare i ruoli)</p></li>
<li><p>comunicare tramite interfacce con altri servizi</p></li>
<li><p>seguire i protocolli in questa comunicazione</p></li>
</ul>
<p>Quindi, in un certo senso, ciò che è &quot;dentro&quot; una classe è un sottoprodotto di come gli oggetti di questa classe agiscono &quot;all'esterno&quot;. Tuttavia, ciò non significa che non ci sia nulla da dire sulle classi stesse che contribuisca a una migliore componibilità.</p>
<section id="single-responsibility-principle">
<h2>Principio di Responsabilità Unica<a class="headerlink" href="#single-responsibility-principle" title="Link to this heading">¶</a></h2>
<p>Ho già detto che vogliamo che il nostro sistema sia una rete di oggetti componibili. Un oggetto è un granello di componibilità -- non possiamo ad es. scollegare metà di un oggetto e collegarne un'altra metà. Pertanto, una domanda valida da porsi è: quanto dovrebbe essere grande un oggetto per rendere confortevole la componibilità -- per permetterci di scollegare tutta la logica che vogliamo, lasciando il resto intatto e pronto a funzionare con i nuovi destinatari che colleghiamo?</p>
<p>La risposta arriva con un <em>Principio di Responsabilità Unica</em> (&quot;Single Responsibility Principle&quot;, in breve: SRP) per le classi<a class="footnote-reference brackets" href="#srpmethods" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, che dice<a class="footnote-reference brackets" href="#srp" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<p>{{keyToDo}} Il codice di una classe dovrebbe avere un solo motivo per cambiare.</p>
<p>È stato scritto molto su questo principio sul web, quindi non ne saprò più saggio del motore di ricerca web (la mia ricerca recente ha prodotto oltre 74mila risultati). Tuttavia credo sia utile spiegare questo principio in termini di componibilità.</p>
<p>Di solito, la parte difficile di questo principio è come capire &quot;un motivo per cambiare&quot;. Robert C. Martin spiega<a class="footnote-reference brackets" href="#srponstackoverflow" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> che si tratta di un'unica fonte di entropia che genera modifiche alla classe. Il che ci porta ad un altro problema, quello di definire una &quot;fonte di entropia&quot;. Quindi penso che sia meglio fare solo un esempio.</p>
<section id="separating-responsibilities">
<h3>Separazione delle responsabilità<a class="headerlink" href="#separating-responsibilities" title="Link to this heading">¶</a></h3>
<p>Ricordate il codice utilizzato da Johnny e Benjamin per applicare i piani di incentivazione ai dipendenti? In caso contrario, eccolo qui (è solo un singolo metodo, non un'intera classe, ma dovrebbe essere sufficiente per le nostre esigenze):</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">ApplyYearlyIncentivePlan</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_repository</span><span class="p">.</span><span class="n">CurrentEmployees</span><span class="p">();</span>

<span class="w">  </span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">employees</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateRaise</span><span class="p">();</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateBonus</span><span class="p">();</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">Save</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Quindi... quanti motivi per cambiare ha questo pezzo di codice? Se non parlassimo di &quot;motivi per cambiare&quot; ma semplicemente di &quot;cambiamento&quot;, la risposta sarebbe &quot;molti&quot;. Ad esempio, qualcuno potrebbe decidere che non stiamo più dando aumenti e la riga <code class="docutils literal notranslate"><span class="pre">employee.EvaluateRaise()</span></code> scomparirebbe. Allo stesso modo, se si decidesse di non concedere bonus, la riga <code class="docutils literal notranslate"><span class="pre">employee.EvaluateBonus()</span></code> dovrebbe essere rimossa. Quindi, ci sono senza dubbio molti modi in cui questo metodo potrebbe cambiare. Ma sarebbe per ragioni diverse? In realtà no. Il motivo in entrambi i casi sarebbe (probabilmente) che l'amministratore delegato ha approvato un nuovo piano di incentivi. Quindi, esiste una &quot;fonte di entropia&quot; per questi due cambiamenti, sebbene ci siano molti modi in cui il codice può cambiare. Quindi, le due modifiche avvengono per lo stesso motivo.</p>
<p>Ora la parte più interessante della discussione: che ne dite di salvare i dipendenti? La ragione per cambiare il modo in cui salviamo i dipendenti è la stessa che per i bonus e le retribuzioni? Ad esempio, potremmo decidere di non salvare ciascun dipendente separatamente, perché ciò causerebbe un enorme carico di prestazioni sul nostro archivio dati, ma di salvarli insieme in un unico batch dopo aver terminato l'elaborazione dell'ultimo. Ciò fa sì che il codice cambi, ad es. come questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">ApplyYearlyIncentivePlan</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">var</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_repository</span><span class="p">.</span><span class="n">CurrentEmployees</span><span class="p">();</span>

<span class="w">  </span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">employees</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateRaise</span><span class="p">();</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateBonus</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//now all employees saved once</span>
<span class="w">  </span><span class="n">_repository</span><span class="p">.</span><span class="n">SaveAll</span><span class="p">(</span><span class="n">employees</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Quindi, come già intuito, il motivo di questo cambiamento è diverso da quello della modifica del piano di incentivi, quindi si tratta di una responsabilità separata e la logica per la lettura e l'archiviazione dei dipendenti dovrebbe essere separata da questa classe. Il metodo dopo la separazione e l'estrazione in una nuova classe sarebbe simile a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">ApplyYearlyIncentivePlanTo</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span><span class="w"> </span><span class="n">employees</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">employees</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateRaise</span><span class="p">();</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateBonus</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Nell'esempio sopra, abbiamo spostato la lettura e la scrittura dei dipendenti, in modo che siano gestite da un codice diverso, quindi le responsabilità sono separate. Disponiamo ora di un codice che aderisce al Principio di Responsabilità Unica? Possiamo, ma consideriamo questa situazione: la valutazione degli aumenti e dei bonus inizia a rallentare e, invece di farlo per tutti i dipendenti in un ciclo sequenziale <code class="docutils literal notranslate"><span class="pre">for</span></code>, preferiremmo parallelizzarlo per elaborare tutti i dipendenti contemporaneamente in un thread separato. Dopo aver applicato questa modifica, il codice potrebbe assomigliare a questo (utilizza un'API specifica di C# per il loop parallelo, ma spero di aver reso l'idea):</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">ApplyYearlyIncentivePlanTo</span><span class="p">(</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span><span class="w"> </span><span class="n">employees</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Parallel</span><span class="p">.</span><span class="n">ForEach</span><span class="p">(</span><span class="n">employees</span><span class="p">,</span><span class="w"> </span><span class="n">employee</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateRaise</span><span class="p">();</span>
<span class="w">    </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateBonus</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>È questo un nuovo motivo per cambiare? Ovviamente è! Le decisioni sulla parallelizzazione dell'elaborazione provengono da fonti diverse rispetto alle modifiche del piano di incentivi. Quindi, potremmo dire che abbiamo incontrato un'altra responsabilità e l'abbiamo separata. Il codice che rimane nel metodo <code class="docutils literal notranslate"><span class="pre">ApplyYearlyIncentivePlanTo()</span></code> ora assomiglia a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">ApplyYearlyIncentivePlanTo</span><span class="p">(</span><span class="n">Employee</span><span class="w"> </span><span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateRaise</span><span class="p">();</span>
<span class="w">  </span><span class="n">employee</span><span class="p">.</span><span class="n">EvaluateBonus</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Il looping, che è una responsabilità separata, è ora gestito da una classe diversa.</p>
</section>
<section id="how-far-do-we-go">
<h3>Fino a che punto andiamo?<a class="headerlink" href="#how-far-do-we-go" title="Link to this heading">¶</a></h3>
<p>L'esempio sopra pone alcune domande:</p>
<ol class="arabic simple">
<li><p>Possiamo raggiungere un punto in cui abbiamo separato tutte le responsabilità?</p></li>
<li><p>Se sì, come possiamo essere sicuri di averlo raggiunto?</p></li>
</ol>
<p>La risposta alla prima domanda è: probabilmente no. Sebbene alcune ragioni per cambiare siano dettate dal buon senso e altre possano essere tratte dalla nostra esperienza di sviluppatori o dalla conoscenza del del problema, ce ne sono sempre alcune che sono inaspettate e finché non emergono non possiamo prevederle. Pertanto, la risposta alla seconda domanda è: &quot;non c'è modo&quot;. Ciò non significa che non dovremmo cercare di separare le diverse ragioni che vediamo -- anzi. Semplicemente evitiamo di diventare troppo zelanti nel cercare di prevedere ogni possibile cambiamento.</p>
<p>Mi piace il confronto tra le responsabilità e il nostro utilizzo del tempo nella vita reale. Il tempo di infusione del tè nero è solitamente di circa tre-cinque minuti. Questo è quello che solitamente viene stampato sulla confezione che acquistiamo: &quot;3 --- 5 minuti&quot;. Nessuno fornisce il tempo in secondi, perché tale granularità non è necessaria. Se i secondi facessero una notevole differenza nel processo di preparazione del tè, probabilmente ci verrebbe dato il tempo in secondi. Ma non lo fanno. Quando valutiamo le attività nell'ingegneria del software, utilizziamo anche una granularità temporale diversa a seconda della necessità<a class="footnote-reference brackets" href="#storypoints" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> e la granularità diventa più fine quando raggiungiamo un punto in cui le differenze più piccole contano di più.</p>
<p>Allo stesso modo, un semplice programma software che stampa &quot;hello world&quot; sullo schermo potrebbe rientrare in un unico metodo &quot;main&quot; e probabilmente non lo vedremo come diverse responsabilità. Ma non appena riceviamo l'ordine di scrivere &quot;hello world&quot; nella lingua madre del sistema operativo attualmente in esecuzione, ottenere il testo diventa una responsabilità separata dal metterlo sullo schermo. Tutto dipende dalla granularità di cui abbiamo bisogno al momento (che, come accennato, può essere individuata dal codice o, in alcuni casi, nota in anticipo dalla nostra esperienza come sviluppatori o dalla conoscenza del dominio).</p>
</section>
<section id="the-mutual-relationship-between-the-single-responsibility-principle-and-composability">
<h3>Il rapporto reciproco tra &quot;Principio di Responsabilità Unica&quot; e componibilità<a class="headerlink" href="#the-mutual-relationship-between-the-single-responsibility-principle-and-composability" title="Link to this heading">¶</a></h3>
<p>Il motivo per cui scrivo tutto questo è che le responsabilità<a class="footnote-reference brackets" href="#rddandsrp" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> sono i veri granuli della componibilità. La componibilità degli oggetti di cui ho già parlato molto è un mezzo per raggiungere la componibilità delle responsabilità. Quindi questo è il nostro vero obiettivo. Se abbiamo due oggetti che collaborano, ciascuno con una singola responsabilità, possiamo facilmente sostituire il modo in cui la nostra applicazione raggiunge una di queste responsabilità senza toccare l'altra. Pertanto, gli oggetti conformi all'SRP [<em>Principio di Responsabilità Unica</em>] sono i più comodamente componibili e hanno le giuste dimensioni.<a class="footnote-reference brackets" href="#notrdd" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.</p>
<p>Un buon esempio da un altro terreno di gioco in cui la singola responsabilità va di pari passo con la componibilità è UNIX. UNIX è famoso per la sua raccolta di tool a riga di comando monouso, come <code class="docutils literal notranslate"><span class="pre">ls</span></code>, <code class="docutils literal notranslate"><span class="pre">grep</span></code>, <code class="docutils literal notranslate"><span class="pre">ps</span></code>, <code class="docutils literal notranslate"><span class="pre">sed</span></code> ecc. Lo scopo unico di queste utilità insieme alla capacità della riga di comando UNIX di passare un flusso di output di un comando al flusso di input di un altro utilizzando l'operatore &quot;|&quot; (pipe). Ad esempio, possiamo combinare tre comandi: <code class="docutils literal notranslate"><span class="pre">ls</span></code> (elenca il contenuto di una directory), <code class="docutils literal notranslate"><span class="pre">sort</span></code> (ordina l'input passato) e <code class="docutils literal notranslate"><span class="pre">more</span></code> (visualizza comodamente sullo schermo l'input che occupa più di uno schermo) in una pipeline:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ls<span class="w"> </span><span class="p">|</span><span class="w"> </span>sort<span class="w"> </span><span class="p">|</span><span class="w"> </span>more
</pre></div>
</div>
<p>Che mostra il contenuto ordinato della directory corrente per una visualizzazione più comoda. Questa filosofia di comporre un insieme di strumenti con un unico scopo in un insieme più complesso e più utile ed è ciò che cerchiamo, solo che nello sviluppo di software object-oriented utilizziamo oggetti invece di eseguibili. Ne parleremo meglio nel prossimo capitolo.</p>
</section>
</section>
<section id="static-recipients">
<h2>Destinatari statici<a class="headerlink" href="#static-recipients" title="Link to this heading">¶</a></h2>
<p>Sebbene i campi statici nel corpo di una classe a volte possano sembrare una buona idea di &quot;condividere&quot; i riferimenti dei destinatari tra le sue istanze e un modo intelligente per rendere il codice più &quot;efficiente in termini di memoria&quot;, il più delle volte danneggiano la componibilità. Diamo un'occhiata a un semplice esempio per avere un'idea di come i campi statici vincolano il nostro design.</p>
<section id="smtp-server">
<h3>Server SMTP<a class="headerlink" href="#smtp-server" title="Link to this heading">¶</a></h3>
<p>Immaginiamo di dover implementare un server di posta elettronica che riceva e invii messaggi SMTP<a class="footnote-reference brackets" href="#smtp" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>. Abbiamo una classe <code class="docutils literal notranslate"><span class="pre">OutboundSmtpMessage</span></code> che simboleggia i messaggi SMTP che inviamo ad altre parti. Per inviare il messaggio, dobbiamo codificarlo. Per ora, utilizziamo sempre una codifica chiamata <em>Quoted-Printable</em>, che è dichiarata in una classe separata chiamata <code class="docutils literal notranslate"><span class="pre">QuotedPrintableEncoding</span></code> e la classe <code class="docutils literal notranslate"><span class="pre">OutboundSmtpMessage</span></code> dichiara un campo privato di questo tipo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">OutboundSmtpMessage</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//... other code</span>
<span class="w">  </span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="n">Encoding</span><span class="w"> </span><span class="n">_encoding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">QuotedPrintableEncoding</span><span class="p">();</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//... other code</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Si noti che ogni messaggio possiede il proprio oggetto di codifica, quindi quando abbiamo, diciamo, 1.000.000 di messaggi in memoria, abbiamo anche la stessa quantità di oggetti di codifica.</p>
</section>
<section id="premature-optimization">
<h3>Ottimizzazione prematura<a class="headerlink" href="#premature-optimization" title="Link to this heading">¶</a></h3>
<p>Un giorno notiamo che è uno spreco per ogni messaggio definire il proprio oggetto di codifica poiché una codifica è un puro algoritmo e ogni utilizzo di questa codifica non influisce in alcun modo su ulteriori usi -- quindi possiamo anche avere una singola istanza e usarla in tutti i messaggi -- non causerà alcun conflitto. Inoltre, potrebbe farci risparmiare alcuni cicli della CPU, poiché creare una codifica ogni volta che creiamo un nuovo messaggio ha il suo costo in scenari ad alta produttività.</p>
<p>Ma come facciamo a condividere la codifica tra tutte le istanze? Il primo pensiero -- campi statici! Un campo statico sembra adatto allo scopo poiché ci fornisce esattamente ciò che vogliamo -- un singolo oggetto condiviso tra molte istanze della sua classe dichiarante. Spinti dalla nostra (presumibilmente) eccellente idea, modifichiamo la nostra classe di messaggi <code class="docutils literal notranslate"><span class="pre">OutboundSmtpMessage</span></code> per contenere l'istanza <code class="docutils literal notranslate"><span class="pre">QuotedPrintableEncoding</span></code> come campo statico:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">OutboundSmtpMessage</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">//... other code</span>
<span class="w">  </span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Encoding</span><span class="w"> </span><span class="n">_encoding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">QuotedPrintableEncoding</span><span class="p">();</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">//... other code</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ecco, abbiamo risolto il problema! Ma le nostre mamme non ci hanno detto di non ottimizzare prematuramente? Vabbè...</p>
</section>
<section id="welcome-change">
<h3>Benvenuto, cambiamento!<a class="headerlink" href="#welcome-change" title="Link to this heading">¶</a></h3>
<p>Un giorno si scopre che nei nostri messaggi dobbiamo supportare non solo la codifica Quoted-Printable ma anche un'altra, chiamata <em>Base64</em>. Col nostro nostro design attuale, non possiamo farlo perché, come risultato dell'utilizzo di un campo statico, una singola codifica è condivisa tra tutti i messaggi. Pertanto, se modifichiamo la codifica per un messaggio che richiede la codifica Base64, cambierà anche la codifica per i messaggi che richiedono Quoted-Printable. In questo modo, limitiamo la componibilità con questa ottimizzazione prematura -- non possiamo comporre ciascun messaggio con la codifica che desideriamo. Tutti i messaggi utilizzano una codifica o un'altra. Una conclusione logica è che nessuna istanza di tale classe è indipendente dal contesto -- non può ottenere il proprio contesto, ma piuttosto il contesto le viene imposto.</p>
</section>
<section id="so-what-about-optimizations">
<h3>E per quanto riguarda le ottimizzazioni?<a class="headerlink" href="#so-what-about-optimizations" title="Link to this heading">¶</a></h3>
<p>Siamo condannati a tornare alla soluzione precedente per avere una codifica per ciascun messaggio? E se questo diventasse davvero un problema di prestazioni o di memoria? La nostra osservazione che non è necessario creare la stessa codifica molte volte è inutile?</p>
<p>Niente affatto. Possiamo ancora utilizzare questa osservazione e ottenere molti (anche se non tutti) dei vantaggi di un campo statico. Come lo facciamo? Come possiamo ottenere la condivisione degli encoding senza i vincoli di un campo statico? Bene, abbiamo già risposto a questa domanda qualche capitolo fa -- assegnare a ciascun messaggio una codifica tramite il suo costruttore. In questo modo, possiamo passare la stessa codifica a moltissime istanze <code class="docutils literal notranslate"><span class="pre">OutboundSmtpMessage</span></code>, ma se vogliamo, possiamo sempre creare un messaggio a cui è passata un'altra codifica. Utilizzando questa idea, proveremo a ottenere la condivisione delle codifiche creando una singola istanza di ciascuna codifica nella <em>composition root</em> e facendola passare a un messaggio tramite il suo costruttore.</p>
<p>Esaminiamo questa soluzione. Innanzitutto, dobbiamo creare una codifica per ciascuna codifica nella &quot;composition root&quot;, in questo modo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// We are in a composition root!</span>

<span class="c1">//...some initialization</span>

<span class="kt">var</span><span class="w"> </span><span class="n">base64Encoding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Base64Encoding</span><span class="p">();</span>
<span class="kt">var</span><span class="w"> </span><span class="n">quotedPrintableEncoding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">QuotedPrintableEncoding</span><span class="p">();</span>

<span class="c1">//...some more initialization</span>
</pre></div>
</div>
<p>Ok, le codifiche vengono create, ma dobbiamo ancora passarle ai messaggi. Nel nostro caso, dobbiamo creare un nuovo oggetto <code class="docutils literal notranslate"><span class="pre">OutboundSmtpMessage</span></code> nel momento in cui dobbiamo inviare un nuovo messaggio, ovvero su richiesta, quindi abbiamo bisogno di una factory per produrre gli oggetti del messaggio. Questa factory può (e deve) essere creata nella &quot;composition root&quot;. Quando creiamo la factory, possiamo passare entrambe le codifiche al suo costruttore come contesto globale (ricordate che le factory incapsulano il contesto globale?):</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// We are in a composition root!</span>

<span class="c1">//...some initialization</span>

<span class="kt">var</span><span class="w"> </span><span class="n">messageFactory</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StmpMessageFactory</span><span class="p">(</span><span class="n">base64Encoding</span><span class="p">,</span><span class="w"> </span><span class="n">quotedPrintableEncoding</span><span class="p">);</span>

<span class="c1">//...some more initialization</span>
</pre></div>
</div>
<p>La factory stessa può essere utilizzata per la creazione di messaggi on-demand di cui abbiamo parlato. Poiché la factory riceve entrambe le codifiche tramite il suo costruttore, può memorizzarle come campi privati e passare quella appropriata all'oggetto messaggio che crea:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">SmtpMessageFactory</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">MessageFactory</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="n">Encoding</span><span class="w"> </span><span class="n">_quotedPrintable</span><span class="p">;</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="n">Encoding</span><span class="w"> </span><span class="n">_base64</span><span class="p">;</span>
<span class="w">  </span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="nf">SmtpMessageFactory</span><span class="p">(</span>
<span class="w">    </span><span class="n">Encoding</span><span class="w"> </span><span class="n">quotedPrintable</span><span class="p">,</span>
<span class="w">    </span><span class="n">Encoding</span><span class="w"> </span><span class="n">base64</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">_quotedPrintable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quotedPrintable</span><span class="p">;</span>
<span class="w">    </span><span class="n">_base64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base64</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
<span class="w">  </span><span class="k">public</span><span class="w"> </span><span class="n">Message</span><span class="w"> </span><span class="nf">CreateFrom</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">content</span><span class="p">,</span><span class="w"> </span><span class="n">MessageLanguage</span><span class="w"> </span><span class="n">language</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">language</span><span class="p">.</span><span class="n">IsLatinBased</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">//each message gets the same instance of encoding:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">StmpMessage</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="w"> </span><span class="n">_quotedPrintable</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">//each message gets the same instance of encoding:</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">StmpMessage</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="w"> </span><span class="n">_base64</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span><span class="w">  </span>
</pre></div>
</div>
<p>Le prestazioni e il risparmio di memoria non sono esattamente così grandi come quando si utilizza un campo statico (ad esempio, ciascuna istanza <code class="docutils literal notranslate"><span class="pre">OutboundSmtpMessage</span></code> deve memorizzare un riferimento separato alla codifica ricevuta), ma rappresenta comunque un enorme miglioramento rispetto alla creazione di un oggetto di codifica separato per ogni messaggio.</p>
</section>
<section id="where-statics-work">
<h3>Dove funziona la statica?<a class="headerlink" href="#where-statics-work" title="Link to this heading">¶</a></h3>
<p>Ciò che ho scritto non significa che le cose static non abbiano la loro utilità. Lo fanno, ma questi usi sono molto specifici. Vi mostrerò uno di questi usi nei prossimi capitoli dopo aver introdotto gli <em>oggetti valore</em>.</p>
</section>
</section>
<section id="summary">
<h2>Riepilogo<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>In questo capitolo ho provato a darvi qualche consiglio sulla progettazione di classi che non emergano in modo così naturale dal concetto di componibilità e interazioni come quelli descritti nei capitoli precedenti. Tuttavia, come spero di essere riuscito a dimostrare, migliorano la componibilità e sono preziosi.</p>
</section>
</section>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="srpmethods" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Questo principio può essere applicato anche ai metodi, ma non tratteremo questa parte, perché non è direttamente legata al concetto di componibilità e questo non è un libro di design ;-).</p>
</aside>
<aside class="footnote brackets" id="srp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod.</p>
</aside>
<aside class="footnote brackets" id="srponstackoverflow" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>https://stackoverflow.fogbugz.com/default.asp?W29030</p>
</aside>
<aside class="footnote brackets" id="storypoints" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>A condizione che non utilizziamo una misura come gli story point.</p>
</aside>
<aside class="footnote brackets" id="rddandsrp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>Si noti che sto scrivendo sulla responsabilità in termini di &quot;Principio di Responsabilità Unica&quot;. Nella &quot;<em>Responsibility-Driven Design</em>&quot;, responsabilità significa qualcosa di diverso. Vedere <a class="reference external" href="http://www.wirfs-brock.com/PDFs/PrinciplesInPractice.pdf">il chiarimento di Rebecca Wirfs-Brock</a>.</p>
</aside>
<aside class="footnote brackets" id="notrdd" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">6</a><span class="fn-bracket">]</span></span>
<p>Si noti che sto parlando di responsabilità nel modo in cui ne parla SRP, non nel modo in cui vengono intese, ad es. Responsibility-Driven Design. Pertanto, sto parlando delle responsabilità di una classe, non delle responsabilità della sua API.</p>
</aside>
<aside class="footnote brackets" id="smtp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p>SMTP sta per Simple Mail Transfer Protocol ed è un protocollo standard per l'invio e la ricezione di posta elettronica. Ulteriori informazioni su <a class="reference external" href="https://it.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol">Wikipedia</a>.</p>
</aside>
</aside>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">TDD</a></h1>








<h3>Navigazione</h3>
<p class="caption" role="heading"><span class="caption-text">Contenuti:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Cover.html">Titolo</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Premessa</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html">Premessa</a></li>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html#dedications">Dediche</a></li>
<li class="toctree-l1"><a class="reference internal" href="015_Thanks.html">Grazie!</a></li>
<li class="toctree-l1"><a class="reference internal" href="017_CodeExamples.html">I codici di esempio</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 1:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="020_Part1Marker.html">Parte 1: Solo le nozioni di base</a></li>
<li class="toctree-l1"><a class="reference internal" href="030_Motivations.html">Motivazione: il primo passo per imparare il TDD</a></li>
<li class="toctree-l1"><a class="reference internal" href="040_Three_Essential_Tools.html"><span class="xref myst">Gli strumenti essenziali</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="050_Its_Not_a_Test.html">Non è (solo) un test</a></li>
<li class="toctree-l1"><a class="reference internal" href="060_Statement_First_Programming.html">La programmazione Statement-first</a></li>
<li class="toctree-l1"><a class="reference internal" href="070_Practicing_What_We_Already_Learned.html">Mettere in pratica ciò che abbiamo già imparato</a></li>
<li class="toctree-l1"><a class="reference internal" href="080_Sorting_out_the_bits.html">Facciamo un po' d'ordine</a></li>
<li class="toctree-l1"><a class="reference internal" href="090_How_to_start.html">Come iniziare?</a></li>
<li class="toctree-l1"><a class="reference internal" href="100_Analysis_In_TDD.html">In che modo il TDD riguarda l'analisi e cosa significa &quot;GIVEN-WHEN-THEN&quot;?</a></li>
<li class="toctree-l1"><a class="reference internal" href="110_What_is_the_scope_of_a_Statement_in_TDD.html">Qual è lo scopo di uno Statement a livello di unità in TDD?</a></li>
<li class="toctree-l1"><a class="reference internal" href="120_Constrained_Non_Determinism.html">Sviluppare uno stile TDD e Non-Determinismo Vincolato</a></li>
<li class="toctree-l1"><a class="reference internal" href="130_Boundaries.html">Specificare i confini e le condizioni funzionali</a></li>
<li class="toctree-l1"><a class="reference internal" href="140_Triangulation.html">Guidare l'implementazione dalle Specifiche</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 2:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="150_Part2Marker.html">Parte 2: Il Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="160_Composable_Design.html">La Componibilità degli Oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="170_TellDoNotAsk.html"><span class="xref myst">Raccontare, non chiedere</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="180_Web_of_objects_explained.html">La necessità degli oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="190_Why_do_we_need_composability.html">Perché abbiamo bisogno della componibilità?</a></li>
<li class="toctree-l1"><a class="reference internal" href="200_What_does_it_mean_to_compose_objects.html">Reti, messaggi e protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="210_How_are_objects_composed.html">Comporre una rete di oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="211_When_are_objects_composed.html">Quando vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="212_How_are_the_connections_made.html">Come fa un mittente ad ottenere un riferimento a un destinatario (cioè come vengono stabilite le connessioni)?</a></li>
<li class="toctree-l1"><a class="reference internal" href="213_Where_are_objects_composed.html">Dove vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="220_Designing_for_composabiity_interfaces.html">Interfacce</a></li>
<li class="toctree-l1"><a class="reference internal" href="230_Designing_for_composabiity_protocols.html">Protocolli</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Le Classi</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#single-responsibility-principle">Principio di Responsabilità Unica</a></li>
<li class="toctree-l2"><a class="reference internal" href="#static-recipients">Destinatari statici</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Riepilogo</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="240_Refactoring_Object_Composition.html">Composizione di Oggetti come Linguaggio</a></li>
<li class="toctree-l1"><a class="reference internal" href="250_Value_Objects.html">Gli <em>Oggetti Valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="255_Value_Objects_properties.html">Anatomia del <em>oggetto valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="257_Value%20objects_general_topics.html">Aspetti del design degli <em>oggetti valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html">Oggetti di Trasferimento Dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-behavior">Disaccoppiamento mediante l'astrazione del comportamento</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-data">Disaccoppiamento mediante l'astrazione dei dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#use-both">Usare entrambi</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#dto-as-data-centric-decoupling-mechanism">DTO come meccanismo di disaccoppiamento incentrato sui dati</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 3:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="260_Part3Marker.html">Parte 3: TDD nel Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="270_Mock_Objects.html">Oggetti Mock come strumento di test</a></li>
<li class="toctree-l1"><a class="reference internal" href="280_Start_with_a_failing_test_mocks.html">Test-first  [<em>Testare prima</em>] utilizzando oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="290_NeedDrivenDevelopment.html">Il test-driving ai confini di input</a></li>
<li class="toctree-l1"><a class="reference internal" href="300_NeedDrivenRetrospective1.html">Il test-driving ai confini di input -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="310_Test_Driving_Factories.html">Creazione di oggetti &quot;test-driving&quot;</a></li>
<li class="toctree-l1"><a class="reference internal" href="320_Test_Driving_Factories_retrospective.html">Creazione di oggetti &quot;test-driving&quot; -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="330_Test-Driving_Command.html">Logica dell'applicazione test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="340_Test-Driving_Value_object.html"><em>Oggetti valore</em> nel test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="350_Web_of_objects_boundaries.html">Raggiungere la rete dei confini degli oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="360_Internals.html">Cosa c'è dentro l'oggetto?</a></li>
<li class="toctree-l1"><a class="reference internal" href="370_Design_smells.html">Odori del design visibile nella Specifica</a></li>
<li class="toctree-l1"><a class="reference internal" href="End.html">QUESTO È TUTTO QUELLO CHE HO PER ORA. QUELLO CHE SEGUE È MATERIALE GREZZO, NON ORDINATO, NON ANCORA PRONTO PER ESSERE CONSUMATO COME PARTE DI QUESTO TUTORIAL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 5:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html">Mock di oggetti come strumento di progettazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#guidance-of-test-smells">Guidaa ai test smells [<em>puzzolenti</em>]</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#revisiting-topics-from-chapter-1">Rivedere gli argomenti del capitolo 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#maintainable-mock-based-statements">Statement manutenibili basate su mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#refactoring-mock-code">Refactoring del codice mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-4-application-architecture">Parte 4: Architettura dell'applicazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#on-stable-architectural-boundaries">Sui confini stabili/architetturali</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#ports-and-adapters">[Port] e adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-application">Cosa entra in applicazione?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-ports">Cosa va nei [port]?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-5-tdd-on-application-architecture-level">Parte 5: TDD a livello di architettura applicativa</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#designing-automation-layer">Progettazione del layer di automazione</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 9:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="990_Further_reading.html"><span class="xref myst">Ulteriori Letture</span></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="230_Designing_for_composabiity_protocols.html" title="capitolo precedente">Protocolli</a></li>
      <li>Next: <a href="240_Refactoring_Object_Composition.html" title="capitolo successivo">Composizione di Oggetti come Linguaggio</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Ricerca veloce</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Vai" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Grzegorz GaÅ‚Ä™zowski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/manuscript/235_Classes.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>