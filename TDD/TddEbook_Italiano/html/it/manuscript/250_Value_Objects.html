<!DOCTYPE html>

<html lang="it" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Gli Oggetti Valore &#8212; Documentazione TDD 2025 </title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=ad698211"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=45930005"></script>
    <link rel="index" title="Indice" href="../genindex.html" />
    <link rel="search" title="Cerca" href="../search.html" />
    <link rel="next" title="Anatomia del oggetto valore" href="255_Value_Objects_properties.html" />
    <link rel="prev" title="Composizione di Oggetti come Linguaggio" href="240_Refactoring_Object_Composition.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="value-objects">
<h1>Gli <em>Oggetti Valore</em><a class="headerlink" href="#value-objects" title="Link to this heading">¶</a></h1>
<p>In diversi capitoli ho parlato della composizione di oggetti in una rete in cui la vera implementazione era nascosta esponendo solo le interfacce. Questi oggetti si scambiavano messaggi e modellavano ruoli nel nostro dominio.</p>
<p>Tuttavia, questa è solo una parte dell'approccio object-oriented agli oggetti che sto cercando di spiegare. Un'altra parte del mondo object-oriented , complementare a ciò di cui abbiamo parlato, sono gli <em>oggetti valore</em>. Hanno una propria serie di vincoli e idee di progettazione, quindi la maggior parte dei concetti dei capitoli precedenti non si applicano a loro o si applicano in modo diverso.</p>
<section id="what-is-a-value-object">
<h2>Cos'è un <em>oggetto valore</em>?<a class="headerlink" href="#what-is-a-value-object" title="Link to this heading">¶</a></h2>
<p>In breve, i valori sono solitamente visti come quantità immutabili, misure<a class="footnote-reference brackets" href="#goosvalues" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> o altri oggetti che vengono confrontati in base al loro contenuto, non alla loro identità. Sono presenti alcuni esempi di valori nelle librerie dei nostri linguaggi di programmazione. Ad esempio, la classe <code class="docutils literal notranslate"><span class="pre">String</span></code> in Java o in C# è un oggetto valore perché è immutabile e ogni due stringhe sono considerate uguali quando contengono gli stessi dati. Altri esempi sono i tipi primitivi nativi nella maggior parte dei linguaggi di programmazione, come numeri o caratteri.</p>
<p>La maggior parte dei valori forniti con le librerie general-purpose sono piuttosto primitivi o generali. Ci sono molte volte, tuttavia, in cui vogliamo modellare un'astrazione di dominio come un <em>oggetto valore</em>. Alcuni esempi includono data e ora (che oggigiorno di solito fanno parte della libreria standard, perché è utilizzabile in tanti domini), denaro, temperatura, ma anche cose come path di file o identificatori di risorse.</p>
<p>Come già notato leggendo questo libro, sono davvero pessimo nello spiegare le cose senza esempi, quindi eccone uno:</p>
</section>
<section id="example-money-and-names">
<h2>Esempio: soldi e nomi<a class="headerlink" href="#example-money-and-names" title="Link to this heading">¶</a></h2>
<p>Immaginiamo di sviluppare un negozio web per un cliente. Esistono diversi tipi di prodotti in vendita e il cliente desidera avere la possibilità di aggiungere di nuovi.</p>
<p>Ogni prodotto ha almeno due attributi importanti: nome e prezzo (ce ne sono altri come la quantità, ma per ora lasciamoli stare).</p>
<p>Ora, immaginiamo come si modellerebbero queste due cose: il nome sarebbe modellato come una semplice <code class="docutils literal notranslate"><span class="pre">string</span></code> e il prezzo sarebbe di tipo <code class="docutils literal notranslate"><span class="pre">double</span></code> o <code class="docutils literal notranslate"><span class="pre">decimal</span></code>?</p>
<p>Diciamo che abbiamo effettivamente deciso di utilizzare un <code class="docutils literal notranslate"><span class="pre">decimal</span></code> per contenere un prezzo e una <code class="docutils literal notranslate"><span class="pre">string</span></code> per contenere un nome. Notare che entrambi sono tipi di libreria generici, non collegati ad alcun dominio. È una buona scelta utilizzare i &quot;tipi della libreria&quot; per le astrazioni del dominio? Lo scopriremo presto...</p>
<section id="time-passes">
<h3>Il tempo passa...<a class="headerlink" href="#time-passes" title="Link to this heading">¶</a></h3>
<p>Un giorno si scopre che questi valori devono essere condivisi tra diversi sottodomini del sistema. Per esempio:</p>
<ol class="arabic simple">
<li><p>Il sito web deve visualizzarli</p></li>
<li><p>Sono utilizzati nei calcoli dei ricavi</p></li>
<li><p>Vengono presi in considerazione nella definizione e nella verifica delle regole di sconto (ad esempio &quot;compra tre, paghi due&quot;)</p></li>
<li><p>Devono essere forniti durante la stampa delle fatture</p></li>
</ol>
<p>ecc.</p>
<p>Il codice diventa sempre più grande e, poiché i concetti di nome del prodotto e prezzo sono tra quelli principali dell'applicazione, tendono ad arrivare in molti posti.</p>
</section>
<section id="change-request">
<h3>Richiesta di modifica<a class="headerlink" href="#change-request" title="Link to this heading">¶</a></h3>
<p>Ora, immaginiamo che uno dei seguenti cambiamenti debba farsi strada nel sistema:</p>
<ol class="arabic simple">
<li><p>Il nome del prodotto deve essere confrontato senza distinzione tra maiuscole e minuscole poiché i nomi dei prodotti sono sempre stampati in maiuscolo sulla fattura. Pertanto, creando due prodotti che differiscono solo per la lettera maiuscola (es. &quot;laptop&quot; e &quot;LAPTOP&quot;) confonderebbero i clienti poiché entrambi i prodotti appaiono uguali sulla fattura. Inoltre, l'unico modo per creare due prodotti che differiscono solo per le lettere è per errore e vogliamo evitarlo.</p></li>
<li><p>Il nome del prodotto non è sufficiente per differenziare un prodotto. Ad esempio, i produttori di PC hanno gli stessi modelli di notebook in diverse configurazioni (ad esempio diversa quantità di RAM o diversi modelli di processore all'interno). Quindi ogni prodotto riceverà un identificativo aggiuntivo di cui si dovrà tenere conto durante i confronti.</p></li>
<li><p>Per supportare i clienti di paesi diversi, è necessario supportare nuove valute.</p></li>
</ol>
<p>Nella situazione attuale, questi cambiamenti sono laboriosi da apportare. Perché? È perché abbiamo utilizzato i tipi primitivi per rappresentare le cose che avrebbero dovuto cambiare, il che significa che siamo accoppiati in più punti a una particolare implementazione del nome del prodotto (<code class="docutils literal notranslate"><span class="pre">string</span></code>) e a una particolare implementazione del denaro (ad esempio <code class="docutils literal notranslate"><span class="pre">decimal</span></code>) . Non sarebbe poi così male, se non fosse per il fatto che siamo vincolati all'implementazione e non possiamo cambiare!</p>
<p>Siamo condannati a convivere con problemi del genere nel nostro codice e non possiamo farci nulla? Scopriamolo esplorando le opzioni a nostra disposizione.</p>
<p>D'ora in poi mettiamo da parte il concetto di denaro e concentriamoci solo sul nome del prodotto, poiché sia nome che prezzo sono casi simili con soluzioni simili, quindi ci basta considerarne solo uno.</p>
</section>
<section id="what-options-do-we-have-to-address-product-name-changes">
<h3>Quali opzioni abbiamo per affrontare le modifiche al nome del prodotto?<a class="headerlink" href="#what-options-do-we-have-to-address-product-name-changes" title="Link to this heading">¶</a></h3>
<p>Per supportare i nuovi requisiti, dobbiamo trovare tutti i posti in cui utilizziamo il nome del prodotto (a proposito, un IDE non ci aiuterà molto in questa ricerca, perché cercheremmo tutte le occorrenze del tipo <code class="docutils literal notranslate"><span class="pre">string</span></code>) e fare la stessa modifica. Ogni volta che dobbiamo fare qualcosa del genere (ovvero dobbiamo apportare la stessa modifica in più posti e c'è una possibilità diversa da zero di perdere almeno uno di quei posti), significa che abbiamo introdotto la ridondanza. Ricordate? Abbiamo parlato di ridondanza parlando di factory e abbiamo accennato al fatto che la ridondanza riguarda una duplicazione concettuale che ci costringe a apportare lo stesso cambiamento (non letteralmente, ma concettualmente) in diversi luoghi.</p>
<p>Al Shalloway ha coniato una &quot;legge&quot; divertente sulla ridondanza, chiamata <em>La Legge di Shalloway</em>, che dice:</p>
<blockquote>
<div><p>Ogni volta che la stessa modifica deve essere applicata in N posti e N &gt; 1, Shalloway troverà al massimo N-1 di tali posti.</p>
</div></blockquote>
<p>Un esempio di applicazione di questa legge potrebbe essere:</p>
<blockquote>
<div><p>Ogni volta che è necessario applicare la stessa modifica in 4 posti, Shalloway ne troverà al massimo 3.</p>
</div></blockquote>
<p>Prendendosi in giro, Al ha descritto qualcosa che vedo comune a me e ad altri programmatori: che la duplicazione concettuale ci rende vulnerabili e quando ci abbiamo a che fare, non abbiamo strumenti avanzati per aiutarci, solo la nostra memoria e pazienza.</p>
<p>Per fortuna, ci sono diversi modi per affrontare questa ridondanza. Alcuni di essi sono migliori e altri peggiori<a class="footnote-reference brackets" href="#everydecisionistradeoff" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<section id="option-one-just-modify-the-implementation-in-all-places">
<h4>Opzione uno: modificare semplicemente l'implementazione in tutti i punti<a class="headerlink" href="#option-one-just-modify-the-implementation-in-all-places" title="Link to this heading">¶</a></h4>
<p>Questa opzione consiste nel lasciare la ridondanza dov'è e apportare semplicemente la modifica in tutti i punti, sperando che questa sia l'ultima volta che cambiamo qualcosa riguardo al nome del prodotto.</p>
<p>Quindi diciamo che vogliamo aggiungere il confronto ignorando le maiuscole. Questa opzione ci porterebbe a trovare tutti i posti in cui facciamo qualcosa del genere:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">productName</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">productName2</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">..</span>
</pre></div>
</div>
<p>o</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="n">productName</span><span class="p">,</span><span class="w"> </span><span class="n">productName2</span><span class="p">))</span>
<span class="p">{</span>
<span class="p">..</span>
</pre></div>
</div>
<p>Cambiandoli in un confronto che ignori maiuscole e minuscole, ad esempio:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="n">productName</span><span class="p">,</span><span class="w"> </span><span class="n">productName2</span><span class="p">,</span>
<span class="w">   </span><span class="n">StringComparison</span><span class="p">.</span><span class="n">OrdinalIgnoreCase</span><span class="p">))</span>
<span class="p">{</span>
<span class="p">..</span>
</pre></div>
</div>
<p>Questo risolve il problema, almeno per ora, ma a lungo termine può causare qualche problema:</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://www.netobjectives.com/blogs/shalloway%E2%80%99s-law-and-shalloway%E2%80%99s-principle">Sarà molto difficile</a> trovare tutti questi posti e le possibilità sono che se ne perderà almeno uno. Questo è un modo semplice per far sì che un bug possa insinuarsi.</p></li>
<li><p>Anche se questa volta si sarà in grado di trovare e correggere tutti i posti, ogni volta che cambia la logica del dominio per i confronti dei nomi dei prodotti (ad esempio, dovremo utilizzare l'opzione <code class="docutils literal notranslate"><span class="pre">InvariantIgnoreCase</span></code> invece di <code class="docutils literal notranslate"><span class="pre">OrdinalIgnoreCase</span></code>per qualche motivo, o gestire il caso menzionato prima in cui il confronto include un identificatore di un prodotto), lo si dovrà rifare. E la legge di Shalloway si applica ogni volta allo stesso modo. In altre parole, le cose non stanno migliorando.</p></li>
<li><p>Chiunque in futuro aggiunga nuova logica per confrontare i nomi dei prodotti dovrà ricordare che in tali confronti maiuscole e minuscole vengono ignorate. Pertanto, dovranno tenere presente che dovrebbero utilizzare l'opzione <code class="docutils literal notranslate"><span class="pre">OrdinalIgnoreCase</span></code> ogni volta che aggiungono nuovi confronti da qualche parte nel codice. La mia opinione è che, la violazione accidentale di questa convenzione in un team che ha dimensioni adeguate o un tasso di turnover del personale superiore al minimo è solo questione di tempo.</p></li>
<li><p>Inoltre, ci sono altri cambiamenti che saranno legati al concetto di uguaglianza dei nomi dei prodotti in modo diverso (ad esempio, i set di hash e le tabelle hash utilizzano codici hash per aiutare a trovare gli oggetti giusti) e si dovranno trovare quei posti e apportare modifiche anche lì.</p></li>
</ol>
<p>Quindi, come si vede, questo approccio non migliora le cose. È proprio questo approccio che ci ha portato al problema che stiamo cercando di risolvere.</p>
</section>
<section id="option-two-use-a-helper-class">
<h4>Opzione due - utilizzare una classe helper<a class="headerlink" href="#option-two-use-a-helper-class" title="Link to this heading">¶</a></h4>
<p>Possiamo affrontare i problemi #1 e #2 dell'elenco precedente (ovvero la necessità di cambiare più posizioni quando cambia la logica di confronto dei nomi dei prodotti) spostando questo confronto in un metodo helper statico di una classe helper (chiamiamolo semplicemente <code class="docutils literal notranslate"><span class="pre">ProductNameComparison</span></code>) e rendere questo metodo un unico posto in grado di confrontare i nomi dei prodotti. Ciò farebbe sì che ciascuno dei punti del codice in cui è necessario effettuare il confronto assomigli a questo:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">ProductNameComparison</span><span class="p">.</span><span class="n">AreEqual</span><span class="p">(</span><span class="n">productName</span><span class="p">,</span><span class="w"> </span><span class="n">productName2</span><span class="p">))</span>
<span class="p">{</span>
<span class="p">..</span>
</pre></div>
</div>
<p>Si noti che i dettagli su cosa significa confrontare due nomi di prodotto sono ora nascosti all'interno del metodo statico <code class="docutils literal notranslate"><span class="pre">AreEqual()</span></code> appena creato. Questo metodo è diventato l'unico posto che conosce questi dettagli e ogni volta che è necessario cambiare il confronto, dobbiamo modificare solo questo metodo. Il resto del codice chiama semplicemente questo metodo senza sapere cosa fa, quindi non sarà necessario modificarlo. Questo ci libera dalla necessità di cercare e modificare questo codice ogni volta che cambia la logica di confronto.</p>
<p>Tuttavia, anche se ci protegge dal cambiamento della logica di confronto, non è ancora sufficiente. Perché? Perché il concetto di nome di prodotto non è ancora incapsulato - un nome di prodotto è ancora una <code class="docutils literal notranslate"><span class="pre">string</span></code> e ci consente di farci tutto ciò che possiamo fare con qualsiasi altra <code class="docutils literal notranslate"><span class="pre">string</span></code>, anche quando non ha senso per i nomi dei prodotti. Questo perché, nel dominio del problema, i nomi dei prodotti non sono sequenze di caratteri (come lo sono le <code class="docutils literal notranslate"><span class="pre">string</span></code>), ma un'astrazione con uno speciale insieme di regole ad essa applicabili. Non riuscendo a modellare questa astrazione in modo appropriato, possiamo imbatterci in una situazione in cui un altro sviluppatore che inizia ad aggiungere del nuovo codice potrebbe non notare nemmeno che i nomi dei prodotti devono essere confrontati in modo diverso rispetto ad altre stringhe e utilizzare semplicemente il confronto predefinito di un tipo <code class="docutils literal notranslate"><span class="pre">string</span></code>.</p>
<p>Si applicano anche altre carenze dell'approccio precedente (come menzionato, ad eccezione delle questioni #1 e #2).</p>
</section>
<section id="option-three-encapsulate-the-domain-concept-and-create-a-value-object">
<h4>Opzione tre - incapsulare il concetto di dominio e creare un &quot;value object&quot;<a class="headerlink" href="#option-three-encapsulate-the-domain-concept-and-create-a-value-object" title="Link to this heading">¶</a></h4>
<p>Penso che sia più che chiaro ora che il nome di un prodotto non è &quot;solo una stringa&quot;, ma un concetto di dominio e come tale merita una classe a parte. Introduciamo quindi una classe di questo tipo e chiamiamola <code class="docutils literal notranslate"><span class="pre">ProductName</span></code>. Le istanze di questa classe avranno il metodo <code class="docutils literal notranslate"><span class="pre">Equals()</span></code> sovrascritto<a class="footnote-reference brackets" href="#csharpoperatorsoverride" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> con la logica specifica dei nomi di prodotto.  Detto questo, lo snippet per il confronto ora è:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">// productName and productName2</span>
<span class="c1">// are both instances of ProductName</span>
<span class="k">if</span><span class="p">(</span><span class="n">productName</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="n">productName2</span><span class="p">))</span>
<span class="p">{</span>
<span class="p">..</span>
</pre></div>
</div>
<p>In cosa differisce dall'approccio precedente in cui avevamo una classe helper, chiamata <code class="docutils literal notranslate"><span class="pre">ProductNameComparison</span></code>? In precedenza i dati del nome di un prodotto erano visibili pubblicamente (come una stringa) e utilizzavamo la classe helper solo per memorizzare una funzione che operava su questi dati (e chiunque poteva creare le proprie funzioni da qualche altra parte senza accorgersi di quelle che avevamo già aggiunto). Questa volta i dati del nome del prodotto sono nascosti<a class="footnote-reference brackets" href="#notcompletelyhidden" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> al mondo esterno. L'unico modo disponibile per operare su questi dati è attraverso l'interfaccia pubblica di <code class="docutils literal notranslate"><span class="pre">ProductName</span></code> (che espone solo i metodi che riteniamo abbiano senso per i nomi dei prodotti e nient'altro). In altre parole, mentre prima avevamo a che fare con un tipo generico che non potevamo cambiare, ora abbiamo un tipo specifico del dominio che è completamente sotto il nostro controllo. Ciò significa che possiamo cambiare liberamente il significato di due nomi uguali e questo cambiamento non si diffonderà in tutto il codice.</p>
<p>Nei capitoli seguenti esplorerò ulteriormente questo esempio di nomi di prodotto per mostrare alcune proprietà degli <em>oggetti valore</em>.</p>
</section>
</section>
</section>
</section>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="goosvalues" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>S. Freeman, N. Pryce, Growing Object-Oriented Software Guided by Tests, Addison-Wesley Professional, 2009</p>
</aside>
<aside class="footnote brackets" id="everydecisionistradeoff" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>Tutte le decisioni ingegneristiche sono comunque dei compromessi, quindi dovrei dire &quot;alcune di esse apportano compromessi migliori nel nostro contesto, mentre altre li peggiorano&quot;.</p>
</aside>
<aside class="footnote brackets" id="csharpoperatorsoverride" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>e, per C#, anche sovrascrivere gli operatori di uguaglianza (<code class="docutils literal notranslate"><span class="pre">==</span></code> e <code class="docutils literal notranslate"><span class="pre">!=</span></code>) è probabilmente una buona idea, per non parlare di <code class="docutils literal notranslate"><span class="pre">GetHashCode()</span></code> (vedere https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/equality-operators)</p>
</aside>
<aside class="footnote brackets" id="notcompletelyhidden" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>In realtà, questo è vero solo in parte. Ad esempio, dovremo comunque sovrascrivere <code class="docutils literal notranslate"><span class="pre">ToString()</span></code> da qualche parte per garantire l'interoperabilità con librerie di terze parti che non conoscono il nostro tipo <code class="docutils literal notranslate"><span class="pre">ProductName</span></code>, ma accetteranno argomenti di tipo stringa. Inoltre, è sempre possibile utilizzare la reflection per ottenere dati privati. Spero che sia chiaro il punto però :-).</p>
</aside>
</aside>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">TDD</a></h1>








<h3>Navigazione</h3>
<p class="caption" role="heading"><span class="caption-text">Contenuti:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Cover.html">Titolo</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Premessa</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html">Premessa</a></li>
<li class="toctree-l1"><a class="reference internal" href="010_Dedication.html#dedications">Dediche</a></li>
<li class="toctree-l1"><a class="reference internal" href="015_Thanks.html">Grazie!</a></li>
<li class="toctree-l1"><a class="reference internal" href="017_CodeExamples.html">I codici di esempio</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 1:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="020_Part1Marker.html">Parte 1: Solo le nozioni di base</a></li>
<li class="toctree-l1"><a class="reference internal" href="030_Motivations.html">Motivazione: il primo passo per imparare il TDD</a></li>
<li class="toctree-l1"><a class="reference internal" href="040_Three_Essential_Tools.html"><span class="xref myst">Gli strumenti essenziali</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="050_Its_Not_a_Test.html">Non è (solo) un test</a></li>
<li class="toctree-l1"><a class="reference internal" href="060_Statement_First_Programming.html">La programmazione Statement-first</a></li>
<li class="toctree-l1"><a class="reference internal" href="070_Practicing_What_We_Already_Learned.html">Mettere in pratica ciò che abbiamo già imparato</a></li>
<li class="toctree-l1"><a class="reference internal" href="080_Sorting_out_the_bits.html">Facciamo un po' d'ordine</a></li>
<li class="toctree-l1"><a class="reference internal" href="090_How_to_start.html">Come iniziare?</a></li>
<li class="toctree-l1"><a class="reference internal" href="100_Analysis_In_TDD.html">In che modo il TDD riguarda l'analisi e cosa significa &quot;GIVEN-WHEN-THEN&quot;?</a></li>
<li class="toctree-l1"><a class="reference internal" href="110_What_is_the_scope_of_a_Statement_in_TDD.html">Qual è lo scopo di uno Statement a livello di unità in TDD?</a></li>
<li class="toctree-l1"><a class="reference internal" href="120_Constrained_Non_Determinism.html">Sviluppare uno stile TDD e Non-Determinismo Vincolato</a></li>
<li class="toctree-l1"><a class="reference internal" href="130_Boundaries.html">Specificare i confini e le condizioni funzionali</a></li>
<li class="toctree-l1"><a class="reference internal" href="140_Triangulation.html">Guidare l'implementazione dalle Specifiche</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 2:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="150_Part2Marker.html">Parte 2: Il Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="160_Composable_Design.html">La Componibilità degli Oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="170_TellDoNotAsk.html"><span class="xref myst">Raccontare, non chiedere</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="180_Web_of_objects_explained.html">La necessità degli oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="190_Why_do_we_need_composability.html">Perché abbiamo bisogno della componibilità?</a></li>
<li class="toctree-l1"><a class="reference internal" href="200_What_does_it_mean_to_compose_objects.html">Reti, messaggi e protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="210_How_are_objects_composed.html">Comporre una rete di oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="211_When_are_objects_composed.html">Quando vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="212_How_are_the_connections_made.html">Come fa un mittente ad ottenere un riferimento a un destinatario (cioè come vengono stabilite le connessioni)?</a></li>
<li class="toctree-l1"><a class="reference internal" href="213_Where_are_objects_composed.html">Dove vengono composti gli oggetti?</a></li>
<li class="toctree-l1"><a class="reference internal" href="220_Designing_for_composabiity_interfaces.html">Interfacce</a></li>
<li class="toctree-l1"><a class="reference internal" href="230_Designing_for_composabiity_protocols.html">Protocolli</a></li>
<li class="toctree-l1"><a class="reference internal" href="235_Classes.html">Le Classi</a></li>
<li class="toctree-l1"><a class="reference internal" href="240_Refactoring_Object_Composition.html">Composizione di Oggetti come Linguaggio</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Gli <em>Oggetti Valore</em></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-is-a-value-object">Cos'è un <em>oggetto valore</em>?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-money-and-names">Esempio: soldi e nomi</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="255_Value_Objects_properties.html">Anatomia del <em>oggetto valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="257_Value%20objects_general_topics.html">Aspetti del design degli <em>oggetti valore</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html">Oggetti di Trasferimento Dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-behavior">Disaccoppiamento mediante l'astrazione del comportamento</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#decoupling-by-abstracting-data">Disaccoppiamento mediante l'astrazione dei dati</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#use-both">Usare entrambi</a></li>
<li class="toctree-l1"><a class="reference internal" href="259_DataTransferObjects.html#dto-as-data-centric-decoupling-mechanism">DTO come meccanismo di disaccoppiamento incentrato sui dati</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 3:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="260_Part3Marker.html">Parte 3: TDD nel Mondo Object-Oriented</a></li>
<li class="toctree-l1"><a class="reference internal" href="270_Mock_Objects.html">Oggetti Mock come strumento di test</a></li>
<li class="toctree-l1"><a class="reference internal" href="280_Start_with_a_failing_test_mocks.html">Test-first  [<em>Testare prima</em>] utilizzando oggetti mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="290_NeedDrivenDevelopment.html">Il test-driving ai confini di input</a></li>
<li class="toctree-l1"><a class="reference internal" href="300_NeedDrivenRetrospective1.html">Il test-driving ai confini di input -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="310_Test_Driving_Factories.html">Creazione di oggetti &quot;test-driving&quot;</a></li>
<li class="toctree-l1"><a class="reference internal" href="320_Test_Driving_Factories_retrospective.html">Creazione di oggetti &quot;test-driving&quot; -- una retrospettiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="330_Test-Driving_Command.html">Logica dell'applicazione test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="340_Test-Driving_Value_object.html"><em>Oggetti valore</em> nel test-driving</a></li>
<li class="toctree-l1"><a class="reference internal" href="350_Web_of_objects_boundaries.html">Raggiungere la rete dei confini degli oggetti</a></li>
<li class="toctree-l1"><a class="reference internal" href="360_Internals.html">Cosa c'è dentro l'oggetto?</a></li>
<li class="toctree-l1"><a class="reference internal" href="370_Design_smells.html">Odori del design visibile nella Specifica</a></li>
<li class="toctree-l1"><a class="reference internal" href="End.html">QUESTO È TUTTO QUELLO CHE HO PER ORA. QUELLO CHE SEGUE È MATERIALE GREZZO, NON ORDINATO, NON ANCORA PRONTO PER ESSERE CONSUMATO COME PARTE DI QUESTO TUTORIAL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 5:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html">Mock di oggetti come strumento di progettazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#guidance-of-test-smells">Guidaa ai test smells [<em>puzzolenti</em>]</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#revisiting-topics-from-chapter-1">Rivedere gli argomenti del capitolo 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#maintainable-mock-based-statements">Statement manutenibili basate su mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#refactoring-mock-code">Refactoring del codice mock</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-4-application-architecture">Parte 4: Architettura dell'applicazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#on-stable-architectural-boundaries">Sui confini stabili/architetturali</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#ports-and-adapters">[Port] e adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-application">Cosa entra in applicazione?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#what-goes-into-ports">Cosa va nei [port]?</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#part-5-tdd-on-application-architecture-level">Parte 5: TDD a livello di architettura applicativa</a></li>
<li class="toctree-l1"><a class="reference internal" href="400_Dealing_with_3rd_party.html#designing-automation-layer">Progettazione del layer di automazione</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Parte 9:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="990_Further_reading.html"><span class="xref myst">Ulteriori Letture</span></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="240_Refactoring_Object_Composition.html" title="capitolo precedente">Composizione di Oggetti come Linguaggio</a></li>
      <li>Next: <a href="255_Value_Objects_properties.html" title="capitolo successivo">Anatomia del <em>oggetto valore</em></a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Ricerca veloce</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Vai" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Grzegorz GaÅ‚Ä™zowski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/manuscript/250_Value_Objects.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>